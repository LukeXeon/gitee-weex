// { "framework": "Vue"} 

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 63);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*
                                                                                                                                                                                                                                                                                * Licensed to the Apache Software Foundation (ASF) under one
                                                                                                                                                                                                                                                                                * or more contributor license agreements.  See the NOTICE file
                                                                                                                                                                                                                                                                                * distributed with this work for additional information
                                                                                                                                                                                                                                                                                * regarding copyright ownership.  The ASF licenses this file
                                                                                                                                                                                                                                                                                * to you under the Apache License, Version 2.0 (the
                                                                                                                                                                                                                                                                                * "License"); you may not use this file except in compliance
                                                                                                                                                                                                                                                                                * with the License.  You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                *   http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing,
                                                                                                                                                                                                                                                                                * software distributed under the License is distributed on an
                                                                                                                                                                                                                                                                                * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
                                                                                                                                                                                                                                                                                * KIND, either express or implied.  See the License for the
                                                                                                                                                                                                                                                                                * specific language governing permissions and limitations
                                                                                                                                                                                                                                                                                * under the License.
                                                                                                                                                                                                                                                                                */

var _urlParse = __webpack_require__(89);

var _urlParse2 = _interopRequireDefault(_urlParse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Utils = {
  UrlParser: _urlParse2.default,
  _typeof: function _typeof(obj) {
    return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
  },
  isPlainObject: function isPlainObject(obj) {
    return Utils._typeof(obj) === 'object';
  },
  isString: function isString(obj) {
    return typeof obj === 'string';
  },
  isNonEmptyArray: function isNonEmptyArray() {
    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    return obj && obj.length > 0 && Array.isArray(obj) && typeof obj !== 'undefined';
  },
  isObject: function isObject(item) {
    return item && (typeof item === 'undefined' ? 'undefined' : _typeof2(item)) === 'object' && !Array.isArray(item);
  },
  isEmptyObject: function isEmptyObject(obj) {
    return Object.keys(obj).length === 0 && obj.constructor === Object;
  },
  decodeIconFont: function decodeIconFont(text) {
    // 正则匹配 图标和文字混排 eg: 我去上学校&#xe600;,天天不&#xe600;迟到
    var regExp = /&#x[a-z|0-9]{4,5};?/g;
    if (regExp.test(text)) {
      return text.replace(new RegExp(regExp, 'g'), function (iconText) {
        var replace = iconText.replace(/&#x/, '0x').replace(/;$/, '');
        return String.fromCharCode(replace);
      });
    } else {
      return text;
    }
  },
  mergeDeep: function mergeDeep(target) {
    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }

    if (!sources.length) return target;
    var source = sources.shift();
    if (Utils.isObject(target) && Utils.isObject(source)) {
      for (var key in source) {
        if (Utils.isObject(source[key])) {
          if (!target[key]) {
            Object.assign(target, _defineProperty({}, key, {}));
          }
          Utils.mergeDeep(target[key], source[key]);
        } else {
          Object.assign(target, _defineProperty({}, key, source[key]));
        }
      }
    }
    return Utils.mergeDeep.apply(Utils, [target].concat(sources));
  },
  appendProtocol: function appendProtocol(url) {
    if (/^\/\//.test(url)) {
      var bundleUrl = weex.config.bundleUrl;

      return 'http' + (/^https:/.test(bundleUrl) ? 's' : '') + ':' + url;
    }
    return url;
  },
  encodeURLParams: function encodeURLParams(url) {
    var parsedUrl = new _urlParse2.default(url, true);
    return parsedUrl.toString();
  },
  goToH5Page: function goToH5Page(jumpUrl) {
    var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    var Navigator = weex.requireModule('navigator');
    var jumpUrlObj = new Utils.UrlParser(jumpUrl, true);
    var url = Utils.appendProtocol(jumpUrlObj.toString());
    Navigator.push({
      url: Utils.encodeURLParams(url),
      animated: animated.toString()
    }, callback);
  },

  env: {
    isTaobao: function isTaobao() {
      var appName = weex.config.env.appName;

      return (/(tb|taobao|淘宝)/i.test(appName)
      );
    },
    isTrip: function isTrip() {
      var appName = weex.config.env.appName;

      return appName === 'LX';
    },
    isBoat: function isBoat() {
      var appName = weex.config.env.appName;

      return appName === 'Boat' || appName === 'BoatPlayground';
    },
    isWeb: function isWeb() {
      var platform = weex.config.env.platform;

      return (typeof window === 'undefined' ? 'undefined' : _typeof2(window)) === 'object' && platform.toLowerCase() === 'web';
    },
    isIOS: function isIOS() {
      var platform = weex.config.env.platform;

      return platform.toLowerCase() === 'ios';
    },

    /**
     * 是否为 iPhone X or iPhoneXS or iPhoneXR or iPhoneXS Max
     * @returns {boolean}
     */
    isIPhoneX: function isIPhoneX() {
      var deviceHeight = weex.config.env.deviceHeight;

      if (Utils.env.isWeb()) {
        return (typeof window === 'undefined' ? 'undefined' : _typeof2(window)) !== undefined && window.screen && window.screen.width && window.screen.height && (parseInt(window.screen.width, 10) === 375 && parseInt(window.screen.height, 10) === 812 || parseInt(window.screen.width, 10) === 414 && parseInt(window.screen.height, 10) === 896);
      }
      return Utils.env.isIOS() && (deviceHeight === 2436 || deviceHeight === 2688 || deviceHeight === 1792 || deviceHeight === 1624);
    },
    isAndroid: function isAndroid() {
      var platform = weex.config.env.platform;

      return platform.toLowerCase() === 'android';
    },
    isTmall: function isTmall() {
      var appName = weex.config.env.appName;

      return (/(tm|tmall|天猫)/i.test(appName)
      );
    },
    isAliWeex: function isAliWeex() {
      return Utils.env.isTmall() || Utils.env.isTrip() || Utils.env.isTaobao();
    },

    /**
     * 获取weex屏幕真实的设置高度，需要减去导航栏高度
     * @returns {Number}
     */
    getPageHeight: function getPageHeight() {
      var env = weex.config.env;

      var navHeight = Utils.env.isWeb() ? 0 : Utils.env.isIPhoneX() ? 176 : 132;
      return env.deviceHeight / env.deviceWidth * 750 - navHeight;
    },

    /**
     * 获取weex屏幕真实的设置高度
     * @returns {Number}
     */
    getScreenHeight: function getScreenHeight() {
      var env = weex.config.env;

      return env.deviceHeight / env.deviceWidth * 750;
    }
  },

  /**
   * 版本号比较
   * @memberOf Utils
   * @param currVer {string}
   * @param promoteVer {string}
   * @returns {boolean}
   * @example
   *
   * const { Utils } = require('@ali/wx-bridge');
   * const { compareVersion } = Utils;
   * console.log(compareVersion('0.1.100', '0.1.11')); // 'true'
   */
  compareVersion: function compareVersion() {
    var currVer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '0.0.0';
    var promoteVer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '0.0.0';

    if (currVer === promoteVer) return true;
    var currVerArr = currVer.split('.');
    var promoteVerArr = promoteVer.split('.');
    var len = Math.max(currVerArr.length, promoteVerArr.length);
    for (var i = 0; i < len; i++) {
      var proVal = ~~promoteVerArr[i];
      var curVal = ~~currVerArr[i];
      if (proVal < curVal) {
        return true;
      } else if (proVal > curVal) {
        return false;
      }
    }
    return false;
  },

  /**
   * 分割数组
   * @param arr 被分割数组
   * @param size 分割数组的长度
   * @returns {Array}
   */
  arrayChunk: function arrayChunk() {
    var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;

    var groups = [];
    if (arr && arr.length > 0) {
      groups = arr.map(function (e, i) {
        return i % size === 0 ? arr.slice(i, i + size) : null;
      }).filter(function (e) {
        return e;
      });
    }
    return groups;
  },

  /*
   * 截断字符串
   * @param str 传入字符串
   * @param len 截断长度
   * @param hasDot 末尾是否...
   * @returns {String}
   */
  truncateString: function truncateString(str, len) {
    var hasDot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    var newLength = 0;
    var newStr = '';
    var singleChar = '';
    var chineseRegex = /[^\x00-\xff]/g;
    var strLength = str.replace(chineseRegex, '**').length;
    for (var i = 0; i < strLength; i++) {
      singleChar = str.charAt(i).toString();
      if (singleChar.match(chineseRegex) !== null) {
        newLength += 2;
      } else {
        newLength++;
      }
      if (newLength > len) {
        break;
      }
      newStr += singleChar;
    }

    if (hasDot && strLength > len) {
      newStr += '...';
    }
    return newStr;
  },

  /*
   * 转换 obj 为 url params参数
   * @param obj 传入字符串
   * @returns {String}
   */
  objToParams: function objToParams(obj) {
    var str = '';
    for (var key in obj) {
      if (str !== '') {
        str += '&';
      }
      str += key + '=' + encodeURIComponent(obj[key]);
    }
    return str;
  },

  /*
   * 转换 url params参数为obj
   * @param str 传入url参数字符串
   * @returns {Object}
   */
  paramsToObj: function paramsToObj(str) {
    var obj = {};
    try {
      obj = JSON.parse('{"' + decodeURI(str).replace(/"/g, '\\"').replace(/&/g, '","').replace(/=/g, '":"') + '"}');
    } catch (e) {
      console.log(e);
    }
    return obj;
  },

  animation: {
    /**
     * 返回定义页面转场动画起初的位置
     * @param ref
     * @param transform 运动类型
     * @param status
     * @param callback 回调函数
     */
    pageTransitionAnimation: function pageTransitionAnimation(ref, transform, status, callback) {
      var animation = weex.requireModule('animation');
      animation.transition(ref, {
        styles: {
          transform: transform
        },
        duration: status ? 250 : 300, // ms
        timingFunction: status ? 'ease-in' : 'ease-out',
        delay: 0 // ms
      }, function () {
        callback && callback();
      });
    }
  },
  uiStyle: {
    /**
     * 返回定义页面转场动画起初的位置
     * @param animationType 页面转场动画的类型 push，model
     * @param size 分割数组的长度
     * @returns {}
     */
    pageTransitionAnimationStyle: function pageTransitionAnimationStyle(animationType) {
      if (animationType === 'push') {
        return {
          left: '750px',
          top: '0px',
          height: weex.config.env.deviceHeight / weex.config.env.deviceWidth * 750 + 'px'
        };
      } else if (animationType === 'model') {
        return {
          top: weex.config.env.deviceHeight / weex.config.env.deviceWidth * 750 + 'px',
          left: '0px',
          height: weex.config.env.deviceHeight / weex.config.env.deviceWidth * 750 + 'px'
        };
      }
      return {};
    }
  }
};

exports.default = Utils;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DOMException = __webpack_require__(17);
var ERR = DOMException;
var isApiWritable = __webpack_require__(18).isApiWritable;

exports.NAMESPACE = {
  HTML: 'http://www.w3.org/1999/xhtml',
  XML: 'http://www.w3.org/XML/1998/namespace',
  XMLNS: 'http://www.w3.org/2000/xmlns/',
  MATHML: 'http://www.w3.org/1998/Math/MathML',
  SVG: 'http://www.w3.org/2000/svg',
  XLINK: 'http://www.w3.org/1999/xlink'
};

//
// Shortcut functions for throwing errors of various types.
//
exports.IndexSizeError = function () {
  throw new DOMException(ERR.INDEX_SIZE_ERR);
};
exports.HierarchyRequestError = function () {
  throw new DOMException(ERR.HIERARCHY_REQUEST_ERR);
};
exports.WrongDocumentError = function () {
  throw new DOMException(ERR.WRONG_DOCUMENT_ERR);
};
exports.InvalidCharacterError = function () {
  throw new DOMException(ERR.INVALID_CHARACTER_ERR);
};
exports.NoModificationAllowedError = function () {
  throw new DOMException(ERR.NO_MODIFICATION_ALLOWED_ERR);
};
exports.NotFoundError = function () {
  throw new DOMException(ERR.NOT_FOUND_ERR);
};
exports.NotSupportedError = function () {
  throw new DOMException(ERR.NOT_SUPPORTED_ERR);
};
exports.InvalidStateError = function () {
  throw new DOMException(ERR.INVALID_STATE_ERR);
};
exports.SyntaxError = function () {
  throw new DOMException(ERR.SYNTAX_ERR);
};
exports.InvalidModificationError = function () {
  throw new DOMException(ERR.INVALID_MODIFICATION_ERR);
};
exports.NamespaceError = function () {
  throw new DOMException(ERR.NAMESPACE_ERR);
};
exports.InvalidAccessError = function () {
  throw new DOMException(ERR.INVALID_ACCESS_ERR);
};
exports.TypeMismatchError = function () {
  throw new DOMException(ERR.TYPE_MISMATCH_ERR);
};
exports.SecurityError = function () {
  throw new DOMException(ERR.SECURITY_ERR);
};
exports.NetworkError = function () {
  throw new DOMException(ERR.NETWORK_ERR);
};
exports.AbortError = function () {
  throw new DOMException(ERR.ABORT_ERR);
};
exports.UrlMismatchError = function () {
  throw new DOMException(ERR.URL_MISMATCH_ERR);
};
exports.QuotaExceededError = function () {
  throw new DOMException(ERR.QUOTA_EXCEEDED_ERR);
};
exports.TimeoutError = function () {
  throw new DOMException(ERR.TIMEOUT_ERR);
};
exports.InvalidNodeTypeError = function () {
  throw new DOMException(ERR.INVALID_NODE_TYPE_ERR);
};
exports.DataCloneError = function () {
  throw new DOMException(ERR.DATA_CLONE_ERR);
};

exports.nyi = function () {
  throw new Error("NotYetImplemented");
};

exports.shouldOverride = function () {
  throw new Error("Abstract function; should be overriding in subclass.");
};

exports.assert = function (expr, msg) {
  if (!expr) {
    throw new Error("Assertion failed: " + (msg || "") + "\n" + new Error().stack);
  }
};

exports.expose = function (src, c) {
  for (var n in src) {
    Object.defineProperty(c.prototype, n, { value: src[n], writable: isApiWritable });
  }
};

exports.merge = function (a, b) {
  for (var n in b) {
    a[n] = b[n];
  }
};

// Compare two nodes based on their document order. This function is intended
// to be passed to sort(). Assumes that the array being sorted does not
// contain duplicates.  And that all nodes are connected and comparable.
// Clever code by ppk via jeresig.
exports.documentOrder = function (n, m) {
  /* jshint bitwise: false */
  return 3 - (n.compareDocumentPosition(m) & 6);
};

exports.toASCIILowerCase = function (s) {
  return s.replace(/[A-Z]+/g, function (c) {
    return c.toLowerCase();
  });
};

exports.toASCIIUpperCase = function (s) {
  return s.replace(/[a-z]+/g, function (c) {
    return c.toUpperCase();
  });
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Node;

var EventTarget = __webpack_require__(32);
var LinkedList = __webpack_require__(35);
var NodeUtils = __webpack_require__(36);
var utils = __webpack_require__(1);

// All nodes have a nodeType and an ownerDocument.
// Once inserted, they also have a parentNode.
// This is an abstract class; all nodes in a document are instances
// of a subtype, so all the properties are defined by more specific
// constructors.
function Node() {
  EventTarget.call(this);
  this.parentNode = null;
  this._nextSibling = this._previousSibling = this;
  this._index = undefined;
}

var ELEMENT_NODE = Node.ELEMENT_NODE = 1;
var ATTRIBUTE_NODE = Node.ATTRIBUTE_NODE = 2;
var TEXT_NODE = Node.TEXT_NODE = 3;
var CDATA_SECTION_NODE = Node.CDATA_SECTION_NODE = 4;
var ENTITY_REFERENCE_NODE = Node.ENTITY_REFERENCE_NODE = 5;
var ENTITY_NODE = Node.ENTITY_NODE = 6;
var PROCESSING_INSTRUCTION_NODE = Node.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE = Node.COMMENT_NODE = 8;
var DOCUMENT_NODE = Node.DOCUMENT_NODE = 9;
var DOCUMENT_TYPE_NODE = Node.DOCUMENT_TYPE_NODE = 10;
var DOCUMENT_FRAGMENT_NODE = Node.DOCUMENT_FRAGMENT_NODE = 11;
var NOTATION_NODE = Node.NOTATION_NODE = 12;

var DOCUMENT_POSITION_DISCONNECTED = Node.DOCUMENT_POSITION_DISCONNECTED = 0x01;
var DOCUMENT_POSITION_PRECEDING = Node.DOCUMENT_POSITION_PRECEDING = 0x02;
var DOCUMENT_POSITION_FOLLOWING = Node.DOCUMENT_POSITION_FOLLOWING = 0x04;
var DOCUMENT_POSITION_CONTAINS = Node.DOCUMENT_POSITION_CONTAINS = 0x08;
var DOCUMENT_POSITION_CONTAINED_BY = Node.DOCUMENT_POSITION_CONTAINED_BY = 0x10;
var DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;

Node.prototype = Object.create(EventTarget.prototype, {

  // Node that are not inserted into the tree inherit a null parent

  // XXX: the baseURI attribute is defined by dom core, but
  // a correct implementation of it requires HTML features, so
  // we'll come back to this later.
  baseURI: { get: utils.nyi },

  parentElement: { get: function get() {
      return this.parentNode && this.parentNode.nodeType === ELEMENT_NODE ? this.parentNode : null;
    } },

  hasChildNodes: { value: utils.shouldOverride },

  firstChild: { get: utils.shouldOverride },

  lastChild: { get: utils.shouldOverride },

  previousSibling: { get: function get() {
      var parent = this.parentNode;
      if (!parent) return null;
      if (this === parent.firstChild) return null;
      return this._previousSibling;
    } },

  nextSibling: { get: function get() {
      var parent = this.parentNode,
          next = this._nextSibling;
      if (!parent) return null;
      if (next === parent.firstChild) return null;
      return next;
    } },

  textContent: {
    // Should override for DocumentFragment/Element/Attr/Text/PI/Comment
    get: function get() {
      return null;
    },
    set: function set(v) {/* do nothing */}
  },

  _countChildrenOfType: { value: function value(type) {
      var sum = 0;
      for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
        if (kid.nodeType === type) sum++;
      }
      return sum;
    } },

  _ensureInsertValid: { value: function _ensureInsertValid(node, child, isPreinsert) {
      var parent = this,
          i,
          kid;
      if (!node.nodeType) throw new TypeError('not a node');
      // 1. If parent is not a Document, DocumentFragment, or Element
      // node, throw a HierarchyRequestError.
      switch (parent.nodeType) {
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
        case ELEMENT_NODE:
          break;
        default:
          utils.HierarchyRequestError();
      }
      // 2. If node is a host-including inclusive ancestor of parent,
      // throw a HierarchyRequestError.
      if (node.isAncestor(parent)) utils.HierarchyRequestError();
      // 3. If child is not null and its parent is not parent, then
      // throw a NotFoundError. (replaceChild omits the 'child is not null'
      // and throws a TypeError here if child is null.)
      if (child !== null || !isPreinsert) {
        if (child.parentNode !== parent) utils.NotFoundError();
      }
      // 4. If node is not a DocumentFragment, DocumentType, Element,
      // Text, ProcessingInstruction, or Comment node, throw a
      // HierarchyRequestError.
      switch (node.nodeType) {
        case DOCUMENT_FRAGMENT_NODE:
        case DOCUMENT_TYPE_NODE:
        case ELEMENT_NODE:
        case TEXT_NODE:
        case PROCESSING_INSTRUCTION_NODE:
        case COMMENT_NODE:
          break;
        default:
          utils.HierarchyRequestError();
      }
      // 5. If either node is a Text node and parent is a document, or
      // node is a doctype and parent is not a document, throw a
      // HierarchyRequestError.
      // 6. If parent is a document, and any of the statements below, switched
      // on node, are true, throw a HierarchyRequestError.
      if (parent.nodeType === DOCUMENT_NODE) {
        switch (node.nodeType) {
          case TEXT_NODE:
            utils.HierarchyRequestError();
            break;
          case DOCUMENT_FRAGMENT_NODE:
            // 6a1. If node has more than one element child or has a Text
            // node child.
            if (node._countChildrenOfType(TEXT_NODE) > 0) utils.HierarchyRequestError();
            switch (node._countChildrenOfType(ELEMENT_NODE)) {
              case 0:
                break;
              case 1:
                // 6a2. Otherwise, if node has one element child and either
                // parent has an element child, child is a doctype, or child
                // is not null and a doctype is following child. [preinsert]
                // 6a2. Otherwise, if node has one element child and either
                // parent has an element child that is not child or a
                // doctype is following child. [replaceWith]
                if (child !== null /* always true here for replaceWith */) {
                    if (isPreinsert && child.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();
                    for (kid = child.nextSibling; kid !== null; kid = kid.nextSibling) {
                      if (kid.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();
                    }
                  }
                i = parent._countChildrenOfType(ELEMENT_NODE);
                if (isPreinsert) {
                  // "parent has an element child"
                  if (i > 0) utils.HierarchyRequestError();
                } else {
                  // "parent has an element child that is not child"
                  if (i > 1 || i === 1 && child.nodeType !== ELEMENT_NODE) utils.HierarchyRequestError();
                }
                break;
              default:
                // 6a1, continued. (more than one Element child)
                utils.HierarchyRequestError();
            }
            break;
          case ELEMENT_NODE:
            // 6b. parent has an element child, child is a doctype, or
            // child is not null and a doctype is following child. [preinsert]
            // 6b. parent has an element child that is not child or a
            // doctype is following child. [replaceWith]
            if (child !== null /* always true here for replaceWith */) {
                if (isPreinsert && child.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();
                for (kid = child.nextSibling; kid !== null; kid = kid.nextSibling) {
                  if (kid.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();
                }
              }
            i = parent._countChildrenOfType(ELEMENT_NODE);
            if (isPreinsert) {
              // "parent has an element child"
              if (i > 0) utils.HierarchyRequestError();
            } else {
              // "parent has an element child that is not child"
              if (i > 1 || i === 1 && child.nodeType !== ELEMENT_NODE) utils.HierarchyRequestError();
            }
            break;
          case DOCUMENT_TYPE_NODE:
            // 6c. parent has a doctype child, child is non-null and an
            // element is preceding child, or child is null and parent has
            // an element child. [preinsert]
            // 6c. parent has a doctype child that is not child, or an
            // element is preceding child. [replaceWith]
            if (child === null) {
              if (parent._countChildrenOfType(ELEMENT_NODE)) utils.HierarchyRequestError();
            } else {
              // child is always non-null for [replaceWith] case
              for (kid = parent.firstChild; kid !== null; kid = kid.nextSibling) {
                if (kid === child) break;
                if (kid.nodeType === ELEMENT_NODE) utils.HierarchyRequestError();
              }
            }
            i = parent._countChildrenOfType(DOCUMENT_TYPE_NODE);
            if (isPreinsert) {
              // "parent has an doctype child"
              if (i > 0) utils.HierarchyRequestError();
            } else {
              // "parent has an doctype child that is not child"
              if (i > 1 || i === 1 && child.nodeType !== DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();
            }
            break;
        }
      } else {
        // 5, continued: (parent is not a document)
        if (node.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();
      }
    } },

  insertBefore: { value: function insertBefore(node, child) {
      var parent = this;
      // 1. Ensure pre-insertion validity
      parent._ensureInsertValid(node, child, true);
      // 2. Let reference child be child.
      var refChild = child;
      // 3. If reference child is node, set it to node's next sibling
      if (refChild === node) {
        refChild = node.nextSibling;
      }
      // 4. Adopt node into parent's node document.
      parent.doc.adoptNode(node);
      // 5. Insert node into parent before reference child.
      node._insertOrReplace(parent, refChild, false);
      // 6. Return node
      return node;
    } },

  appendChild: { value: function value(child) {
      // This invokes _appendChild after doing validity checks.
      return this.insertBefore(child, null);
    } },

  _appendChild: { value: function value(child) {
      child._insertOrReplace(this, null, false);
    } },

  removeChild: { value: function removeChild(child) {
      var parent = this;
      if (!child.nodeType) throw new TypeError('not a node');
      if (child.parentNode !== parent) utils.NotFoundError();
      child.remove();
      return child;
    } },

  // To replace a `child` with `node` within a `parent` (this)
  replaceChild: { value: function replaceChild(node, child) {
      var parent = this;
      // Ensure validity (slight differences from pre-insertion check)
      parent._ensureInsertValid(node, child, false);
      // Adopt node into parent's node document.
      if (node.doc !== parent.doc) {
        // XXX adoptNode has side-effect of removing node from its parent
        // and generating a mutation event, thus causing the _insertOrReplace
        // to generate two deletes and an insert instead of a 'move'
        // event.  It looks like the new MutationObserver stuff avoids
        // this problem, but for now let's only adopt (ie, remove `node`
        // from its parent) here if we need to.
        parent.doc.adoptNode(node);
      }
      // Do the replace.
      node._insertOrReplace(parent, child, true);
      return child;
    } },

  // See: http://ejohn.org/blog/comparing-document-position/
  contains: { value: function contains(node) {
      if (node === null) {
        return false;
      }
      if (this === node) {
        return true; /* inclusive descendant */
      }
      /* jshint bitwise: false */
      return (this.compareDocumentPosition(node) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
    } },

  compareDocumentPosition: { value: function compareDocumentPosition(that) {
      // Basic algorithm for finding the relative position of two nodes.
      // Make a list the ancestors of each node, starting with the
      // document element and proceeding down to the nodes themselves.
      // Then, loop through the lists, looking for the first element
      // that differs.  The order of those two elements give the
      // order of their descendant nodes.  Or, if one list is a prefix
      // of the other one, then that node contains the other.

      if (this === that) return 0;

      // If they're not owned by the same document or if one is rooted
      // and one is not, then they're disconnected.
      if (this.doc !== that.doc || this.rooted !== that.rooted) return DOCUMENT_POSITION_DISCONNECTED + DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;

      // Get arrays of ancestors for this and that
      var these = [],
          those = [];
      for (var n = this; n !== null; n = n.parentNode) {
        these.push(n);
      }for (n = that; n !== null; n = n.parentNode) {
        those.push(n);
      }these.reverse(); // So we start with the outermost
      those.reverse();

      if (these[0] !== those[0]) // No common ancestor
        return DOCUMENT_POSITION_DISCONNECTED + DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;

      n = Math.min(these.length, those.length);
      for (var i = 1; i < n; i++) {
        if (these[i] !== those[i]) {
          // We found two different ancestors, so compare
          // their positions
          if (these[i].index < those[i].index) return DOCUMENT_POSITION_FOLLOWING;else return DOCUMENT_POSITION_PRECEDING;
        }
      }

      // If we get to here, then one of the nodes (the one with the
      // shorter list of ancestors) contains the other one.
      if (these.length < those.length) return DOCUMENT_POSITION_FOLLOWING + DOCUMENT_POSITION_CONTAINED_BY;else return DOCUMENT_POSITION_PRECEDING + DOCUMENT_POSITION_CONTAINS;
    } },

  isSameNode: { value: function isSameNode(node) {
      return this === node;
    } },

  // This method implements the generic parts of node equality testing
  // and defers to the (non-recursive) type-specific isEqual() method
  // defined by subclasses
  isEqualNode: { value: function isEqualNode(node) {
      if (!node) return false;
      if (node.nodeType !== this.nodeType) return false;

      // Check type-specific properties for equality
      if (!this.isEqual(node)) return false;

      // Now check children for number and equality
      for (var c1 = this.firstChild, c2 = node.firstChild; c1 && c2; c1 = c1.nextSibling, c2 = c2.nextSibling) {
        if (!c1.isEqualNode(c2)) return false;
      }
      return c1 === null && c2 === null;
    } },

  // This method delegates shallow cloning to a clone() method
  // that each concrete subclass must implement
  cloneNode: { value: function value(deep) {
      // Clone this node
      var clone = this.clone();

      // Handle the recursive case if necessary
      if (deep) {
        for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
          clone._appendChild(kid.cloneNode(true));
        }
      }

      return clone;
    } },

  lookupPrefix: { value: function lookupPrefix(ns) {
      var e;
      if (ns === '' || ns === null || ns === undefined) return null;
      switch (this.nodeType) {
        case ELEMENT_NODE:
          return this._lookupNamespacePrefix(ns, this);
        case DOCUMENT_NODE:
          e = this.documentElement;
          return e ? e.lookupPrefix(ns) : null;
        case ENTITY_NODE:
        case NOTATION_NODE:
        case DOCUMENT_FRAGMENT_NODE:
        case DOCUMENT_TYPE_NODE:
          return null;
        case ATTRIBUTE_NODE:
          e = this.ownerElement;
          return e ? e.lookupPrefix(ns) : null;
        default:
          e = this.parentElement;
          return e ? e.lookupPrefix(ns) : null;
      }
    } },

  lookupNamespaceURI: { value: function lookupNamespaceURI(prefix) {
      if (prefix === '' || prefix === undefined) {
        prefix = null;
      }
      var e;
      switch (this.nodeType) {
        case ELEMENT_NODE:
          return utils.shouldOverride();
        case DOCUMENT_NODE:
          e = this.documentElement;
          return e ? e.lookupNamespaceURI(prefix) : null;
        case ENTITY_NODE:
        case NOTATION_NODE:
        case DOCUMENT_TYPE_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          return null;
        case ATTRIBUTE_NODE:
          e = this.ownerElement;
          return e ? e.lookupNamespaceURI(prefix) : null;
        default:
          e = this.parentElement;
          return e ? e.lookupNamespaceURI(prefix) : null;
      }
    } },

  isDefaultNamespace: { value: function isDefaultNamespace(ns) {
      if (ns === '' || ns === undefined) {
        ns = null;
      }
      var defaultNamespace = this.lookupNamespaceURI(null);
      return defaultNamespace === ns;
    } },

  // Utility methods for nodes.  Not part of the DOM

  // Return the index of this node in its parent.
  // Throw if no parent, or if this node is not a child of its parent
  index: { get: function get() {
      var parent = this.parentNode;
      if (this === parent.firstChild) return 0; // fast case
      var kids = parent.childNodes;
      if (this._index === undefined || kids[this._index] !== this) {
        // Ensure that we don't have an O(N^2) blowup if none of the
        // kids have defined indices yet and we're traversing via
        // nextSibling or previousSibling
        for (var i = 0; i < kids.length; i++) {
          kids[i]._index = i;
        }
        utils.assert(kids[this._index] === this);
      }
      return this._index;
    } },

  // Return true if this node is equal to or is an ancestor of that node
  // Note that nodes are considered to be ancestors of themselves
  isAncestor: { value: function value(that) {
      // If they belong to different documents, then they're unrelated.
      if (this.doc !== that.doc) return false;
      // If one is rooted and one isn't then they're not related
      if (this.rooted !== that.rooted) return false;

      // Otherwise check by traversing the parentNode chain
      for (var e = that; e; e = e.parentNode) {
        if (e === this) return true;
      }
      return false;
    } },

  // DOMINO Changed the behavior to conform with the specs. See:
  // https://groups.google.com/d/topic/mozilla.dev.platform/77sIYcpdDmc/discussion
  ensureSameDoc: { value: function value(that) {
      if (that.ownerDocument === null) {
        that.ownerDocument = this.doc;
      } else if (that.ownerDocument !== this.doc) {
        utils.WrongDocumentError();
      }
    } },

  removeChildren: { value: utils.shouldOverride },

  // Insert this node as a child of parent before the specified child,
  // or insert as the last child of parent if specified child is null,
  // or replace the specified child with this node, firing mutation events as
  // necessary
  _insertOrReplace: { value: function _insertOrReplace(parent, before, isReplace) {
      var child = this,
          before_index,
          i;

      if (child.nodeType === DOCUMENT_FRAGMENT_NODE && child.rooted) {
        utils.HierarchyRequestError();
      }

      /* Ensure index of `before` is cached before we (possibly) remove it. */
      if (parent._childNodes) {
        before_index = before === null ? parent._childNodes.length : before.index; /* ensure _index is cached */

        // If we are already a child of the specified parent, then
        // the index may have to be adjusted.
        if (child.parentNode === parent) {
          var child_index = child.index;
          // If the child is before the spot it is to be inserted at,
          // then when it is removed, the index of that spot will be
          // reduced.
          if (child_index < before_index) {
            before_index--;
          }
        }
      }

      // Delete the old child
      if (isReplace) {
        if (before.rooted) before.doc.mutateRemove(before);
        before.parentNode = null;
      }

      var n = before;
      if (n === null) {
        n = parent.firstChild;
      }

      // If both the child and the parent are rooted, then we want to
      // transplant the child without uprooting and rerooting it.
      var bothRooted = child.rooted && parent.rooted;
      if (child.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var spliceArgs = [0, isReplace ? 1 : 0],
            next;
        for (var kid = child.firstChild; kid !== null; kid = next) {
          next = kid.nextSibling;
          spliceArgs.push(kid);
          kid.parentNode = parent;
        }
        var len = spliceArgs.length;
        // Add all nodes to the new parent, overwriting the old child
        if (isReplace) {
          LinkedList.replace(n, len > 2 ? spliceArgs[2] : null);
        } else if (len > 2 && n !== null) {
          LinkedList.insertBefore(spliceArgs[2], n);
        }
        if (parent._childNodes) {
          spliceArgs[0] = before === null ? parent._childNodes.length : before._index;
          parent._childNodes.splice.apply(parent._childNodes, spliceArgs);
          for (i = 2; i < len; i++) {
            spliceArgs[i]._index = spliceArgs[0] + (i - 2);
          }
        } else if (parent._firstChild === before) {
          if (len > 2) {
            parent._firstChild = spliceArgs[2];
          } else if (isReplace) {
            parent._firstChild = null;
          }
        }
        // Remove all nodes from the document fragment
        if (child._childNodes) {
          child._childNodes.length = 0;
        } else {
          child._firstChild = null;
        }
        // Call the mutation handlers
        // Use spliceArgs since the original array has been destroyed. The
        // liveness guarantee requires us to clone the array so that
        // references to the childNodes of the DocumentFragment will be empty
        // when the insertion handlers are called.
        if (parent.rooted) {
          parent.modify();
          for (i = 2; i < len; i++) {
            parent.doc.mutateInsert(spliceArgs[i]);
          }
        }
      } else {
        if (before === child) {
          return;
        }
        if (bothRooted) {
          // Remove the child from its current position in the tree
          // without calling remove(), since we don't want to uproot it.
          child._remove();
        } else if (child.parentNode) {
          child.remove();
        }

        // Insert it as a child of its new parent
        child.parentNode = parent;
        if (isReplace) {
          LinkedList.replace(n, child);
          if (parent._childNodes) {
            child._index = before_index;
            parent._childNodes[before_index] = child;
          } else if (parent._firstChild === before) {
            parent._firstChild = child;
          }
        } else {
          if (n !== null) {
            LinkedList.insertBefore(child, n);
          }
          if (parent._childNodes) {
            child._index = before_index;
            parent._childNodes.splice(before_index, 0, child);
          } else if (parent._firstChild === before) {
            parent._firstChild = child;
          }
        }
        if (bothRooted) {
          parent.modify();
          // Generate a move mutation event
          parent.doc.mutateMove(child);
        } else if (parent.rooted) {
          parent.modify();
          parent.doc.mutateInsert(child);
        }
      }
    } },

  // Return the lastModTime value for this node. (For use as a
  // cache invalidation mechanism. If the node does not already
  // have one, initialize it from the owner document's modclock
  // property. (Note that modclock does not return the actual
  // time; it is simply a counter incremented on each document
  // modification)
  lastModTime: { get: function get() {
      if (!this._lastModTime) {
        this._lastModTime = this.doc.modclock;
      }
      return this._lastModTime;
    } },

  // Increment the owner document's modclock and use the new
  // value to update the lastModTime value for this node and
  // all of its ancestors. Nodes that have never had their
  // lastModTime value queried do not need to have a
  // lastModTime property set on them since there is no
  // previously queried value to ever compare the new value
  // against, so only update nodes that already have a
  // _lastModTime property.
  modify: { value: function value() {
      if (this.doc.modclock) {
        // Skip while doc.modclock == 0
        var time = ++this.doc.modclock;
        for (var n = this; n; n = n.parentElement) {
          if (n._lastModTime) {
            n._lastModTime = time;
          }
        }
      }
    } },

  // This attribute is not part of the DOM but is quite helpful.
  // It returns the document with which a node is associated.  Usually
  // this is the ownerDocument. But ownerDocument is null for the
  // document object itself, so this is a handy way to get the document
  // regardless of the node type
  doc: { get: function get() {
      return this.ownerDocument || this;
    } },

  // If the node has a nid (node id), then it is rooted in a document
  rooted: { get: function get() {
      return !!this._nid;
    } },

  normalize: { value: function value() {
      var next;
      for (var child = this.firstChild; child !== null; child = next) {
        next = child.nextSibling;

        if (child.normalize) {
          child.normalize();
        }

        if (child.nodeType !== Node.TEXT_NODE) {
          continue;
        }

        if (child.nodeValue === "") {
          this.removeChild(child);
          continue;
        }

        var prevChild = child.previousSibling;
        if (prevChild === null) {
          continue;
        } else if (prevChild.nodeType === Node.TEXT_NODE) {
          // merge this with previous and remove the child
          prevChild.appendData(child.nodeValue);
          this.removeChild(child);
        }
      }
    } },

  // Convert the children of a node to an HTML string.
  // This is used by the innerHTML getter
  // The serialization spec is at:
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#serializing-html-fragments
  //
  // The serialization logic is intentionally implemented in a separate
  // `NodeUtils` helper instead of the more obvious choice of a private
  // `_serializeOne()` method on the `Node.prototype` in order to avoid
  // the megamorphic `this._serializeOne` property access, which reduces
  // performance unnecessarily. If you need specialized behavior for a
  // certain subclass, you'll need to implement that in `NodeUtils`.
  // See https://github.com/fgnass/domino/pull/142 for more information.
  serialize: { value: function value() {
      var s = '';
      for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
        s += NodeUtils.serializeOne(kid, this);
      }
      return s;
    } },

  // Non-standard, but often useful for debugging.
  outerHTML: {
    get: function get() {
      return NodeUtils.serializeOne(this, { nodeType: 0 });
    },
    set: utils.nyi
  },

  // mirror node type properties in the prototype, so they are present
  // in instances of Node (and subclasses)
  ELEMENT_NODE: { value: ELEMENT_NODE },
  ATTRIBUTE_NODE: { value: ATTRIBUTE_NODE },
  TEXT_NODE: { value: TEXT_NODE },
  CDATA_SECTION_NODE: { value: CDATA_SECTION_NODE },
  ENTITY_REFERENCE_NODE: { value: ENTITY_REFERENCE_NODE },
  ENTITY_NODE: { value: ENTITY_NODE },
  PROCESSING_INSTRUCTION_NODE: { value: PROCESSING_INSTRUCTION_NODE },
  COMMENT_NODE: { value: COMMENT_NODE },
  DOCUMENT_NODE: { value: DOCUMENT_NODE },
  DOCUMENT_TYPE_NODE: { value: DOCUMENT_TYPE_NODE },
  DOCUMENT_FRAGMENT_NODE: { value: DOCUMENT_FRAGMENT_NODE },
  NOTATION_NODE: { value: NOTATION_NODE },

  DOCUMENT_POSITION_DISCONNECTED: { value: DOCUMENT_POSITION_DISCONNECTED },
  DOCUMENT_POSITION_PRECEDING: { value: DOCUMENT_POSITION_PRECEDING },
  DOCUMENT_POSITION_FOLLOWING: { value: DOCUMENT_POSITION_FOLLOWING },
  DOCUMENT_POSITION_CONTAINS: { value: DOCUMENT_POSITION_CONTAINS },
  DOCUMENT_POSITION_CONTAINED_BY: { value: DOCUMENT_POSITION_CONTAINED_BY },
  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: { value: DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC }
});

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WxcTag = exports.WxcTabPage = exports.WxcTabBar = exports.WxcSwipeAction = exports.WxcStepper = exports.WxcSpecialRichText = exports.WxcSliderBar = exports.WxcSlideNav = exports.WxcSimpleFlow = exports.WxcSearchbar = exports.WxcRichText = exports.WxcResult = exports.WxcRefresher = exports.WxcRadio = exports.WxcProgress = exports.WxcPopup = exports.WxcPopover = exports.WxcPartLoading = exports.WxcPanItem = exports.WxcPageCalendar = exports.WxcOverlay = exports.WxcNoticebar = exports.WxcMinibar = exports.WxcMask = exports.WxcLotteryRain = exports.WxcLoading = exports.WxcLightbox = exports.WxcIndexlist = exports.WxcIcon = exports.WxcGridSelect = exports.WxcFullPage = exports.WxcEpSlider = exports.WxcDialog = exports.WxcCountdown = exports.WxcCity = exports.WxcCheckboxList = exports.WxcCheckbox = exports.WxcCell = exports.WxcButton = exports.Utils = exports.BindEnv = undefined;

var _bindEnv = __webpack_require__(88);

var _bindEnv2 = _interopRequireDefault(_bindEnv);

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

var _wxcButton = __webpack_require__(92);

var _wxcButton2 = _interopRequireDefault(_wxcButton);

var _wxcCell = __webpack_require__(29);

var _wxcCell2 = _interopRequireDefault(_wxcCell);

var _wxcCheckbox = __webpack_require__(102);

var _wxcCheckbox2 = _interopRequireDefault(_wxcCheckbox);

var _wxcCheckboxList = __webpack_require__(107);

var _wxcCheckboxList2 = _interopRequireDefault(_wxcCheckboxList);

var _wxcCity = __webpack_require__(111);

var _wxcCity2 = _interopRequireDefault(_wxcCity);

var _wxcCountdown = __webpack_require__(137);

var _wxcCountdown2 = _interopRequireDefault(_wxcCountdown);

var _wxcDialog = __webpack_require__(142);

var _wxcDialog2 = _interopRequireDefault(_wxcDialog);

var _wxcEpSlider = __webpack_require__(152);

var _wxcEpSlider2 = _interopRequireDefault(_wxcEpSlider);

var _wxcFullPage = __webpack_require__(157);

var _wxcFullPage2 = _interopRequireDefault(_wxcFullPage);

var _wxcGridSelect = __webpack_require__(162);

var _wxcGridSelect2 = _interopRequireDefault(_wxcGridSelect);

var _wxcIcon = __webpack_require__(171);

var _wxcIcon2 = _interopRequireDefault(_wxcIcon);

var _wxcIndexlist = __webpack_require__(57);

var _wxcIndexlist2 = _interopRequireDefault(_wxcIndexlist);

var _wxcLightbox = __webpack_require__(177);

var _wxcLightbox2 = _interopRequireDefault(_wxcLightbox);

var _wxcLoading = __webpack_require__(186);

var _wxcLoading2 = _interopRequireDefault(_wxcLoading);

var _wxcLotteryRain = __webpack_require__(191);

var _wxcLotteryRain2 = _interopRequireDefault(_wxcLotteryRain);

var _wxcMask = __webpack_require__(58);

var _wxcMask2 = _interopRequireDefault(_wxcMask);

var _wxcMinibar = __webpack_require__(60);

var _wxcMinibar2 = _interopRequireDefault(_wxcMinibar);

var _wxcNoticebar = __webpack_require__(207);

var _wxcNoticebar2 = _interopRequireDefault(_wxcNoticebar);

var _wxcOverlay = __webpack_require__(14);

var _wxcOverlay2 = _interopRequireDefault(_wxcOverlay);

var _wxcPageCalendar = __webpack_require__(213);

var _wxcPageCalendar2 = _interopRequireDefault(_wxcPageCalendar);

var _wxcPanItem = __webpack_require__(219);

var _wxcPanItem2 = _interopRequireDefault(_wxcPanItem);

var _wxcPartLoading = __webpack_require__(223);

var _wxcPartLoading2 = _interopRequireDefault(_wxcPartLoading);

var _wxcPopover = __webpack_require__(227);

var _wxcPopover2 = _interopRequireDefault(_wxcPopover);

var _wxcPopup = __webpack_require__(232);

var _wxcPopup2 = _interopRequireDefault(_wxcPopup);

var _wxcProgress = __webpack_require__(237);

var _wxcProgress2 = _interopRequireDefault(_wxcProgress);

var _wxcRadio = __webpack_require__(242);

var _wxcRadio2 = _interopRequireDefault(_wxcRadio);

var _wxcRefresher = __webpack_require__(252);

var _wxcRefresher2 = _interopRequireDefault(_wxcRefresher);

var _wxcResult = __webpack_require__(56);

var _wxcResult2 = _interopRequireDefault(_wxcResult);

var _wxcRichText = __webpack_require__(257);

var _wxcRichText2 = _interopRequireDefault(_wxcRichText);

var _wxcSearchbar = __webpack_require__(55);

var _wxcSearchbar2 = _interopRequireDefault(_wxcSearchbar);

var _wxcSimpleFlow = __webpack_require__(275);

var _wxcSimpleFlow2 = _interopRequireDefault(_wxcSimpleFlow);

var _wxcSlideNav = __webpack_require__(280);

var _wxcSlideNav2 = _interopRequireDefault(_wxcSlideNav);

var _wxcSliderBar = __webpack_require__(285);

var _wxcSliderBar2 = _interopRequireDefault(_wxcSliderBar);

var _wxcSpecialRichText = __webpack_require__(290);

var _wxcSpecialRichText2 = _interopRequireDefault(_wxcSpecialRichText);

var _wxcStepper = __webpack_require__(295);

var _wxcStepper2 = _interopRequireDefault(_wxcStepper);

var _wxcSwipeAction = __webpack_require__(300);

var _wxcSwipeAction2 = _interopRequireDefault(_wxcSwipeAction);

var _wxcTabBar = __webpack_require__(305);

var _wxcTabBar2 = _interopRequireDefault(_wxcTabBar);

var _wxcTabPage = __webpack_require__(310);

var _wxcTabPage2 = _interopRequireDefault(_wxcTabPage);

var _wxcTag = __webpack_require__(315);

var _wxcTag2 = _interopRequireDefault(_wxcTag);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.BindEnv = _bindEnv2.default;
exports.Utils = _utils2.default;
exports.WxcButton = _wxcButton2.default;
exports.WxcCell = _wxcCell2.default;
exports.WxcCheckbox = _wxcCheckbox2.default;
exports.WxcCheckboxList = _wxcCheckboxList2.default;
exports.WxcCity = _wxcCity2.default;
exports.WxcCountdown = _wxcCountdown2.default;
exports.WxcDialog = _wxcDialog2.default;
exports.WxcEpSlider = _wxcEpSlider2.default;
exports.WxcFullPage = _wxcFullPage2.default;
exports.WxcGridSelect = _wxcGridSelect2.default;
exports.WxcIcon = _wxcIcon2.default;
exports.WxcIndexlist = _wxcIndexlist2.default;
exports.WxcLightbox = _wxcLightbox2.default;
exports.WxcLoading = _wxcLoading2.default;
exports.WxcLotteryRain = _wxcLotteryRain2.default;
exports.WxcMask = _wxcMask2.default;
exports.WxcMinibar = _wxcMinibar2.default;
exports.WxcNoticebar = _wxcNoticebar2.default;
exports.WxcOverlay = _wxcOverlay2.default;
exports.WxcPageCalendar = _wxcPageCalendar2.default;
exports.WxcPanItem = _wxcPanItem2.default;
exports.WxcPartLoading = _wxcPartLoading2.default;
exports.WxcPopover = _wxcPopover2.default;
exports.WxcPopup = _wxcPopup2.default;
exports.WxcProgress = _wxcProgress2.default;
exports.WxcRadio = _wxcRadio2.default;
exports.WxcRefresher = _wxcRefresher2.default;
exports.WxcResult = _wxcResult2.default;
exports.WxcRichText = _wxcRichText2.default;
exports.WxcSearchbar = _wxcSearchbar2.default;
exports.WxcSimpleFlow = _wxcSimpleFlow2.default;
exports.WxcSlideNav = _wxcSlideNav2.default;
exports.WxcSliderBar = _wxcSliderBar2.default;
exports.WxcSpecialRichText = _wxcSpecialRichText2.default;
exports.WxcStepper = _wxcStepper2.default;
exports.WxcSwipeAction = _wxcSwipeAction2.default;
exports.WxcTabBar = _wxcTabBar2.default;
exports.WxcTabPage = _wxcTabPage2.default;
exports.WxcTag = _wxcTag2.default; /**
                                    * Created by Tw93 on 17/09/25
                                    */

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

;(function (fn) {
  if (( false ? "undefined" : _typeof2(exports)) === "object" && typeof module !== "undefined") {
    module.exports = fn();
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, module) {
      module.exports = fn();
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    var root;
    if (typeof window !== "undefined") {
      root = window;
    } else if (typeof self !== "undefined") {
      root = self;
    } else if (typeof global !== "undefined") {
      root = global;
    } else {
      // NOTICE: In JavaScript strict mode, this is null
      root = this;
    }
    root["index"] = fn();
  }
})(function () {
  return (/******/function (modules) {
      // webpackBootstrap
      /******/ // The module cache
      /******/var installedModules = {};
      /******/
      /******/ // The require function
      /******/function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/if (installedModules[moduleId]) {
          /******/return installedModules[moduleId].exports;
          /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/var module = installedModules[moduleId] = {
          /******/i: moduleId,
          /******/l: false,
          /******/exports: {}
          /******/ };
        /******/
        /******/ // Execute the module function
        /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/return module.exports;
        /******/
      }
      /******/
      /******/
      /******/ // expose the modules object (__webpack_modules__)
      /******/__webpack_require__.m = modules;
      /******/
      /******/ // expose the module cache
      /******/__webpack_require__.c = installedModules;
      /******/
      /******/ // define getter function for harmony exports
      /******/__webpack_require__.d = function (exports, name, getter) {
        /******/if (!__webpack_require__.o(exports, name)) {
          /******/Object.defineProperty(exports, name, {
            /******/configurable: false,
            /******/enumerable: true,
            /******/get: getter
            /******/ });
          /******/
        }
        /******/
      };
      /******/
      /******/ // getDefaultExport function for compatibility with non-harmony modules
      /******/__webpack_require__.n = function (module) {
        /******/var getter = module && module.__esModule ?
        /******/function getDefault() {
          return module['default'];
        } :
        /******/function getModuleExports() {
          return module;
        };
        /******/__webpack_require__.d(getter, 'a', getter);
        /******/return getter;
        /******/
      };
      /******/
      /******/ // Object.prototype.hasOwnProperty.call
      /******/__webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/
      /******/ // __webpack_public_path__
      /******/__webpack_require__.p = "";
      /******/
      /******/ // Load entry module and return exports
      /******/return __webpack_require__(__webpack_require__.s = 0);
      /******/
    }(
    /************************************************************************/
    /******/[
    /* 0 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";
      /**
       Copyright 2018 Alibaba Group
      
       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at
      
       http://www.apache.org/licenses/LICENSE-2.0
      
       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.
       */

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
      };

      var _bindingxParser = __webpack_require__(1);

      var isWeb = false;
      var isWeex = true;

      function requireModule(moduleName) {
        try {
          if ((typeof weex === 'undefined' ? 'undefined' : _typeof(weex)) !== undefined && weex.requireModule) {
            // eslint-disable-line
            return weex.requireModule(moduleName); // eslint-disable-line
          }
        } catch (err) {}
        return window.require('@weex-module/' + moduleName);
      }

      var isSupportNewBinding = true;
      var isSupportBinding = true;
      var WeexBinding = void 0;
      var WebBinding = {};

      try {
        WeexBinding = requireModule('bindingx');
        isSupportNewBinding = true;
      } catch (e) {
        isSupportNewBinding = false;
      }
      if (!WeexBinding || !WeexBinding.bind) {
        try {
          WeexBinding = requireModule('binding');
          isSupportNewBinding = true;
        } catch (e) {
          isSupportNewBinding = false;
        }
      }
      isSupportNewBinding = !!(WeexBinding && WeexBinding.bind && WeexBinding.unbind);
      if (!isSupportNewBinding) {
        try {
          WeexBinding = requireModule('expressionBinding');
          isSupportBinding = true;
        } catch (err) {
          isSupportBinding = false;
        }
      }
      isSupportBinding = !!(WeexBinding && (WeexBinding.bind || WeexBinding.createBinding));

      function formatExpression(expression) {
        if (expression === undefined) return;
        try {
          expression = JSON.parse(expression);
        } catch (err) {}
        var resultExpression = {};
        if (typeof expression === 'string') {
          resultExpression.origin = expression;
        } else if (expression) {
          resultExpression.origin = expression.origin;
          resultExpression.transformed = expression.transformed;
        }
        if (!resultExpression.transformed && !resultExpression.origin) return;
        resultExpression.transformed = resultExpression.transformed || (0, _bindingxParser.parse)(resultExpression.origin);
        return resultExpression;
      }

      // 统一回调参数
      function fixCallback(callback) {
        return function () {
          var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          if (typeof callback === 'function') {
            return callback({
              state: params.state === 'end' ? 'exit' : params.state,
              t: params.t !== undefined ? params.t : params.deltaT
            });
          }
        };
      }

      exports.default = {
        // 是否支持新版本的binding
        isSupportNewBinding: isSupportNewBinding,
        // 是否支持binding
        isSupportBinding: isSupportBinding,
        _bindingInstances: [],
        /**
         * 绑定
         * @param options 参数
         * @example
         {
           anchor:blockRef,
           eventType:'pan',
           props: [
           {
             element:blockRef,
             property:'transform.translateX',
             expression:{
               origin:"x+1",
               transformed:"{\"type\":\"+\",\"children\":[{\"type\":\"Identifier\",\"value\":\"x\"},{\"type\":\"NumericLiteral\",\"value\":1}]}"
             }
           }
          ]
         }
         */
        bind: function bind(options) {
          var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

          if (!options) {
            throw new Error('should pass options for binding');
          }

          options.exitExpression = formatExpression(options.exitExpression);

          if (options.props) {
            options.props.forEach(function (prop) {
              prop.expression = formatExpression(prop.expression);
            });
          }

          if (WeexBinding && isSupportBinding) {
            if (isSupportNewBinding) {
              return WeexBinding.bind(options, options && options.eventType === 'timing' ? fixCallback(callback) : callback);
            } else {
              WeexBinding.enableBinding(options.anchor, options.eventType);
              // 处理expression的参数格式
              var expressionArgs = options.props.map(function (prop) {
                return {
                  element: prop.element,
                  property: prop.property,
                  expression: prop.expression.transformed
                };
              });
              WeexBinding.createBinding(options.anchor, options.eventType, '', expressionArgs, callback);
            }
          }
        },

        /**
         *  @param {object} options
         *  @example
         *  {eventType:'pan',
         *   token:self.gesToken}
         */
        unbind: function unbind(options) {
          if (!options) {
            throw new Error('should pass options for binding');
          }

          if (WeexBinding && isSupportBinding) {
            if (isSupportNewBinding) {
              return WeexBinding.unbind(options);
            } else {
              return WeexBinding.disableBinding(options.anchor, options.eventType);
            }
          }
        },
        unbindAll: function unbindAll() {
          if (WeexBinding && isSupportBinding) {
            if (isSupportNewBinding) {
              return WeexBinding.unbindAll();
            } else {
              return WeexBinding.disableAll();
            }
          }
        },
        prepare: function prepare(options) {
          if (WeexBinding && isSupportBinding) {
            if (isSupportNewBinding) {
              return WeexBinding.prepare(options);
            } else {
              return WeexBinding.enableBinding(options.anchor, options.eventType);
            }
          }
        },
        getComputedStyle: function getComputedStyle(el) {
          if (isSupportNewBinding) {
            return WeexBinding.getComputedStyle(el);
          } else {
            return {};
          }
        }
      };
      module.exports = exports['default'];

      /***/
    },
    /* 1 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      module.exports = __webpack_require__(2);

      /***/
    },
    /* 2 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var lex = {
        InputElementDiv: '<WhiteSpace>|<LineTerminator>|<ReservedWord>|<Identifier>|<NumericLiteral>|<Punctuator>|<StringLiteral>',
        InputElementRegExp: '<WhiteSpace>|<LineTerminator>|<ReservedWord>|<Identifier>|<NumericLiteral>|<Punctuator>|<StringLiteral>',
        ReservedWord: '<Keyword>|<NullLiteral>|<BooleanLiteral>',
        WhiteSpace: /[\t\v\f\u0020\u00A0\u1680\u180E\u2000-\u200A\u202F\u205f\u3000\uFEFF]/,
        LineTerminator: /[\n\r\u2028\u2029]/,
        Keyword: /new(?![_$a-zA-Z0-9])|void(?![_$a-zA-Z0-9])|delete(?![_$a-zA-Z0-9])|in(?![_$a-zA-Z0-9])|instanceof(?![_$a-zA-Z0-9])|typeof(?![_$a-zA-Z0-9])/,
        NullLiteral: /null(?![_$a-zA-Z0-9])/,
        BooleanLiteral: /(?:true|false)(?![_$a-zA-Z0-9])/,
        Identifier: /[_$a-zA-Z][_$a-zA-Z0-9]*/,
        Punctuator: /\/|=>|\*\*|>>>=|>>=|<<=|===|!==|>>>|<<|%=|\*=|-=|\+=|<=|>=|==|!=|\^=|\|=|\|\||&&|&=|>>|\+\+|--|\:|}|\*|&|\||\^|!|~|-|\+|\?|%|=|>|<|,|;|\.(?![0-9])|\]|\[|\)|\(|{/,
        DivPunctuator: /\/=|\//,
        NumericLiteral: /(?:0[xX][0-9a-fA-F]*|\.[0-9]+|(?:[1-9]+[0-9]*|0)(?:\.[0-9]*|\.)?)(?:[eE][+-]{0,1}[0-9]+)?(?![_$a-zA-Z0-9])/,
        StringLiteral: /"(?:[^"\n\\\r\u2028\u2029]|\\(?:['"\\bfnrtv\n\r\u2028\u2029]|\r\n)|\\x[0-9a-fA-F]{2}|\\u[0-9a-fA-F]{4}|\\[^0-9ux'"\\bfnrtv\n\\\r\u2028\u2029])*"|'(?:[^'\n\\\r\u2028\u2029]|\\(?:['"\\bfnrtv\n\r\u2028\u2029]|\r\n)|\\x[0-9a-fA-F]{2}|\\u[0-9a-fA-F]{4}|\\[^0-9ux'"\\bfnrtv\n\\\r\u2028\u2029])*'/,
        RegularExpressionLiteral: /\/(?:\[(?:\\[\s\S]|[^\]])*\]|[^*\/\\\n\r\u2028\u2029]|\\[^\n\r\u2028\u2029])(?:\[(?:\\[\s\S]|[^\]])*\]|[^\/\\\n\r\u2028\u2029]|\\[^\n\r\u2028\u2029])*\/[0-9a-zA-Z]*/
      };

      function XRegExp(xregexps, rootname, flag) {
        var expnames = [rootname];

        function buildRegExp(source) {
          var regexp = new RegExp();
          regexp.compile(source.replace(/<([^>]+)>/g, function (all, expname) {
            if (!xregexps[expname]) return '';
            expnames.push(expname);
            if (xregexps[expname] instanceof RegExp) return '(' + xregexps[expname].source + ')';
            return '(' + buildRegExp(xregexps[expname]).source + ')';
          }), flag);
          return regexp;
        }

        var regexp = buildRegExp(xregexps[rootname]);
        this.exec = function (string) {
          var matches = regexp.exec(string);
          if (matches == null) return null;
          var result = new String(matches[0]);
          for (var i = 0; i < expnames.length; i++) {
            if (matches[i]) result[expnames[i]] = matches[i];
          }return result;
        };
        Object.defineProperty(this, 'lastIndex', {
          'get': function get() {
            return regexp.lastIndex;
          },
          'set': function set(v) {
            regexp.lastIndex = v;
          }
        });
      }

      function LexicalParser() {
        var inputElementDiv = new XRegExp(lex, 'InputElementDiv', 'g');
        var inputElementRegExp = new XRegExp(lex, 'InputElementRegExp', 'g');
        var source;
        Object.defineProperty(this, 'source', {
          'get': function get() {
            return source;
          },
          'set': function set(v) {
            source = v;
            inputElementDiv.lastIndex = 0;
            inputElementRegExp.lastIndex = 0;
          }
        });
        this.reset = function () {
          inputElementDiv.lastIndex = 0;
          inputElementRegExp.lastIndex = 0;
        };
        this.getNextToken = function (useDiv) {
          var lastIndex = inputElementDiv.lastIndex;
          var inputElement;
          if (useDiv) inputElement = inputElementDiv;else inputElement = inputElementRegExp;
          var token = inputElement.exec(source);
          if (token && inputElement.lastIndex - lastIndex > token.length) {
            throw new SyntaxError('Unexpected token ILLEGAL');
          }
          inputElementDiv.lastIndex = inputElement.lastIndex;
          inputElementRegExp.lastIndex = inputElement.lastIndex;
          return token;
        };
      }

      var rules = {
        'IdentifierName': [['Identifier']],
        'Literal': [['NullLiteral'], ['BooleanLiteral'], ['NumericLiteral'], ['StringLiteral'], ['RegularExpressionLiteral']],
        'PrimaryExpression': [['Identifier'], ['Literal'], ['(', 'Expression', ')']],
        'CallExpression': [['PrimaryExpression', 'Arguments'], ['CallExpression', 'Arguments']],
        'Arguments': [['(', ')'], ['(', 'ArgumentList', ')']],
        'ArgumentList': [['ConditionalExpression'], ['ArgumentList', ',', 'ConditionalExpression']],
        'LeftHandSideExpression': [['PrimaryExpression'], ['CallExpression']],
        'UnaryExpression': [['LeftHandSideExpression'], ['void', 'UnaryExpression'], ['+', 'UnaryExpression'], ['-', 'UnaryExpression'], ['~', 'UnaryExpression'], ['!', 'UnaryExpression']],
        'ExponentiationExpression': [['UnaryExpression'], ['ExponentiationExpression', '**', 'UnaryExpression']],
        'MultiplicativeExpression': [['MultiplicativeExpression', '/', 'ExponentiationExpression'], ['ExponentiationExpression'], ['MultiplicativeExpression', '*', 'ExponentiationExpression'], ['MultiplicativeExpression', '%', 'ExponentiationExpression']],
        'AdditiveExpression': [['MultiplicativeExpression'], ['AdditiveExpression', '+', 'MultiplicativeExpression'], ['AdditiveExpression', '-', 'MultiplicativeExpression']],
        'ShiftExpression': [['AdditiveExpression'], ['ShiftExpression', '<<', 'AdditiveExpression'], ['ShiftExpression', '>>', 'AdditiveExpression'], ['ShiftExpression', '>>>', 'AdditiveExpression']],
        'RelationalExpression': [['ShiftExpression'], ['RelationalExpression', '<', 'ShiftExpression'], ['RelationalExpression', '>', 'ShiftExpression'], ['RelationalExpression', '<=', 'ShiftExpression'], ['RelationalExpression', '>=', 'ShiftExpression'], ['RelationalExpression', 'instanceof', 'ShiftExpression'], ['RelationalExpression', 'in', 'ShiftExpression']],
        'EqualityExpression': [['RelationalExpression'], ['EqualityExpression', '==', 'RelationalExpression'], ['EqualityExpression', '!=', 'RelationalExpression'], ['EqualityExpression', '===', 'RelationalExpression'], ['EqualityExpression', '!==', 'RelationalExpression']],
        'BitwiseANDExpression': [['EqualityExpression'], ['BitwiseANDExpression', '&', 'EqualityExpression']],
        'BitwiseXORExpression': [['BitwiseANDExpression'], ['BitwiseXORExpression', '^', 'BitwiseANDExpression']],
        'BitwiseORExpression': [['BitwiseXORExpression'], ['BitwiseORExpression', '|', 'BitwiseXORExpression']],
        'LogicalANDExpression': [['BitwiseORExpression'], ['LogicalANDExpression', '&&', 'BitwiseORExpression']],
        'LogicalORExpression': [['LogicalANDExpression'], ['LogicalORExpression', '||', 'LogicalANDExpression']],
        'ConditionalExpression': [['LogicalORExpression'], ['LogicalORExpression', '?', 'LogicalORExpression', ':', 'LogicalORExpression']],
        'Expression': [['ConditionalExpression'], ['Expression', ',', 'ConditionalExpression']],
        'Program': [['Expression']]

      };

      function _Symbol(symbolName, token) {
        this.name = symbolName;
        this.token = token;
        this.childNodes = [];
        this.toString = function (indent) {
          if (!indent) indent = '';
          if (this.childNodes.length == 1) return this.childNodes[0].toString(indent);
          var str = indent + this.name + (this.token != undefined && this.name != this.token ? ':' + this.token : '') + '\n';
          for (var i = 0; i < this.childNodes.length; i++) {
            str += this.childNodes[i].toString(indent + '    ');
          }return str;
        };
      }

      function SyntacticalParser() {
        var currentRule;
        var root = {
          Program: '$'
        };
        var hash = {};

        function closureNode(node) {

          hash[JSON.stringify(node)] = node;

          var queue = Object.getOwnPropertyNames(node);
          while (queue.length) {
            var symbolName = queue.shift();
            if (!rules[symbolName]) continue;
            rules[symbolName].forEach(function (rule) {
              if (!node[rule[0]]) queue.push(rule[0]);
              var rulenode = node;
              var lastnode = null;
              rule.forEach(function (symbol) {
                if (!rulenode[symbol]) rulenode[symbol] = {};
                lastnode = rulenode;
                rulenode = rulenode[symbol];
              });
              if (node[symbolName].$div) rulenode.$div = true;
              rulenode.$reduce = symbolName;
              rulenode.$count = rule.length;
            });
          }

          for (var p in node) {
            if (_typeof2(node[p]) != 'object' || p.charAt(0) == '$' || node[p].$closure) continue;
            if (hash[JSON.stringify(node[p])]) node[p] = hash[JSON.stringify(node[p])];else {
              closureNode(node[p]);
            }
          }
          node.$closure = true;
        }

        closureNode(root);
        var symbolStack = [];
        var statusStack = [root];
        var current = root;
        this.insertSymbol = function insertSymbol(symbol, haveLineTerminator) {
          while (!current[symbol.name] && current.$reduce) {
            var count = current.$count;
            var newsymbol = new _Symbol(current.$reduce);
            while (count--) {
              newsymbol.childNodes.push(symbolStack.pop()), statusStack.pop();
            }current = statusStack[statusStack.length - 1];
            this.insertSymbol(newsymbol);
          }
          current = current[symbol.name];
          symbolStack.push(symbol), statusStack.push(current);
          if (!current) throw new Error();
          return current.$div;
        };
        this.reset = function () {
          current = root;
          symbolStack = [];
          statusStack = [root];
        };
        Object.defineProperty(this, 'grammarTree', {
          'get': function get() {
            try {
              while (current.$reduce) {
                var count = current.$count;
                var newsymbol = new _Symbol(current.$reduce);
                while (count--) {
                  newsymbol.childNodes.push(symbolStack.pop()), statusStack.pop();
                }current = statusStack[statusStack.length - 1];
                this.insertSymbol(newsymbol);
              }
              if (symbolStack.length > 0 && current[';']) {
                this.insertSymbol(new _Symbol(';', ';'));
                return this.grammarTree;
              }
              if (symbolStack.length != 1 || symbolStack[0].name != 'Program') throw new Error();
            } catch (e) {
              throw new SyntaxError('Unexpected end of input');
            }
            return symbolStack[0];
          }
        });
      }

      function Parser() {
        this.lexicalParser = new LexicalParser();
        this.syntacticalParser = new SyntacticalParser();
        var terminalSymbols = ['NullLiteral', 'BooleanLiteral', 'NumericLiteral', 'StringLiteral', 'RegularExpressionLiteral', 'Identifier', '**', '=>', '{', '}', '(', ')', '[', ']', '.', ';', ',', '<', '>', '<=', '>=', '==', '!=', '===', '!==', '+', '-', '*', '%', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '!', '~', '&&', '||', '?', ':', '=', '+=', '-=', '*=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', '/', '/=', 'instanceof', 'typeof', 'new', 'void', 'debugger', 'this', 'delete', 'in'];
        var terminalSymbolIndex = {};
        terminalSymbols.forEach(function (e) {
          Object.defineProperty(terminalSymbolIndex, e, {});
        });
        this.reset = function () {
          this.lexicalParser.reset();
          this.syntacticalParser.reset();
        };
        this.parse = function (source, onInputElement) {
          var _this = this;

          var token;
          var haveLineTerminator = false;
          this.lexicalParser.source = source;
          var useDiv = false;
          while (token = this.lexicalParser.getNextToken(useDiv)) {
            if (onInputElement) onInputElement(token);
            try {
              if (Object.getOwnPropertyNames(token).some(function (e) {
                if (terminalSymbolIndex.hasOwnProperty(e)) {
                  useDiv = _this.syntacticalParser.insertSymbol(new _Symbol(e, token), haveLineTerminator);
                  haveLineTerminator = false;
                  return true;
                } else return false;
              })) continue;
              if ((token.Keyword || token.Punctuator || token.DivPunctuator) && terminalSymbolIndex.hasOwnProperty(token.toString())) {
                useDiv = this.syntacticalParser.insertSymbol(new _Symbol(token.toString(), token), haveLineTerminator);
              }
            } catch (e) {
              throw new SyntaxError('Unexpected token ' + token);
            }
          }
          return this.syntacticalParser.grammarTree;
        };
      }

      var parser = new Parser();

      function JavaScriptExpression(text) {
        parser.reset();
        this.tree = parser.parse(text);
        this.paths = [];
        var context = Object.create(null);
        var me = this;
        var pathIndex = Object.create(null);
        this.isSimple;
        this.isConst;
        walk(this.tree);
        checkSimple(this.tree);
        if (this.paths.length === 0) {
          this.isConst = true;
        }
        this.setter = function (path) {
          var curr = context;
          for (var i = 0; i < path.length - 1; i++) {
            if (!curr[path[i]]) curr[path[i]] = Object.create(null);
            curr = curr[path[i]];
          }
          return {
            isCompleted: function isCompleted() {
              for (var p in pathIndex) {
                if (!pathIndex[p]) return false;
              }return true;
            },
            set: function set(value) {
              if (!pathIndex[path.join('.')]) {
                pathIndex[path.join('.')] = true;
              }
              curr[path[i]] = value;
              if (this.isCompleted()) {
                return me.exec();
              } else {
                return undefined;
              }
            }
          };
        };

        this.valueOf = this.exec = function () {
          try {
            return function () {
              return eval(text);
            }.call(context);
          } catch (e) {}
        };

        function checkSimple(symbol) {

          var curr = symbol;
          while (curr.childNodes.length <= 1 && curr.name !== 'MemberExpression') {
            curr = curr.childNodes[0];
          }
          // TODO: need to point out "[……]"
          if (curr.name === 'MemberExpression') {
            me.isSimple = true;
          } else {
            me.isSimple = false;
          }
        }

        function walk(symbol) {
          if (symbol.name === 'CallExpression' && symbol.childNodes[symbol.childNodes.length - 1].name !== 'CallExpression') {
            var path = getPath(symbol.childNodes[1]);
            walk(symbol.childNodes[0]);
          } else if (symbol.name === 'NewExpression' && symbol.childNodes.length === 1) {
            var path = getPath(symbol.childNodes[0]);
          } else if (symbol.name === 'MemberExpression' && symbol.childNodes.length === 1) {
            var path = getPath(symbol);
          } else {
            for (var i = 0; i < symbol.childNodes.length; i++) {
              walk(symbol.childNodes[i]);
            }
          }
        }

        function getPath(symbol) {
          // [["PrimaryExpression"], ["MemberExpression", "[", "Expression", "]"], ["MemberExpression", ".", "IdentifierName"], ["new", "MemberExpression", "Arguments"]],

          if (symbol.childNodes[0].name === 'IdentifierName') {
            // MemberExpression : MemberExpression "." IdentifierName
            var path = getPath(symbol.childNodes[2]);
            if (path) path = path.concat(symbol.childNodes[0].childNodes[0].token.toString());
            createPath(path);
            return path;
          } else if (symbol.childNodes[0].name === 'PrimaryExpression') {
            // MemberExpression : PrimaryExpression
            if (symbol.childNodes[0].childNodes[0].name === 'Identifier') {
              var path = [symbol.childNodes[0].childNodes[0].token.toString()];
              createPath(path);
              return path;
            } else {
              return null;
            }
          } else if (symbol.childNodes[0].name === ']') {
            // MemberExpression : MemberExpression "[" Expression "]"
            getPath(symbol.childNodes[3]);
            walk(symbol.childNodes[1]);
            return null;
          } else if (symbol.childNodes[0].name === 'Arguments') {
            // MemberExpression : "new" MemberExpression Arguments
            walk(symbol.childNodes[0]);
            walk(symbol.childNodes[1]);
            return null;
          } else {
            for (var i = 0; i < symbol.childNodes.length; i++) {
              walk(symbol.childNodes[i]);
            }
          }
        }

        function createPath(path) {
          var curr = context;
          for (var i = 0; i < path.length - 1; i++) {
            if (!curr[path[i]]) curr[path[i]] = Object.create(null);
            curr = curr[path[i]];
          }
          me.paths.push(path);
          pathIndex[path.join('.')] = false;
        }
      }

      function visit(tree) {
        var childNodes = tree.childNodes.slice().reverse();
        var children = childNodes.filter(function (e) {
          return !e.token || !e.token.Punctuator;
        });
        if (tree.name === 'UnaryExpression') {
          // negative number support
          if (childNodes.length === 2 && childNodes[0].name === '-' && children.length === 1) {
            var res = visit(children[0]);
            res.value = -res.value;
            return res;
          }
        }

        if (tree.name === 'Arguments') {
          var argumentList = [];
          var listNode = children[0];
          while (listNode) {
            if (listNode.childNodes.length === 3) {
              argumentList.unshift(listNode.childNodes[0]);
              listNode = listNode.childNodes[2];
            }
            if (listNode.childNodes.length === 1) {
              argumentList.unshift(listNode.childNodes[0]);
              listNode = null;
            }
          }
          return {
            type: 'Arguments',
            children: argumentList.map(function (e) {
              return visit(e);
            })
          };
        }

        if (children && children.length === 1) {
          var res = visit(children[0]);
          return res;
        }

        if (tree.token && ['NullLiteral', 'BooleanLiteral', 'NumericLiteral', 'StringLiteral', 'Identifier'].some(function (e) {
          return tree.token[e];
        })) {
          var type = Object.keys(tree.token).filter(function (e) {
            return e.match(/Literal/) || e.match(/Identifier/);
          })[0];
          var value = {
            'NullLiteral': null,
            'BooleanLiteral': Boolean(tree.token),
            'NumericLiteral': Number(tree.token),
            'StringLiteral': tree.token,
            'Identifier': tree.token
          }[type];

          return {
            type: type,
            value: value
          };
        }

        if (tree.name === 'CallExpression') return {
          type: 'CallExpression',
          children: [visit(childNodes[0]), visit(childNodes[1])]
        };

        return {
          type: childNodes.filter(function (e) {
            return e.token && e.token.Punctuator;
          })[0].name,
          children: childNodes.filter(function (e) {
            return !e.token || !e.token.Punctuator;
          }).map(function (e) {
            return visit(e);
          })
        };
      }

      function parse(originExp) {
        var exp = new JavaScriptExpression(originExp);
        return JSON.stringify(visit(exp.tree), null);
      }

      module.exports = {
        parse: parse
      };

      /***/
    }]
    /******/)
  );
});;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _indexWeex = __webpack_require__(4);

var _indexWeex2 = _interopRequireDefault(_indexWeex);

var _index = __webpack_require__(0);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var BindEnv = {
  supportsEB: function supportsEB() {
    return _indexWeex2.default.isSupportBinding && !_index2.default.env.isWeb();
  },


  /**
   * 判断Android容器是否支持是否支持expressionBinding(处理方式很不一致)
   * @returns {boolean}
   */
  supportsEBForAndroid: function supportsEBForAndroid() {
    return _index2.default.env.isAndroid() && BindEnv.supportsEB();
  },


  /**
   * 判断IOS容器是否支持是否支持expressionBinding
   * @returns {boolean}
   */
  supportsEBForIos: function supportsEBForIos() {
    return _index2.default.env.isIOS() && BindEnv.supportsEB();
  }
};

exports.default = BindEnv;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var NodeList;

try {
    // Attempt to use ES6-style Array subclass if possible.
    NodeList = __webpack_require__(72);
} catch (e) {
    // No support for subclassing array, return an actual Array object.
    NodeList = __webpack_require__(73);
}

module.exports = NodeList;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(69);


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Event;

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

function Event(type, dictionary) {
  // Initialize basic event properties
  this.type = '';
  this.target = null;
  this.currentTarget = null;
  this.eventPhase = Event.AT_TARGET;
  this.bubbles = false;
  this.cancelable = false;
  this.isTrusted = false;
  this.defaultPrevented = false;
  this.timeStamp = Date.now();

  // Initialize internal flags
  // XXX: Would it be better to inherit these defaults from the prototype?
  this._propagationStopped = false;
  this._immediatePropagationStopped = false;
  this._initialized = true;
  this._dispatching = false;

  // Now initialize based on the constructor arguments (if any)
  if (type) this.type = type;
  if (dictionary) {
    for (var p in dictionary) {
      this[p] = dictionary[p];
    }
  }
}

Event.prototype = Object.create(Object.prototype, {
  constructor: { value: Event },
  stopPropagation: { value: function stopPropagation() {
      this._propagationStopped = true;
    } },

  stopImmediatePropagation: { value: function stopImmediatePropagation() {
      this._propagationStopped = true;
      this._immediatePropagationStopped = true;
    } },

  preventDefault: { value: function preventDefault() {
      if (this.cancelable) this.defaultPrevented = true;
    } },

  initEvent: { value: function initEvent(type, bubbles, cancelable) {
      this._initialized = true;
      if (this._dispatching) return;

      this._propagationStopped = false;
      this._immediatePropagationStopped = false;
      this.defaultPrevented = false;
      this.isTrusted = false;

      this.target = null;
      this.type = type;
      this.bubbles = bubbles;
      this.cancelable = cancelable;
    } }

});

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Element;

var xml = __webpack_require__(20);
var utils = __webpack_require__(1);
var NAMESPACE = utils.NAMESPACE;
var attributes = __webpack_require__(37);
var Node = __webpack_require__(2);
var NodeList = __webpack_require__(6);
var NodeUtils = __webpack_require__(36);
var FilteredElementList = __webpack_require__(74);
var DOMException = __webpack_require__(17);
var DOMTokenList = __webpack_require__(38);
var select = __webpack_require__(21);
var ContainerNode = __webpack_require__(19);
var ChildNode = __webpack_require__(22);
var NonDocumentTypeChildNode = __webpack_require__(39);
var NamedNodeMap = __webpack_require__(40);

var uppercaseCache = Object.create(null);

function Element(doc, localName, namespaceURI, prefix) {
  ContainerNode.call(this);
  this.nodeType = Node.ELEMENT_NODE;
  this.ownerDocument = doc;
  this.localName = localName;
  this.namespaceURI = namespaceURI;
  this.prefix = prefix;
  this._tagName = undefined;

  // These properties maintain the set of attributes
  this._attrsByQName = Object.create(null); // The qname->Attr map
  this._attrsByLName = Object.create(null); // The ns|lname->Attr map
  this._attrKeys = []; // attr index -> ns|lname
}

function recursiveGetText(node, a) {
  if (node.nodeType === Node.TEXT_NODE) {
    a.push(node._data);
  } else {
    for (var i = 0, n = node.childNodes.length; i < n; i++) {
      recursiveGetText(node.childNodes[i], a);
    }
  }
}

Element.prototype = Object.create(ContainerNode.prototype, {
  isHTML: { get: function isHTML() {
      return this.namespaceURI === NAMESPACE.HTML && this.ownerDocument.isHTML;
    } },
  tagName: { get: function tagName() {
      if (this._tagName === undefined) {
        var tn;
        if (this.prefix === null) {
          tn = this.localName;
        } else {
          tn = this.prefix + ':' + this.localName;
        }
        if (this.isHTML) {
          var up = uppercaseCache[tn];
          if (!up) {
            // Converting to uppercase can be slow, so cache the conversion.
            uppercaseCache[tn] = up = utils.toASCIIUpperCase(tn);
          }
          tn = up;
        }
        this._tagName = tn;
      }
      return this._tagName;
    } },
  nodeName: { get: function get() {
      return this.tagName;
    } },
  nodeValue: {
    get: function get() {
      return null;
    },
    set: function set() {}
  },
  textContent: {
    get: function get() {
      var strings = [];
      recursiveGetText(this, strings);
      return strings.join('');
    },
    set: function set(newtext) {
      this.removeChildren();
      if (newtext !== null && newtext !== undefined && newtext !== '') {
        this._appendChild(this.ownerDocument.createTextNode(newtext));
      }
    }
  },
  innerHTML: {
    get: function get() {
      return this.serialize();
    },
    set: utils.nyi
  },
  outerHTML: {
    get: function get() {
      // "the attribute must return the result of running the HTML fragment
      // serialization algorithm on a fictional node whose only child is
      // the context object"
      //
      // The serialization logic is intentionally implemented in a separate
      // `NodeUtils` helper instead of the more obvious choice of a private
      // `_serializeOne()` method on the `Node.prototype` in order to avoid
      // the megamorphic `this._serializeOne` property access, which reduces
      // performance unnecessarily. If you need specialized behavior for a
      // certain subclass, you'll need to implement that in `NodeUtils`.
      // See https://github.com/fgnass/domino/pull/142 for more information.
      return NodeUtils.serializeOne(this, { nodeType: 0 });
    },
    set: function set(v) {
      var document = this.ownerDocument;
      var parent = this.parentNode;
      if (parent === null) {
        return;
      }
      if (parent.nodeType === Node.DOCUMENT_NODE) {
        utils.NoModificationAllowedError();
      }
      if (parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        parent = parent.ownerDocument.createElement("body");
      }
      var parser = document.implementation.mozHTMLParser(document._address, parent);
      parser.parse(v === null ? '' : String(v), true);
      this.replaceWith(parser._asDocumentFragment());
    }
  },

  _insertAdjacent: { value: function _insertAdjacent(position, node) {
      var first = false;
      switch (position) {
        case 'beforebegin':
          first = true;
        /* falls through */
        case 'afterend':
          var parent = this.parentNode;
          if (parent === null) {
            return null;
          }
          return parent.insertBefore(node, first ? this : this.nextSibling);
        case 'afterbegin':
          first = true;
        /* falls through */
        case 'beforeend':
          return this.insertBefore(node, first ? this.firstChild : null);
        default:
          return utils.SyntaxError();
      }
    } },

  insertAdjacentElement: { value: function insertAdjacentElement(position, element) {
      if (element.nodeType !== Node.ELEMENT_NODE) {
        throw new TypeError('not an element');
      }
      position = utils.toASCIILowerCase(String(position));
      return this._insertAdjacent(position, element);
    } },

  insertAdjacentText: { value: function insertAdjacentText(position, data) {
      var textNode = this.ownerDocument.createTextNode(data);
      position = utils.toASCIILowerCase(String(position));
      this._insertAdjacent(position, textNode);
      // "This method returns nothing because it existed before we had a chance
      // to design it."
    } },

  insertAdjacentHTML: { value: function insertAdjacentHTML(position, text) {
      position = utils.toASCIILowerCase(String(position));
      text = String(text);
      var context;
      switch (position) {
        case 'beforebegin':
        case 'afterend':
          context = this.parentNode;
          if (context === null || context.nodeType === Node.DOCUMENT_NODE) {
            utils.NoModificationAllowedError();
          }
          break;
        case 'afterbegin':
        case 'beforeend':
          context = this;
          break;
        default:
          utils.SyntaxError();
      }
      if (!(context instanceof Element) || context.ownerDocument.isHTML && context.localName === 'html' && context.namespaceURI === NAMESPACE.HTML) {
        context = context.ownerDocument.createElementNS(NAMESPACE.HTML, 'body');
      }
      var parser = this.ownerDocument.implementation.mozHTMLParser(this.ownerDocument._address, context);
      parser.parse(text, true);
      this._insertAdjacent(position, parser._asDocumentFragment());
    } },

  children: { get: function get() {
      if (!this._children) {
        this._children = new ChildrenCollection(this);
      }
      return this._children;
    } },

  attributes: { get: function get() {
      if (!this._attributes) {
        this._attributes = new AttributesArray(this);
      }
      return this._attributes;
    } },

  firstElementChild: { get: function get() {
      for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
        if (kid.nodeType === Node.ELEMENT_NODE) return kid;
      }
      return null;
    } },

  lastElementChild: { get: function get() {
      for (var kid = this.lastChild; kid !== null; kid = kid.previousSibling) {
        if (kid.nodeType === Node.ELEMENT_NODE) return kid;
      }
      return null;
    } },

  childElementCount: { get: function get() {
      return this.children.length;
    } },

  // Return the next element, in source order, after this one or
  // null if there are no more.  If root element is specified,
  // then don't traverse beyond its subtree.
  //
  // This is not a DOM method, but is convenient for
  // lazy traversals of the tree.
  nextElement: { value: function value(root) {
      if (!root) root = this.ownerDocument.documentElement;
      var next = this.firstElementChild;
      if (!next) {
        // don't use sibling if we're at root
        if (this === root) return null;
        next = this.nextElementSibling;
      }
      if (next) return next;

      // If we can't go down or across, then we have to go up
      // and across to the parent sibling or another ancestor's
      // sibling.  Be careful, though: if we reach the root
      // element, or if we reach the documentElement, then
      // the traversal ends.
      for (var parent = this.parentElement; parent && parent !== root; parent = parent.parentElement) {

        next = parent.nextElementSibling;
        if (next) return next;
      }

      return null;
    } },

  // XXX:
  // Tests are currently failing for this function.
  // Awaiting resolution of:
  // http://lists.w3.org/Archives/Public/www-dom/2011JulSep/0016.html
  getElementsByTagName: { value: function getElementsByTagName(lname) {
      var filter;
      if (!lname) return new NodeList();
      if (lname === '*') filter = function filter() {
        return true;
      };else if (this.isHTML) filter = htmlLocalNameElementFilter(lname);else filter = localNameElementFilter(lname);

      return new FilteredElementList(this, filter);
    } },

  getElementsByTagNameNS: { value: function getElementsByTagNameNS(ns, lname) {
      var filter;
      if (ns === '*' && lname === '*') filter = function filter() {
        return true;
      };else if (ns === '*') filter = localNameElementFilter(lname);else if (lname === '*') filter = namespaceElementFilter(ns);else filter = namespaceLocalNameElementFilter(ns, lname);

      return new FilteredElementList(this, filter);
    } },

  getElementsByClassName: { value: function getElementsByClassName(names) {
      names = String(names).trim();
      if (names === '') {
        var result = new NodeList(); // Empty node list
        return result;
      }
      names = names.split(/[ \t\r\n\f]+/); // Split on ASCII whitespace
      return new FilteredElementList(this, classNamesElementFilter(names));
    } },

  getElementsByName: { value: function getElementsByName(name) {
      return new FilteredElementList(this, elementNameFilter(String(name)));
    } },

  // Utility methods used by the public API methods above
  clone: { value: function clone() {
      var e;

      // XXX:
      // Modify this to use the constructor directly or
      // avoid error checking in some other way. In case we try
      // to clone an invalid node that the parser inserted.
      //
      if (this.namespaceURI !== NAMESPACE.HTML || this.prefix || !this.ownerDocument.isHTML) {
        e = this.ownerDocument.createElementNS(this.namespaceURI, this.prefix !== null ? this.prefix + ':' + this.localName : this.localName);
      } else {
        e = this.ownerDocument.createElement(this.localName);
      }

      for (var i = 0, n = this._attrKeys.length; i < n; i++) {
        var lname = this._attrKeys[i];
        var a = this._attrsByLName[lname];
        var b = a.cloneNode();
        b._setOwnerElement(e);
        e._attrsByLName[lname] = b;
        e._addQName(b);
      }
      e._attrKeys = this._attrKeys.concat();

      return e;
    } },

  isEqual: { value: function isEqual(that) {
      if (this.localName !== that.localName || this.namespaceURI !== that.namespaceURI || this.prefix !== that.prefix || this._numattrs !== that._numattrs) return false;

      // Compare the sets of attributes, ignoring order
      // and ignoring attribute prefixes.
      for (var i = 0, n = this._numattrs; i < n; i++) {
        var a = this._attr(i);
        if (!that.hasAttributeNS(a.namespaceURI, a.localName)) return false;
        if (that.getAttributeNS(a.namespaceURI, a.localName) !== a.value) return false;
      }

      return true;
    } },

  // This is the 'locate a namespace prefix' algorithm from the
  // DOM specification.  It is used by Node.lookupPrefix()
  // (Be sure to compare DOM3 and DOM4 versions of spec.)
  _lookupNamespacePrefix: { value: function _lookupNamespacePrefix(ns, originalElement) {
      if (this.namespaceURI && this.namespaceURI === ns && this.prefix !== null && originalElement.lookupNamespaceURI(this.prefix) === ns) {
        return this.prefix;
      }

      for (var i = 0, n = this._numattrs; i < n; i++) {
        var a = this._attr(i);
        if (a.prefix === 'xmlns' && a.value === ns && originalElement.lookupNamespaceURI(a.localName) === ns) {
          return a.localName;
        }
      }

      var parent = this.parentElement;
      return parent ? parent._lookupNamespacePrefix(ns, originalElement) : null;
    } },

  // This is the 'locate a namespace' algorithm for Element nodes
  // from the DOM Core spec.  It is used by Node#lookupNamespaceURI()
  lookupNamespaceURI: { value: function lookupNamespaceURI(prefix) {
      if (prefix === '' || prefix === undefined) {
        prefix = null;
      }
      if (this.namespaceURI !== null && this.prefix === prefix) return this.namespaceURI;

      for (var i = 0, n = this._numattrs; i < n; i++) {
        var a = this._attr(i);
        if (a.namespaceURI === NAMESPACE.XMLNS) {
          if (a.prefix === 'xmlns' && a.localName === prefix || prefix === null && a.prefix === null && a.localName === 'xmlns') {
            return a.value || null;
          }
        }
      }

      var parent = this.parentElement;
      return parent ? parent.lookupNamespaceURI(prefix) : null;
    } },

  //
  // Attribute handling methods and utilities
  //

  /*
   * Attributes in the DOM are tricky:
   *
   * - there are the 8 basic get/set/has/removeAttribute{NS} methods
   *
   * - but many HTML attributes are also 'reflected' through IDL
   *   attributes which means that they can be queried and set through
   *   regular properties of the element.  There is just one attribute
   *   value, but two ways to get and set it.
   *
   * - Different HTML element types have different sets of reflected
     attributes.
   *
   * - attributes can also be queried and set through the .attributes
   *   property of an element.  This property behaves like an array of
   *   Attr objects.  The value property of each Attr is writeable, so
   *   this is a third way to read and write attributes.
   *
   * - for efficiency, we really want to store attributes in some kind
   *   of name->attr map.  But the attributes[] array is an array, not a
   *   map, which is kind of unnatural.
   *
   * - When using namespaces and prefixes, and mixing the NS methods
   *   with the non-NS methods, it is apparently actually possible for
   *   an attributes[] array to have more than one attribute with the
   *   same qualified name.  And certain methods must operate on only
   *   the first attribute with such a name.  So for these methods, an
   *   inefficient array-like data structure would be easier to
   *   implement.
   *
   * - The attributes[] array is live, not a snapshot, so changes to the
   *   attributes must be immediately visible through existing arrays.
   *
   * - When attributes are queried and set through IDL properties
   *   (instead of the get/setAttributes() method or the attributes[]
   *   array) they may be subject to type conversions, URL
   *   normalization, etc., so some extra processing is required in that
   *   case.
   *
   * - But access through IDL properties is probably the most common
   *   case, so we'd like that to be as fast as possible.
   *
   * - We can't just store attribute values in their parsed idl form,
   *   because setAttribute() has to return whatever string is passed to
   *   getAttribute even if it is not a legal, parseable value. So
   *   attribute values must be stored in unparsed string form.
   *
   * - We need to be able to send change notifications or mutation
   *   events of some sort to the renderer whenever an attribute value
   *   changes, regardless of the way in which it changes.
   *
   * - Some attributes, such as id and class affect other parts of the
   *   DOM API, like getElementById and getElementsByClassName and so
   *   for efficiency, we need to specially track changes to these
   *   special attributes.
   *
   * - Some attributes like class have different names (className) when
   *   reflected.
   *
   * - Attributes whose names begin with the string 'data-' are treated
     specially.
   *
   * - Reflected attributes that have a boolean type in IDL have special
   *   behavior: setting them to false (in IDL) is the same as removing
   *   them with removeAttribute()
   *
   * - numeric attributes (like HTMLElement.tabIndex) can have default
   *   values that must be returned by the idl getter even if the
   *   content attribute does not exist. (The default tabIndex value
   *   actually varies based on the type of the element, so that is a
   *   tricky one).
   *
   * See
   * http://www.whatwg.org/specs/web-apps/current-work/multipage/urls.html#reflect
   * for rules on how attributes are reflected.
   *
   */

  getAttribute: { value: function getAttribute(qname) {
      var attr = this.getAttributeNode(qname);
      return attr ? attr.value : null;
    } },

  getAttributeNS: { value: function getAttributeNS(ns, lname) {
      var attr = this.getAttributeNodeNS(ns, lname);
      return attr ? attr.value : null;
    } },

  getAttributeNode: { value: function getAttributeNode(qname) {
      qname = String(qname);
      if (/[A-Z]/.test(qname) && this.isHTML) qname = utils.toASCIILowerCase(qname);
      var attr = this._attrsByQName[qname];
      if (!attr) return null;

      if (Array.isArray(attr)) // If there is more than one
        attr = attr[0]; // use the first

      return attr;
    } },

  getAttributeNodeNS: { value: function getAttributeNodeNS(ns, lname) {
      ns = ns === undefined || ns === null ? '' : String(ns);
      lname = String(lname);
      var attr = this._attrsByLName[ns + '|' + lname];
      return attr ? attr : null;
    } },

  hasAttribute: { value: function hasAttribute(qname) {
      qname = String(qname);
      if (/[A-Z]/.test(qname) && this.isHTML) qname = utils.toASCIILowerCase(qname);
      return this._attrsByQName[qname] !== undefined;
    } },

  hasAttributeNS: { value: function hasAttributeNS(ns, lname) {
      ns = ns === undefined || ns === null ? '' : String(ns);
      lname = String(lname);
      var key = ns + '|' + lname;
      return this._attrsByLName[key] !== undefined;
    } },

  hasAttributes: { value: function hasAttributes() {
      return this._numattrs > 0;
    } },

  toggleAttribute: { value: function toggleAttribute(qname, force) {
      qname = String(qname);
      if (!xml.isValidName(qname)) utils.InvalidCharacterError();
      if (/[A-Z]/.test(qname) && this.isHTML) qname = utils.toASCIILowerCase(qname);
      var a = this._attrsByQName[qname];
      if (a === undefined) {
        if (force === undefined || force === true) {
          this._setAttribute(qname, '');
          return true;
        }
        return false;
      } else {
        if (force === undefined || force === false) {
          this.removeAttribute(qname);
          return false;
        }
        return true;
      }
    } },

  // Set the attribute without error checking. The parser uses this.
  _setAttribute: { value: function _setAttribute(qname, value) {
      // XXX: the spec says that this next search should be done
      // on the local name, but I think that is an error.
      // email pending on www-dom about it.
      var attr = this._attrsByQName[qname];
      var isnew;
      if (!attr) {
        attr = this._newattr(qname);
        isnew = true;
      } else {
        if (Array.isArray(attr)) attr = attr[0];
      }

      // Now set the attribute value on the new or existing Attr object.
      // The Attr.value setter method handles mutation events, etc.
      attr.value = value;
      if (this._attributes) this._attributes[qname] = attr;
      if (isnew && this._newattrhook) this._newattrhook(qname, value);
    } },

  // Check for errors, and then set the attribute
  setAttribute: { value: function setAttribute(qname, value) {
      qname = String(qname);
      if (!xml.isValidName(qname)) utils.InvalidCharacterError();
      if (/[A-Z]/.test(qname) && this.isHTML) qname = utils.toASCIILowerCase(qname);
      this._setAttribute(qname, String(value));
    } },

  // The version with no error checking used by the parser
  _setAttributeNS: { value: function _setAttributeNS(ns, qname, value) {
      var pos = qname.indexOf(':'),
          prefix,
          lname;
      if (pos < 0) {
        prefix = null;
        lname = qname;
      } else {
        prefix = qname.substring(0, pos);
        lname = qname.substring(pos + 1);
      }

      if (ns === '' || ns === undefined) ns = null;
      var key = (ns === null ? '' : ns) + '|' + lname;

      var attr = this._attrsByLName[key];
      var isnew;
      if (!attr) {
        attr = new Attr(this, lname, prefix, ns);
        isnew = true;
        this._attrsByLName[key] = attr;
        if (this._attributes) {
          this._attributes[this._attrKeys.length] = attr;
        }
        this._attrKeys.push(key);

        // We also have to make the attr searchable by qname.
        // But we have to be careful because there may already
        // be an attr with this qname.
        this._addQName(attr);
      } else if (false /* changed in DOM 4 */) {
          // Calling setAttributeNS() can change the prefix of an
          // existing attribute in DOM 2/3.
          if (attr.prefix !== prefix) {
            // Unbind the old qname
            this._removeQName(attr);
            // Update the prefix
            attr.prefix = prefix;
            // Bind the new qname
            this._addQName(attr);
          }
        }
      attr.value = value; // Automatically sends mutation event
      if (isnew && this._newattrhook) this._newattrhook(qname, value);
    } },

  // Do error checking then call _setAttributeNS
  setAttributeNS: { value: function setAttributeNS(ns, qname, value) {
      // Convert parameter types according to WebIDL
      ns = ns === null || ns === undefined || ns === '' ? null : String(ns);
      qname = String(qname);
      if (!xml.isValidQName(qname)) utils.InvalidCharacterError();

      var pos = qname.indexOf(':');
      var prefix = pos < 0 ? null : qname.substring(0, pos);

      if (prefix !== null && ns === null || prefix === 'xml' && ns !== NAMESPACE.XML || (qname === 'xmlns' || prefix === 'xmlns') && ns !== NAMESPACE.XMLNS || ns === NAMESPACE.XMLNS && !(qname === 'xmlns' || prefix === 'xmlns')) utils.NamespaceError();

      this._setAttributeNS(ns, qname, String(value));
    } },

  setAttributeNode: { value: function setAttributeNode(attr) {
      if (attr.ownerElement !== null && attr.ownerElement !== this) {
        throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);
      }
      var result = null;
      var oldAttrs = this._attrsByQName[attr.name];
      if (oldAttrs) {
        if (!Array.isArray(oldAttrs)) {
          oldAttrs = [oldAttrs];
        }
        if (oldAttrs.some(function (a) {
          return a === attr;
        })) {
          return attr;
        } else if (attr.ownerElement !== null) {
          throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);
        }
        oldAttrs.forEach(function (a) {
          this.removeAttributeNode(a);
        }, this);
        result = oldAttrs[0];
      }
      this.setAttributeNodeNS(attr);
      return result;
    } },

  setAttributeNodeNS: { value: function setAttributeNodeNS(attr) {
      if (attr.ownerElement !== null) {
        throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);
      }
      var ns = attr.namespaceURI;
      var key = (ns === null ? '' : ns) + '|' + attr.localName;
      var oldAttr = this._attrsByLName[key];
      if (oldAttr) {
        this.removeAttributeNode(oldAttr);
      }
      attr._setOwnerElement(this);
      this._attrsByLName[key] = attr;
      if (this._attributes) {
        this._attributes[this._attrKeys.length] = attr;
      }
      this._attrKeys.push(key);
      this._addQName(attr);
      if (this._newattrhook) this._newattrhook(attr.name, attr.value);
      return oldAttr || null;
    } },

  removeAttribute: { value: function removeAttribute(qname) {
      qname = String(qname);
      if (/[A-Z]/.test(qname) && this.isHTML) qname = utils.toASCIILowerCase(qname);

      var attr = this._attrsByQName[qname];
      if (!attr) return;

      // If there is more than one match for this qname
      // so don't delete the qname mapping, just remove the first
      // element from it.
      if (Array.isArray(attr)) {
        if (attr.length > 2) {
          attr = attr.shift(); // remove it from the array
        } else {
          this._attrsByQName[qname] = attr[1];
          attr = attr[0];
        }
      } else {
        // only a single match, so remove the qname mapping
        this._attrsByQName[qname] = undefined;
      }

      var ns = attr.namespaceURI;
      // Now attr is the removed attribute.  Figure out its
      // ns+lname key and remove it from the other mapping as well.
      var key = (ns === null ? '' : ns) + '|' + attr.localName;
      this._attrsByLName[key] = undefined;

      var i = this._attrKeys.indexOf(key);
      if (this._attributes) {
        Array.prototype.splice.call(this._attributes, i, 1);
        this._attributes[qname] = undefined;
      }
      this._attrKeys.splice(i, 1);

      // Onchange handler for the attribute
      var onchange = attr.onchange;
      attr._setOwnerElement(null);
      if (onchange) {
        onchange.call(attr, this, attr.localName, attr.value, null);
      }
      // Mutation event
      if (this.rooted) this.ownerDocument.mutateRemoveAttr(attr);
    } },

  removeAttributeNS: { value: function removeAttributeNS(ns, lname) {
      ns = ns === undefined || ns === null ? '' : String(ns);
      lname = String(lname);
      var key = ns + '|' + lname;
      var attr = this._attrsByLName[key];
      if (!attr) return;

      this._attrsByLName[key] = undefined;

      var i = this._attrKeys.indexOf(key);
      if (this._attributes) {
        Array.prototype.splice.call(this._attributes, i, 1);
      }
      this._attrKeys.splice(i, 1);

      // Now find the same Attr object in the qname mapping and remove it
      // But be careful because there may be more than one match.
      this._removeQName(attr);

      // Onchange handler for the attribute
      var onchange = attr.onchange;
      attr._setOwnerElement(null);
      if (onchange) {
        onchange.call(attr, this, attr.localName, attr.value, null);
      }
      // Mutation event
      if (this.rooted) this.ownerDocument.mutateRemoveAttr(attr);
    } },

  removeAttributeNode: { value: function removeAttributeNode(attr) {
      var ns = attr.namespaceURI;
      var key = (ns === null ? '' : ns) + '|' + attr.localName;
      if (this._attrsByLName[key] !== attr) {
        utils.NotFoundError();
      }
      this.removeAttributeNS(ns, attr.localName);
      return attr;
    } },

  getAttributeNames: { value: function getAttributeNames() {
      var elt = this;
      return this._attrKeys.map(function (key) {
        return elt._attrsByLName[key].name;
      });
    } },

  // This 'raw' version of getAttribute is used by the getter functions
  // of reflected attributes. It skips some error checking and
  // namespace steps
  _getattr: { value: function _getattr(qname) {
      // Assume that qname is already lowercased, so don't do it here.
      // Also don't check whether attr is an array: a qname with no
      // prefix will never have two matching Attr objects (because
      // setAttributeNS doesn't allow a non-null namespace with a
      // null prefix.
      var attr = this._attrsByQName[qname];
      return attr ? attr.value : null;
    } },

  // The raw version of setAttribute for reflected idl attributes.
  _setattr: { value: function _setattr(qname, value) {
      var attr = this._attrsByQName[qname];
      var isnew;
      if (!attr) {
        attr = this._newattr(qname);
        isnew = true;
      }
      attr.value = String(value);
      if (this._attributes) this._attributes[qname] = attr;
      if (isnew && this._newattrhook) this._newattrhook(qname, value);
    } },

  // Create a new Attr object, insert it, and return it.
  // Used by setAttribute() and by set()
  _newattr: { value: function _newattr(qname) {
      var attr = new Attr(this, qname, null, null);
      var key = '|' + qname;
      this._attrsByQName[qname] = attr;
      this._attrsByLName[key] = attr;
      if (this._attributes) {
        this._attributes[this._attrKeys.length] = attr;
      }
      this._attrKeys.push(key);
      return attr;
    } },

  // Add a qname->Attr mapping to the _attrsByQName object, taking into
  // account that there may be more than one attr object with the
  // same qname
  _addQName: { value: function value(attr) {
      var qname = attr.name;
      var existing = this._attrsByQName[qname];
      if (!existing) {
        this._attrsByQName[qname] = attr;
      } else if (Array.isArray(existing)) {
        existing.push(attr);
      } else {
        this._attrsByQName[qname] = [existing, attr];
      }
      if (this._attributes) this._attributes[qname] = attr;
    } },

  // Remove a qname->Attr mapping to the _attrsByQName object, taking into
  // account that there may be more than one attr object with the
  // same qname
  _removeQName: { value: function value(attr) {
      var qname = attr.name;
      var target = this._attrsByQName[qname];

      if (Array.isArray(target)) {
        var idx = target.indexOf(attr);
        utils.assert(idx !== -1); // It must be here somewhere
        if (target.length === 2) {
          this._attrsByQName[qname] = target[1 - idx];
          if (this._attributes) {
            this._attributes[qname] = this._attrsByQName[qname];
          }
        } else {
          target.splice(idx, 1);
          if (this._attributes && this._attributes[qname] === attr) {
            this._attributes[qname] = target[0];
          }
        }
      } else {
        utils.assert(target === attr); // If only one, it must match
        this._attrsByQName[qname] = undefined;
        if (this._attributes) {
          this._attributes[qname] = undefined;
        }
      }
    } },

  // Return the number of attributes
  _numattrs: { get: function get() {
      return this._attrKeys.length;
    } },
  // Return the nth Attr object
  _attr: { value: function value(n) {
      return this._attrsByLName[this._attrKeys[n]];
    } },

  // Define getters and setters for an 'id' property that reflects
  // the content attribute 'id'.
  id: attributes.property({ name: 'id' }),

  // Define getters and setters for a 'className' property that reflects
  // the content attribute 'class'.
  className: attributes.property({ name: 'class' }),

  classList: { get: function get() {
      var self = this;
      if (this._classList) {
        return this._classList;
      }
      var dtlist = new DOMTokenList(function () {
        return self.className || "";
      }, function (v) {
        self.className = v;
      });
      this._classList = dtlist;
      return dtlist;
    }, set: function set(v) {
      this.className = v;
    } },

  matches: { value: function value(selector) {
      return select.matches(this, selector);
    } },

  closest: { value: function value(selector) {
      var el = this;
      do {
        if (el.matches && el.matches(selector)) {
          return el;
        }
        el = el.parentElement || el.parentNode;
      } while (el !== null && el.nodeType === Node.ELEMENT_NODE);
      return null;
    } },

  querySelector: { value: function value(selector) {
      return select(selector, this)[0];
    } },

  querySelectorAll: { value: function value(selector) {
      var nodes = select(selector, this);
      return nodes.item ? nodes : new NodeList(nodes);
    } }

});

Object.defineProperties(Element.prototype, ChildNode);
Object.defineProperties(Element.prototype, NonDocumentTypeChildNode);

// Register special handling for the id attribute
attributes.registerChangeHandler(Element, 'id', function (element, lname, oldval, newval) {
  if (element.rooted) {
    if (oldval) {
      element.ownerDocument.delId(oldval, element);
    }
    if (newval) {
      element.ownerDocument.addId(newval, element);
    }
  }
});
attributes.registerChangeHandler(Element, 'class', function (element, lname, oldval, newval) {
  if (element._classList) {
    element._classList._update();
  }
});

// The Attr class represents a single attribute.  The values in
// _attrsByQName and _attrsByLName are instances of this class.
function Attr(elt, lname, prefix, namespace, value) {
  // localName and namespace are constant for any attr object.
  // But value may change.  And so can prefix, and so, therefore can name.
  this.localName = lname;
  this.prefix = prefix === null || prefix === '' ? null : '' + prefix;
  this.namespaceURI = namespace === null || namespace === '' ? null : '' + namespace;
  this.data = value;
  // Set ownerElement last to ensure it is hooked up to onchange handler
  this._setOwnerElement(elt);
}

// In DOM 3 Attr was supposed to extend Node; in DOM 4 that was abandoned.
Attr.prototype = Object.create(Object.prototype, {
  ownerElement: {
    get: function get() {
      return this._ownerElement;
    }
  },
  _setOwnerElement: { value: function _setOwnerElement(elt) {
      this._ownerElement = elt;
      if (this.prefix === null && this.namespaceURI === null && elt) {
        this.onchange = elt._attributeChangeHandlers[this.localName];
      } else {
        this.onchange = null;
      }
    } },

  name: { get: function get() {
      return this.prefix ? this.prefix + ':' + this.localName : this.localName;
    } },

  specified: { get: function get() {
      // Deprecated
      return true;
    } },

  value: {
    get: function get() {
      return this.data;
    },
    set: function set(value) {
      var oldval = this.data;
      value = value === undefined ? '' : value + '';
      if (value === oldval) return;

      this.data = value;

      // Run the onchange hook for the attribute
      // if there is one.
      if (this.ownerElement) {
        if (this.onchange) this.onchange(this.ownerElement, this.localName, oldval, value);

        // Generate a mutation event if the element is rooted
        if (this.ownerElement.rooted) this.ownerElement.ownerDocument.mutateAttr(this, oldval);
      }
    }
  },

  cloneNode: { value: function cloneNode(deep) {
      // Both this method and Document#createAttribute*() create unowned Attrs
      return new Attr(null, this.localName, this.prefix, this.namespaceURI, this.data);
    } },

  // Legacy aliases (see gh#70 and https://dom.spec.whatwg.org/#interface-attr)
  nodeType: { get: function get() {
      return Node.ATTRIBUTE_NODE;
    } },
  nodeName: { get: function get() {
      return this.name;
    } },
  nodeValue: {
    get: function get() {
      return this.value;
    },
    set: function set(v) {
      this.value = v;
    }
  },
  textContent: {
    get: function get() {
      return this.value;
    },
    set: function set(v) {
      if (v === null || v === undefined) {
        v = '';
      }
      this.value = v;
    }
  }
});
// Sneakily export this class for use by Document.createAttribute()
Element._Attr = Attr;

// The attributes property of an Element will be an instance of this class.
// This class is really just a dummy, though. It only defines a length
// property and an item() method. The AttrArrayProxy that
// defines the public API just uses the Element object itself.
function AttributesArray(elt) {
  NamedNodeMap.call(this, elt);
  for (var name in elt._attrsByQName) {
    this[name] = elt._attrsByQName[name];
  }
  for (var i = 0; i < elt._attrKeys.length; i++) {
    this[i] = elt._attrsByLName[elt._attrKeys[i]];
  }
}
AttributesArray.prototype = Object.create(NamedNodeMap.prototype, {
  length: { get: function get() {
      return this.element._attrKeys.length;
    }, set: function set() {/* ignore */} },
  item: { value: function value(n) {
      /* jshint bitwise: false */
      n = n >>> 0;
      if (n >= this.length) {
        return null;
      }
      return this.element._attrsByLName[this.element._attrKeys[n]];
      /* jshint bitwise: true */
    } }
});

// // We can't make direct array access work (without Proxies, node >=6)
// // but we can make `Array.from(node.attributes)` and for-of loops work.
// if (global.Symbol && global.Symbol.iterator) {
//     AttributesArray.prototype[global.Symbol.iterator] = function() {
//         var i=0, n=this.length, self=this;
//         return {
//             next: function() {
//                 if (i<n) return { value: self.item(i++) };
//                 return { done: true };
//             }
//         };
//     };
// }


// The children property of an Element will be an instance of this class.
// It defines length, item() and namedItem() and will be wrapped by an
// HTMLCollection when exposed through the DOM.
function ChildrenCollection(e) {
  this.element = e;
  this.updateCache();
}

ChildrenCollection.prototype = Object.create(Object.prototype, {
  length: { get: function get() {
      this.updateCache();
      return this.childrenByNumber.length;
    } },
  item: { value: function item(n) {
      this.updateCache();
      return this.childrenByNumber[n] || null;
    } },

  namedItem: { value: function namedItem(name) {
      this.updateCache();
      return this.childrenByName[name] || null;
    } },

  // This attribute returns the entire name->element map.
  // It is not part of the HTMLCollection API, but we need it in
  // src/HTMLCollectionProxy
  namedItems: { get: function get() {
      this.updateCache();
      return this.childrenByName;
    } },

  updateCache: { value: function updateCache() {
      var namedElts = /^(a|applet|area|embed|form|frame|frameset|iframe|img|object)$/;
      if (this.lastModTime !== this.element.lastModTime) {
        this.lastModTime = this.element.lastModTime;

        var n = this.childrenByNumber && this.childrenByNumber.length || 0;
        for (var i = 0; i < n; i++) {
          this[i] = undefined;
        }

        this.childrenByNumber = [];
        this.childrenByName = Object.create(null);

        for (var c = this.element.firstChild; c !== null; c = c.nextSibling) {
          if (c.nodeType === Node.ELEMENT_NODE) {

            this[this.childrenByNumber.length] = c;
            this.childrenByNumber.push(c);

            // XXX Are there any requirements about the namespace
            // of the id property?
            var id = c.getAttribute('id');

            // If there is an id that is not already in use...
            if (id && !this.childrenByName[id]) this.childrenByName[id] = c;

            // For certain HTML elements we check the name attribute
            var name = c.getAttribute('name');
            if (name && this.element.namespaceURI === NAMESPACE.HTML && namedElts.test(this.element.localName) && !this.childrenByName[name]) this.childrenByName[id] = c;
          }
        }
      }
    } }
});

// These functions return predicates for filtering elements.
// They're used by the Document and Element classes for methods like
// getElementsByTagName and getElementsByClassName

function localNameElementFilter(lname) {
  return function (e) {
    return e.localName === lname;
  };
}

function htmlLocalNameElementFilter(lname) {
  var lclname = utils.toASCIILowerCase(lname);
  if (lclname === lname) return localNameElementFilter(lname);

  return function (e) {
    return e.isHTML ? e.localName === lclname : e.localName === lname;
  };
}

function namespaceElementFilter(ns) {
  return function (e) {
    return e.namespaceURI === ns;
  };
}

function namespaceLocalNameElementFilter(ns, lname) {
  return function (e) {
    return e.namespaceURI === ns && e.localName === lname;
  };
}

function classNamesElementFilter(names) {
  return function (e) {
    return names.every(function (n) {
      return e.classList.contains(n);
    });
  };
}

function elementNameFilter(name) {
  return function (e) {
    // All the *HTML elements* in the document with the given name attribute
    if (e.namespaceURI !== NAMESPACE.HTML) {
      return false;
    }
    return e.getAttribute('name') === name;
  };
}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = __webpack_require__(7);

var _regenerator2 = _interopRequireDefault(_regenerator);

var request = function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee(method, url, body) {
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        _context.next = 2;
                        return _utils2.default.request(method, url, "json", body, {
                            'Content-Type': 'application/json;charset=UTF-8'
                        });

                    case 2:
                        return _context.abrupt('return', _context.sent);

                    case 3:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, this);
    }));

    return function request(_x, _x2, _x3) {
        return _ref.apply(this, arguments);
    };
}();

var _utils = __webpack_require__(15);

var _utils2 = _interopRequireDefault(_utils);

var _index = __webpack_require__(71);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

__webpack_require__(83);

var clientId = 'c5544e74d50886f97db7dc3d0e329a50150073627894a600ad15bc990dd8a7f0';
var clientSecret = '17c6a2209b1f8c732388d49713cdf08ab20aa67ab8aa38a799d490c821275d78';
var redirectUri = 'http://weex.gitee.client/login';

var userInfoCache = null;

exports.default = {
    loginUrl: 'https://gitee.com/oauth/authorize?client_id=' + clientId + '&redirect_uri=' + redirectUri + '&response_type=code',
    handleLogin: function handleLogin(url) {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
            var code, data;
            return _regenerator2.default.wrap(function _callee2$(_context2) {
                while (1) {
                    switch (_context2.prev = _context2.next) {
                        case 0:
                            if (!(url != null && url.startsWith(redirectUri))) {
                                _context2.next = 12;
                                break;
                            }

                            code = _utils2.default.getQueryVariable(url.toString(), 'code');
                            _context2.next = 4;
                            return _utils2.default.request('POST', 'https://gitee.com/oauth/token?grant_type=authorization_code&code=' + code + '&client_id=' + clientId + '&redirect_uri=' + redirectUri + '&client_secret=' + clientSecret, 'json', {}, {
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36'
                            });

                        case 4:
                            data = _context2.sent;
                            _context2.next = 7;
                            return _utils2.default.setValue('access_token', data["access_token"]);

                        case 7:
                            _context2.next = 9;
                            return _utils2.default.setValue('refresh_token', data["refresh_token"]);

                        case 9:
                            return _context2.abrupt('return', true);

                        case 12:
                            return _context2.abrupt('return', false);

                        case 13:
                        case 'end':
                            return _context2.stop();
                    }
                }
            }, _callee2, _this);
        }))();
    },
    isLogin: function isLogin() {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
            var refreshToken, data;
            return _regenerator2.default.wrap(function _callee3$(_context3) {
                while (1) {
                    switch (_context3.prev = _context3.next) {
                        case 0:
                            _context3.next = 2;
                            return _utils2.default.getValue('refresh_token');

                        case 2:
                            refreshToken = _context3.sent;

                            if (!(refreshToken == null)) {
                                _context3.next = 7;
                                break;
                            }

                            return _context3.abrupt('return', false);

                        case 7:
                            _context3.prev = 7;
                            _context3.next = 10;
                            return _this2.loadMyInfo();

                        case 10:
                            return _context3.abrupt('return', true);

                        case 13:
                            _context3.prev = 13;
                            _context3.t0 = _context3['catch'](7);
                            _context3.prev = 15;
                            _context3.next = 18;
                            return _utils2.default.request("POST", 'https://gitee.com/oauth/token?grant_type=refresh_token&refresh_token=' + refreshToken, 'json');

                        case 18:
                            data = _context3.sent;
                            _context3.next = 21;
                            return _utils2.default.setValue('access_token', data["access_token"]);

                        case 21:
                            return _context3.abrupt('return', true);

                        case 24:
                            _context3.prev = 24;
                            _context3.t1 = _context3['catch'](15);
                            return _context3.abrupt('return', false);

                        case 27:
                        case 'end':
                            return _context3.stop();
                    }
                }
            }, _callee3, _this2, [[7, 13], [15, 24]]);
        }))();
    },
    cancelFollowing: function cancelFollowing(username, isFollowing) {
        var _this3 = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
            var accessToken, url;
            return _regenerator2.default.wrap(function _callee4$(_context4) {
                while (1) {
                    switch (_context4.prev = _context4.next) {
                        case 0:
                            _context4.next = 2;
                            return _utils2.default.getValue('access_token');

                        case 2:
                            accessToken = _context4.sent;
                            url = 'https://gitee.com/api/v5/user/following/' + username + '?access_token=' + accessToken;
                            _context4.next = 6;
                            return request("DELETE", url);

                        case 6:
                            return _context4.abrupt('return', _context4.sent);

                        case 7:
                        case 'end':
                            return _context4.stop();
                    }
                }
            }, _callee4, _this3);
        }))();
    },
    following: function following(username, isFollowing) {
        var _this4 = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee5() {
            var accessToken, url;
            return _regenerator2.default.wrap(function _callee5$(_context5) {
                while (1) {
                    switch (_context5.prev = _context5.next) {
                        case 0:
                            _context5.next = 2;
                            return _utils2.default.getValue('access_token');

                        case 2:
                            accessToken = _context5.sent;
                            url = 'https://gitee.com/api/v5/user/following/' + username;
                            _context5.next = 6;
                            return request("PUT", url, {
                                "access_token": accessToken
                            });

                        case 6:
                            return _context5.abrupt('return', _context5.sent);

                        case 7:
                        case 'end':
                            return _context5.stop();
                    }
                }
            }, _callee5, _this4);
        }))();
    },
    getUser: function getUser(username) {
        var _this5 = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee6() {
            var accessToken, url;
            return _regenerator2.default.wrap(function _callee6$(_context6) {
                while (1) {
                    switch (_context6.prev = _context6.next) {
                        case 0:
                            _context6.next = 2;
                            return _utils2.default.getValue('access_token');

                        case 2:
                            accessToken = _context6.sent;
                            url = 'https://gitee.com/api/v5/users/' + username + '?access_token=' + accessToken;
                            _context6.next = 6;
                            return request("GET", url);

                        case 6:
                            return _context6.abrupt('return', _context6.sent);

                        case 7:
                        case 'end':
                            return _context6.stop();
                    }
                }
            }, _callee6, _this5);
        }))();
    },
    getUserFollowers: function getUserFollowers(username, page, countAtPage) {
        var _this6 = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee7() {
            var accessToken, url;
            return _regenerator2.default.wrap(function _callee7$(_context7) {
                while (1) {
                    switch (_context7.prev = _context7.next) {
                        case 0:
                            _context7.next = 2;
                            return _utils2.default.getValue('access_token');

                        case 2:
                            accessToken = _context7.sent;
                            url = 'https://gitee.com/api/v5/users/' + username + '/followers?access_token=' + accessToken + '&page=' + page + '&per_page=' + countAtPage;
                            _context7.next = 6;
                            return request("GET", url);

                        case 6:
                            return _context7.abrupt('return', _context7.sent);

                        case 7:
                        case 'end':
                            return _context7.stop();
                    }
                }
            }, _callee7, _this6);
        }))();
    },
    getUserFollowing: function getUserFollowing(username, page, countAtPage) {
        var _this7 = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee8() {
            var accessToken, url;
            return _regenerator2.default.wrap(function _callee8$(_context8) {
                while (1) {
                    switch (_context8.prev = _context8.next) {
                        case 0:
                            _context8.next = 2;
                            return _utils2.default.getValue('access_token');

                        case 2:
                            accessToken = _context8.sent;
                            url = 'https://gitee.com/api/v5/users/' + username + '/following?access_token=' + accessToken + '&page=' + page + '&per_page=' + countAtPage;
                            _context8.next = 6;
                            return request("GET", url);

                        case 6:
                            return _context8.abrupt('return', _context8.sent);

                        case 7:
                        case 'end':
                            return _context8.stop();
                    }
                }
            }, _callee8, _this7);
        }))();
    },
    star: function star(owner, repo) {
        var _this8 = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee9() {
            var accessToken, url;
            return _regenerator2.default.wrap(function _callee9$(_context9) {
                while (1) {
                    switch (_context9.prev = _context9.next) {
                        case 0:
                            _context9.next = 2;
                            return _utils2.default.getValue('access_token');

                        case 2:
                            accessToken = _context9.sent;
                            url = 'https://gitee.com/api/v5/user/starred/' + owner + '/' + repo;
                            _context9.next = 6;
                            return request("PUT", url, {
                                "access_token": accessToken
                            });

                        case 6:
                            return _context9.abrupt('return', _context9.sent);

                        case 7:
                        case 'end':
                            return _context9.stop();
                    }
                }
            }, _callee9, _this8);
        }))();
    },
    getStars: function getStars(page, countAtPage) {
        var _this9 = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee10() {
            var accessToken, url;
            return _regenerator2.default.wrap(function _callee10$(_context10) {
                while (1) {
                    switch (_context10.prev = _context10.next) {
                        case 0:
                            _context10.next = 2;
                            return _utils2.default.getValue('access_token');

                        case 2:
                            accessToken = _context10.sent;
                            url = 'https://gitee.com/api/v5/user/starred?access_token=' + accessToken + '&sort=created&direction=desc&page=' + page + '&per_page=' + countAtPage;
                            _context10.next = 6;
                            return request("GET", url);

                        case 6:
                            return _context10.abrupt('return', _context10.sent);

                        case 7:
                        case 'end':
                            return _context10.stop();
                    }
                }
            }, _callee10, _this9);
        }))();
    },
    cancelStar: function cancelStar(owner, repo) {
        var _this10 = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee11() {
            var accessToken, url;
            return _regenerator2.default.wrap(function _callee11$(_context11) {
                while (1) {
                    switch (_context11.prev = _context11.next) {
                        case 0:
                            _context11.next = 2;
                            return _utils2.default.getValue('access_token');

                        case 2:
                            accessToken = _context11.sent;
                            url = 'https://gitee.com/api/v5/user/starred/' + owner + '/' + repo + '?access_token=' + accessToken;
                            _context11.next = 6;
                            return request("DELETE", url);

                        case 6:
                            return _context11.abrupt('return', _context11.sent);

                        case 7:
                        case 'end':
                            return _context11.stop();
                    }
                }
            }, _callee11, _this10);
        }))();
    },
    watch: function watch(owner, repo) {
        var _this11 = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee12() {
            var accessToken, url;
            return _regenerator2.default.wrap(function _callee12$(_context12) {
                while (1) {
                    switch (_context12.prev = _context12.next) {
                        case 0:
                            _context12.next = 2;
                            return _utils2.default.getValue('access_token');

                        case 2:
                            accessToken = _context12.sent;
                            url = 'https://gitee.com/api/v5/user/subscriptions/' + owner + '/' + repo;
                            _context12.next = 6;
                            return request("PUT", url, {
                                "access_token": accessToken
                            });

                        case 6:
                            return _context12.abrupt('return', _context12.sent);

                        case 7:
                        case 'end':
                            return _context12.stop();
                    }
                }
            }, _callee12, _this11);
        }))();
    },
    cancelWatch: function cancelWatch(owner, repo) {
        var _this12 = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee13() {
            var accessToken, url;
            return _regenerator2.default.wrap(function _callee13$(_context13) {
                while (1) {
                    switch (_context13.prev = _context13.next) {
                        case 0:
                            _context13.next = 2;
                            return _utils2.default.getValue('access_token');

                        case 2:
                            accessToken = _context13.sent;
                            url = 'https://gitee.com/api/v5/user/subscriptions/' + owner + '/' + repo + '?access_token=' + accessToken;
                            _context13.next = 6;
                            return request("DELETE", url);

                        case 6:
                            return _context13.abrupt('return', _context13.sent);

                        case 7:
                        case 'end':
                            return _context13.stop();
                    }
                }
            }, _callee13, _this12);
        }))();
    },
    getEvents: function getEvents(username, page, countAtPage) {
        var _this13 = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee14() {
            var accessToken, url;
            return _regenerator2.default.wrap(function _callee14$(_context14) {
                while (1) {
                    switch (_context14.prev = _context14.next) {
                        case 0:
                            _context14.next = 2;
                            return _utils2.default.getValue('access_token');

                        case 2:
                            accessToken = _context14.sent;
                            url = 'https://gitee.com/api/v5/users/1/received_events?access_token=' + accessToken + '&page=' + page + '&per_page=' + countAtPage;
                            _context14.next = 6;
                            return request("GET", url);

                        case 6:
                            return _context14.abrupt('return', _context14.sent);

                        case 7:
                        case 'end':
                            return _context14.stop();
                    }
                }
            }, _callee14, _this13);
        }))();
    },
    getMyRepos: function getMyRepos(page, countAtPage) {
        var _this14 = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee15() {
            var accessToken, url;
            return _regenerator2.default.wrap(function _callee15$(_context15) {
                while (1) {
                    switch (_context15.prev = _context15.next) {
                        case 0:
                            _context15.next = 2;
                            return _utils2.default.getValue('access_token');

                        case 2:
                            accessToken = _context15.sent;
                            url = 'https://gitee.com/api/v5/user/repos?access_token=' + accessToken + '&visibility=all&sort=full_name&direction=asc&page=' + page + '&per_page=' + countAtPage;
                            _context15.next = 6;
                            return request("GET", url);

                        case 6:
                            return _context15.abrupt('return', _context15.sent);

                        case 7:
                        case 'end':
                            return _context15.stop();
                    }
                }
            }, _callee15, _this14);
        }))();
    },
    getOtherRepos: function getOtherRepos(username, page, countAtPage) {
        var _this15 = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee16() {
            var accessToken, url;
            return _regenerator2.default.wrap(function _callee16$(_context16) {
                while (1) {
                    switch (_context16.prev = _context16.next) {
                        case 0:
                            _context16.next = 2;
                            return _utils2.default.getValue('access_token');

                        case 2:
                            accessToken = _context16.sent;
                            url = 'https://gitee.com/api/v5/users/' + username + '/repos?access_token=' + accessToken + '&type=all&sort=full_name&page=' + page + '&per_page=' + countAtPage;
                            _context16.next = 6;
                            return request("GET", url);

                        case 6:
                            return _context16.abrupt('return', _context16.sent);

                        case 7:
                        case 'end':
                            return _context16.stop();
                    }
                }
            }, _callee16, _this15);
        }))();
    },
    search: function search(text, lang, page, countAtPage) {
        var _this16 = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee17() {
            var accessToken, url;
            return _regenerator2.default.wrap(function _callee17$(_context17) {
                while (1) {
                    switch (_context17.prev = _context17.next) {
                        case 0:
                            _context17.next = 2;
                            return _utils2.default.getValue('access_token');

                        case 2:
                            accessToken = _context17.sent;
                            url = 'https://gitee.com/api/v5/search/repositories?access_token=' + accessToken + '&q=' + text + '&page=' + page + '&per_page=' + countAtPage + '&order=desc';

                            if (lang != null) {
                                url += '&language=' + encodeURI(lang);
                            }
                            _context17.next = 7;
                            return request("GET", url);

                        case 7:
                            return _context17.abrupt('return', _context17.sent);

                        case 8:
                        case 'end':
                            return _context17.stop();
                    }
                }
            }, _callee17, _this16);
        }))();
    },
    loadMyInfo: function loadMyInfo() {
        var _this17 = this;

        var useCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee18() {
            var accessToken, url, data, login;
            return _regenerator2.default.wrap(function _callee18$(_context18) {
                while (1) {
                    switch (_context18.prev = _context18.next) {
                        case 0:
                            if (!(useCache && !(userInfoCache === null))) {
                                _context18.next = 2;
                                break;
                            }

                            return _context18.abrupt('return', userInfoCache);

                        case 2:
                            _context18.next = 4;
                            return _utils2.default.getValue('access_token');

                        case 4:
                            accessToken = _context18.sent;
                            url = 'https://gitee.com/api/v5/user?access_token=' + accessToken;
                            _context18.next = 8;
                            return request("GET", url);

                        case 8:
                            data = _context18.sent;
                            login = data['login'];
                            _context18.next = 12;
                            return _this17.getUser(login);

                        case 12:
                            userInfoCache = _context18.sent;
                            return _context18.abrupt('return', userInfoCache);

                        case 14:
                        case 'end':
                            return _context18.stop();
                    }
                }
            }, _callee18, _this17);
        }))();
    },
    getHotRepos: function getHotRepos() {
        var _this18 = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee19() {
            return _regenerator2.default.wrap(function _callee19$(_context19) {
                while (1) {
                    switch (_context19.prev = _context19.next) {
                        case 0:
                        case 'end':
                            return _context19.stop();
                    }
                }
            }, _callee19, _this18);
        }))();
    },
    getContributions: function getContributions(username, year) {
        var _this19 = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee20() {
            var url, content, head, index, index2, document, rawArray, result, now, i, item;
            return _regenerator2.default.wrap(function _callee20$(_context20) {
                while (1) {
                    switch (_context20.prev = _context20.next) {
                        case 0:
                            url = 'https://gitee.com/' + username + '/contribution_calendar?year=' + year;
                            _context20.next = 3;
                            return _utils2.default.fetch("GET", url, {
                                Accept: '*/*',
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36'
                            });

                        case 3:
                            content = _context20.sent;
                            head = "$contributionContainer.html(";
                            index = content.indexOf(head);
                            index2 = content.lastIndexOf(");");

                            content = content.substring(index + head.length, index2);
                            content = eval(content);
                            content = "<html><head><title></title></head><body>" + content + "</body></html>";
                            document = _index2.default.createDocument(content);
                            rawArray = document.querySelectorAll('div[data-content]');
                            result = [];
                            now = parseInt(new Date().format('Ymd'));

                            for (i = 0; i < rawArray.length; i++) {
                                item = rawArray[i];

                                if (now >= parseInt(item.getAttribute('date'))) {
                                    result.push({
                                        color: item.classList[1],
                                        text: item.getAttribute('data-content')
                                    });
                                }
                            }
                            return _context20.abrupt('return', result);

                        case 16:
                        case 'end':
                            return _context20.stop();
                    }
                }
            }, _callee20, _this19);
        }))();
    }
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = DOMImplementation;

var Document = __webpack_require__(16);
var DocumentType = __webpack_require__(27);
var HTMLParser = __webpack_require__(28);
var utils = __webpack_require__(1);
var xml = __webpack_require__(20);

// Each document must have its own instance of the domimplementation object
function DOMImplementation(contextObject) {
  this.contextObject = contextObject;
}

// Feature/version pairs that DOMImplementation.hasFeature() returns
// true for.  It returns false for anything else.
var supportedFeatures = {
  'xml': { '': true, '1.0': true, '2.0': true }, // DOM Core
  'core': { '': true, '2.0': true }, // DOM Core
  'html': { '': true, '1.0': true, '2.0': true }, // HTML
  'xhtml': { '': true, '1.0': true, '2.0': true } // HTML
};

DOMImplementation.prototype = {
  hasFeature: function hasFeature(feature, version) {
    var f = supportedFeatures[(feature || '').toLowerCase()];
    return f && f[version || ''] || false;
  },

  createDocumentType: function createDocumentType(qualifiedName, publicId, systemId) {
    if (!xml.isValidQName(qualifiedName)) utils.InvalidCharacterError();

    return new DocumentType(this.contextObject, qualifiedName, publicId, systemId);
  },

  createDocument: function createDocument(namespace, qualifiedName, doctype) {
    //
    // Note that the current DOMCore spec makes it impossible to
    // create an HTML document with this function, even if the
    // namespace and doctype are propertly set.  See this thread:
    // http://lists.w3.org/Archives/Public/www-dom/2011AprJun/0132.html
    //
    var d = new Document(false, null);
    var e;

    if (qualifiedName) e = d.createElementNS(namespace, qualifiedName);else e = null;

    if (doctype) {
      d.appendChild(doctype);
    }

    if (e) d.appendChild(e);
    if (namespace === utils.NAMESPACE.HTML) {
      d._contentType = 'application/xhtml+xml';
    } else if (namespace === utils.NAMESPACE.SVG) {
      d._contentType = 'image/svg+xml';
    } else {
      d._contentType = 'application/xml';
    }

    return d;
  },

  createHTMLDocument: function createHTMLDocument(titleText) {
    var d = new Document(true, null);
    d.appendChild(new DocumentType(d, 'html'));
    var html = d.createElement('html');
    d.appendChild(html);
    var head = d.createElement('head');
    html.appendChild(head);
    if (titleText !== undefined) {
      var title = d.createElement('title');
      head.appendChild(title);
      title.appendChild(d.createTextNode(titleText));
    }
    html.appendChild(d.createElement('body'));
    d.modclock = 1; // Start tracking modifications
    return d;
  },

  mozSetOutputMutationHandler: function mozSetOutputMutationHandler(doc, handler) {
    doc.mutationHandler = handler;
  },

  mozGetInputMutationHandler: function mozGetInputMutationHandler(doc) {
    utils.nyi();
  },

  mozHTMLParser: HTMLParser
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* jshint bitwise: false */


module.exports = CharacterData;

var Leaf = __webpack_require__(42);
var utils = __webpack_require__(1);
var ChildNode = __webpack_require__(22);
var NonDocumentTypeChildNode = __webpack_require__(39);

function CharacterData() {
  Leaf.call(this);
}

CharacterData.prototype = Object.create(Leaf.prototype, {
  // DOMString substringData(unsigned long offset,
  //               unsigned long count);
  // The substringData(offset, count) method must run these steps:
  //
  //     If offset is greater than the context object's
  //     length, throw an INDEX_SIZE_ERR exception and
  //     terminate these steps.
  //
  //     If offset+count is greater than the context
  //     object's length, return a DOMString whose value is
  //     the UTF-16 code units from the offsetth UTF-16 code
  //     unit to the end of data.
  //
  //     Return a DOMString whose value is the UTF-16 code
  //     units from the offsetth UTF-16 code unit to the
  //     offset+countth UTF-16 code unit in data.
  substringData: { value: function substringData(offset, count) {
      if (arguments.length < 2) {
        throw new TypeError("Not enough arguments");
      }
      // Convert arguments to WebIDL "unsigned long"
      offset = offset >>> 0;
      count = count >>> 0;
      if (offset > this.data.length || offset < 0 || count < 0) {
        utils.IndexSizeError();
      }
      return this.data.substring(offset, offset + count);
    } },

  // void appendData(DOMString data);
  // The appendData(data) method must append data to the context
  // object's data.
  appendData: { value: function appendData(data) {
      if (arguments.length < 1) {
        throw new TypeError("Not enough arguments");
      }
      this.data += String(data);
    } },

  // void insertData(unsigned long offset, DOMString data);
  // The insertData(offset, data) method must run these steps:
  //
  //     If offset is greater than the context object's
  //     length, throw an INDEX_SIZE_ERR exception and
  //     terminate these steps.
  //
  //     Insert data into the context object's data after
  //     offset UTF-16 code units.
  //
  insertData: { value: function insertData(offset, data) {
      return this.replaceData(offset, 0, data);
    } },

  // void deleteData(unsigned long offset, unsigned long count);
  // The deleteData(offset, count) method must run these steps:
  //
  //     If offset is greater than the context object's
  //     length, throw an INDEX_SIZE_ERR exception and
  //     terminate these steps.
  //
  //     If offset+count is greater than the context
  //     object's length var count be length-offset.
  //
  //     Starting from offset UTF-16 code units remove count
  //     UTF-16 code units from the context object's data.
  deleteData: { value: function deleteData(offset, count) {
      return this.replaceData(offset, count, '');
    } },

  // void replaceData(unsigned long offset, unsigned long count,
  //          DOMString data);
  //
  // The replaceData(offset, count, data) method must act as
  // if the deleteData() method is invoked with offset and
  // count as arguments followed by the insertData() method
  // with offset and data as arguments and re-throw any
  // exceptions these methods might have thrown.
  replaceData: { value: function replaceData(offset, count, data) {
      var curtext = this.data,
          len = curtext.length;
      // Convert arguments to correct WebIDL type
      offset = offset >>> 0;
      count = count >>> 0;
      data = String(data);

      if (offset > len || offset < 0) utils.IndexSizeError();

      if (offset + count > len) count = len - offset;

      var prefix = curtext.substring(0, offset),
          suffix = curtext.substring(offset + count);

      this.data = prefix + data + suffix;
    } },

  // Utility method that Node.isEqualNode() calls to test Text and
  // Comment nodes for equality.  It is okay to put it here, since
  // Node will have already verified that nodeType is equal
  isEqual: { value: function isEqual(n) {
      return this._data === n._data;
    } },

  length: { get: function get() {
      return this.data.length;
    } }

});

Object.defineProperties(CharacterData.prototype, ChildNode);
Object.defineProperties(CharacterData.prototype, NonDocumentTypeChildNode);

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var NodeFilter = {
  // Constants for acceptNode()
  FILTER_ACCEPT: 1,
  FILTER_REJECT: 2,
  FILTER_SKIP: 3,

  // Constants for whatToShow
  SHOW_ALL: 0xFFFFFFFF,
  SHOW_ELEMENT: 0x1,
  SHOW_ATTRIBUTE: 0x2, // historical
  SHOW_TEXT: 0x4,
  SHOW_CDATA_SECTION: 0x8, // historical
  SHOW_ENTITY_REFERENCE: 0x10, // historical
  SHOW_ENTITY: 0x20, // historical
  SHOW_PROCESSING_INSTRUCTION: 0x40,
  SHOW_COMMENT: 0x80,
  SHOW_DOCUMENT: 0x100,
  SHOW_DOCUMENT_TYPE: 0x200,
  SHOW_DOCUMENT_FRAGMENT: 0x400,
  SHOW_NOTATION: 0x800 // historical
};

module.exports = NodeFilter.constructor = NodeFilter.prototype = NodeFilter;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(146);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var stream = weex.requireModule('stream');
var storage = weex.requireModule('storage');
var modal = weex.requireModule('modal');
var animation = weex.requireModule('animation');

exports.default = {
    request: function request(method, url, type, body, headers) {
        return new Promise(function (resolve, reject) {
            stream.fetch({
                method: method,
                url: url,
                body: body,
                type: type,
                headers: headers
            }, function (event) {
                if (event.ok) {
                    resolve(event.data);
                } else {
                    reject(event.status);
                }
            }, function () {});
        });
    },
    fetch: function fetch(method, url, headers) {
        return new Promise(function (resolve) {
            stream.sendHttp({
                method: "GET",
                url: url,
                header: headers
            }, function (e) {
                resolve(e);
            });
        });
    },
    getQueryVariable: function getQueryVariable(url, variable) {
        var urlParams = url.split("?")[1];
        //或者url.search获取参数字符串
        var paramArray = urlParams.split("&");
        var len = paramArray.length;
        var paramObj = {}; //json对象
        var arr = []; //数组对象
        for (var i = 0; i < len; i++) {
            arr = paramArray[i].split("=");
            paramObj[arr[0]] = arr[1];
        }
        for (var key in paramObj) {
            if (key === variable) {
                return paramObj[variable];
            }
        }
    },
    setValue: function setValue(key, value) {
        return new Promise(function (resolve) {
            storage.setItem(key, value, function () {
                resolve();
            });
        });
    },
    getValue: function getValue(key) {
        return new Promise(function (resolve) {
            storage.getItem(key, function (e) {
                resolve(e.result === 'success' ? e.data : null);
            });
        });
    },
    debug: function debug(text) {
        modal.alert({
            message: text
        });
    },
    animate: function animate(vnode, options) {
        return new Promise(function (resolve) {
            animation.transition(vnode, options, function () {
                resolve();
            });
        });
    }
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Document;

var Node = __webpack_require__(2);
var NodeList = __webpack_require__(6);
var ContainerNode = __webpack_require__(19);
var Element = __webpack_require__(9);
var Text = __webpack_require__(41);
var Comment = __webpack_require__(43);
var Event = __webpack_require__(8);
var DocumentFragment = __webpack_require__(44);
var ProcessingInstruction = __webpack_require__(45);
var DOMImplementation = __webpack_require__(11);
var TreeWalker = __webpack_require__(75);
var NodeIterator = __webpack_require__(76);
var NodeFilter = __webpack_require__(13);
var URL = __webpack_require__(23);
var select = __webpack_require__(21);
var events = __webpack_require__(47);
var xml = __webpack_require__(20);
var html = __webpack_require__(24);
var svg = __webpack_require__(52);
var utils = __webpack_require__(1);
var MUTATE = __webpack_require__(82);
var NAMESPACE = utils.NAMESPACE;
var isApiWritable = __webpack_require__(18).isApiWritable;

function Document(isHTML, address) {
  ContainerNode.call(this);
  this.nodeType = Node.DOCUMENT_NODE;
  this.isHTML = isHTML;
  this._address = address || 'about:blank';
  this.readyState = 'loading';
  this.implementation = new DOMImplementation(this);

  // DOMCore says that documents are always associated with themselves
  this.ownerDocument = null; // ... but W3C tests expect null
  this._contentType = isHTML ? 'text/html' : 'application/xml';

  // These will be initialized by our custom versions of
  // appendChild and insertBefore that override the inherited
  // Node methods.
  // XXX: override those methods!
  this.doctype = null;
  this.documentElement = null;

  // "Associated inert template document"
  this._templateDocCache = null;
  // List of active NodeIterators, see NodeIterator#_preremove()
  this._nodeIterators = null;

  // Documents are always rooted, by definition
  this._nid = 1;
  this._nextnid = 2; // For numbering children of the document
  this._nodes = [null, this]; // nid to node map

  // This maintains the mapping from element ids to element nodes.
  // We may need to update this mapping every time a node is rooted
  // or uprooted, and any time an attribute is added, removed or changed
  // on a rooted element.
  this.byId = Object.create(null);

  // This property holds a monotonically increasing value akin to
  // a timestamp used to record the last modification time of nodes
  // and their subtrees. See the lastModTime attribute and modify()
  // method of the Node class. And see FilteredElementList for an example
  // of the use of lastModTime
  this.modclock = 0;
}

// Map from lowercase event category names (used as arguments to
// createEvent()) to the property name in the impl object of the
// event constructor.
var supportedEvents = {
  event: 'Event',
  customevent: 'CustomEvent',
  uievent: 'UIEvent',
  mouseevent: 'MouseEvent'
};

// Certain arguments to document.createEvent() must be treated specially
var replacementEvent = {
  events: 'event',
  htmlevents: 'event',
  mouseevents: 'mouseevent',
  mutationevents: 'mutationevent',
  uievents: 'uievent'
};

var mirrorAttr = function mirrorAttr(f, name, defaultValue) {
  return {
    get: function get() {
      var o = f.call(this);
      if (o) {
        return o[name];
      }
      return defaultValue;
    },
    set: function set(value) {
      var o = f.call(this);
      if (o) {
        o[name] = value;
      }
    }
  };
};

/** @spec https://dom.spec.whatwg.org/#validate-and-extract */
function validateAndExtract(namespace, qualifiedName) {
  var prefix, localName, pos;
  if (namespace === '') {
    namespace = null;
  }
  // See https://github.com/whatwg/dom/issues/671
  // and https://github.com/whatwg/dom/issues/319
  if (!xml.isValidQName(qualifiedName)) {
    utils.InvalidCharacterError();
  }
  prefix = null;
  localName = qualifiedName;

  pos = qualifiedName.indexOf(':');
  if (pos >= 0) {
    prefix = qualifiedName.substring(0, pos);
    localName = qualifiedName.substring(pos + 1);
  }
  if (prefix !== null && namespace === null) {
    utils.NamespaceError();
  }
  if (prefix === 'xml' && namespace !== NAMESPACE.XML) {
    utils.NamespaceError();
  }
  if ((prefix === 'xmlns' || qualifiedName === 'xmlns') && namespace !== NAMESPACE.XMLNS) {
    utils.NamespaceError();
  }
  if (namespace === NAMESPACE.XMLNS && !(prefix === 'xmlns' || qualifiedName === 'xmlns')) {
    utils.NamespaceError();
  }
  return { namespace: namespace, prefix: prefix, localName: localName };
}

Document.prototype = Object.create(ContainerNode.prototype, {
  // This method allows dom.js to communicate with a renderer
  // that displays the document in some way
  // XXX: I should probably move this to the window object
  _setMutationHandler: { value: function value(handler) {
      this.mutationHandler = handler;
    } },

  // This method allows dom.js to receive event notifications
  // from the renderer.
  // XXX: I should probably move this to the window object
  _dispatchRendererEvent: { value: function value(targetNid, type, details) {
      var target = this._nodes[targetNid];
      if (!target) return;
      target._dispatchEvent(new Event(type, details), true);
    } },

  nodeName: { value: '#document' },
  nodeValue: {
    get: function get() {
      return null;
    },
    set: function set() {}
  },

  // XXX: DOMCore may remove documentURI, so it is NYI for now
  documentURI: { get: function get() {
      return this._address;
    }, set: utils.nyi },
  compatMode: { get: function get() {
      // The _quirks property is set by the HTML parser
      return this._quirks ? 'BackCompat' : 'CSS1Compat';
    } },

  createTextNode: { value: function value(data) {
      return new Text(this, String(data));
    } },
  createComment: { value: function value(data) {
      return new Comment(this, data);
    } },
  createDocumentFragment: { value: function value() {
      return new DocumentFragment(this);
    } },
  createProcessingInstruction: { value: function value(target, data) {
      if (!xml.isValidName(target) || data.indexOf('?>') !== -1) utils.InvalidCharacterError();
      return new ProcessingInstruction(this, target, data);
    } },

  createAttribute: { value: function value(localName) {
      localName = String(localName);
      if (!xml.isValidName(localName)) utils.InvalidCharacterError();
      if (this.isHTML) {
        localName = utils.toASCIILowerCase(localName);
      }
      return new Element._Attr(null, localName, null, null, '');
    } },
  createAttributeNS: { value: function value(namespace, qualifiedName) {
      // Convert parameter types according to WebIDL
      namespace = namespace === null || namespace === undefined || namespace === '' ? null : String(namespace);
      qualifiedName = String(qualifiedName);
      var ve = validateAndExtract(namespace, qualifiedName);
      return new Element._Attr(null, ve.localName, ve.prefix, ve.namespace, '');
    } },

  createElement: { value: function value(localName) {
      localName = String(localName);
      if (!xml.isValidName(localName)) utils.InvalidCharacterError();
      // Per spec, namespace should be HTML namespace if "context object is
      // an HTML document or context object's content type is
      // "application/xhtml+xml", and null otherwise.
      if (this.isHTML) {
        if (/[A-Z]/.test(localName)) localName = utils.toASCIILowerCase(localName);
        return html.createElement(this, localName, null);
      } else if (this.contentType === 'application/xhtml+xml') {
        return html.createElement(this, localName, null);
      } else {
        return new Element(this, localName, null, null);
      }
    }, writable: isApiWritable },

  createElementNS: { value: function value(namespace, qualifiedName) {
      // Convert parameter types according to WebIDL
      namespace = namespace === null || namespace === undefined || namespace === '' ? null : String(namespace);
      qualifiedName = String(qualifiedName);
      var ve = validateAndExtract(namespace, qualifiedName);
      return this._createElementNS(ve.localName, ve.namespace, ve.prefix);
    }, writable: isApiWritable },

  // This is used directly by HTML parser, which allows it to create
  // elements with localNames containing ':' and non-default namespaces
  _createElementNS: { value: function value(localName, namespace, prefix) {
      if (namespace === NAMESPACE.HTML) {
        return html.createElement(this, localName, prefix);
      } else if (namespace === NAMESPACE.SVG) {
        return svg.createElement(this, localName, prefix);
      }

      return new Element(this, localName, namespace, prefix);
    } },

  createEvent: { value: function createEvent(interfaceName) {
      interfaceName = interfaceName.toLowerCase();
      var name = replacementEvent[interfaceName] || interfaceName;
      var constructor = events[supportedEvents[name]];

      if (constructor) {
        var e = new constructor();
        e._initialized = false;
        return e;
      } else {
        utils.NotSupportedError();
      }
    } },

  // See: http://www.w3.org/TR/dom/#dom-document-createtreewalker
  createTreeWalker: { value: function value(root, whatToShow, filter) {
      if (!root) {
        throw new TypeError("root argument is required");
      }
      if (!(root instanceof Node)) {
        throw new TypeError("root not a node");
      }
      whatToShow = whatToShow === undefined ? NodeFilter.SHOW_ALL : +whatToShow;
      filter = filter === undefined ? null : filter;

      return new TreeWalker(root, whatToShow, filter);
    } },

  // See: http://www.w3.org/TR/dom/#dom-document-createnodeiterator
  createNodeIterator: { value: function value(root, whatToShow, filter) {
      if (!root) {
        throw new TypeError("root argument is required");
      }
      if (!(root instanceof Node)) {
        throw new TypeError("root not a node");
      }
      whatToShow = whatToShow === undefined ? NodeFilter.SHOW_ALL : +whatToShow;
      filter = filter === undefined ? null : filter;

      return new NodeIterator(root, whatToShow, filter);
    } },

  _attachNodeIterator: { value: function value(ni) {
      // XXX ideally this should be a weak reference from Document to NodeIterator
      if (!this._nodeIterators) {
        this._nodeIterators = [];
      }
      this._nodeIterators.push(ni);
    } },

  _detachNodeIterator: { value: function value(ni) {
      // ni should always be in list of node iterators
      var idx = this._nodeIterators.indexOf(ni);
      this._nodeIterators.splice(idx, 1);
    } },

  _preremoveNodeIterators: { value: function value(toBeRemoved) {
      if (this._nodeIterators) {
        this._nodeIterators.forEach(function (ni) {
          ni._preremove(toBeRemoved);
        });
      }
    } },

  // Maintain the documentElement and
  // doctype properties of the document.  Each of the following
  // methods chains to the Node implementation of the method
  // to do the actual inserting, removal or replacement.

  _updateDocTypeElement: { value: function _updateDocTypeElement() {
      this.doctype = this.documentElement = null;
      for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
        if (kid.nodeType === Node.DOCUMENT_TYPE_NODE) this.doctype = kid;else if (kid.nodeType === Node.ELEMENT_NODE) this.documentElement = kid;
      }
    } },

  insertBefore: { value: function insertBefore(child, refChild) {
      Node.prototype.insertBefore.call(this, child, refChild);
      this._updateDocTypeElement();
      return child;
    } },

  replaceChild: { value: function replaceChild(node, child) {
      Node.prototype.replaceChild.call(this, node, child);
      this._updateDocTypeElement();
      return child;
    } },

  removeChild: { value: function removeChild(child) {
      Node.prototype.removeChild.call(this, child);
      this._updateDocTypeElement();
      return child;
    } },

  getElementById: { value: function value(id) {
      var n = this.byId[id];
      if (!n) return null;
      if (n instanceof MultiId) {
        // there was more than one element with this id
        return n.getFirst();
      }
      return n;
    } },

  _hasMultipleElementsWithId: { value: function value(id) {
      // Used internally by querySelectorAll optimization
      return this.byId[id] instanceof MultiId;
    } },

  // Just copy this method from the Element prototype
  getElementsByName: { value: Element.prototype.getElementsByName },
  getElementsByTagName: { value: Element.prototype.getElementsByTagName },
  getElementsByTagNameNS: { value: Element.prototype.getElementsByTagNameNS },
  getElementsByClassName: { value: Element.prototype.getElementsByClassName },

  adoptNode: { value: function adoptNode(node) {
      if (node.nodeType === Node.DOCUMENT_NODE) utils.NotSupportedError();
      if (node.nodeType === Node.ATTRIBUTE_NODE) {
        return node;
      }

      if (node.parentNode) node.parentNode.removeChild(node);

      if (node.ownerDocument !== this) recursivelySetOwner(node, this);

      return node;
    } },

  importNode: { value: function importNode(node, deep) {
      return this.adoptNode(node.cloneNode(deep));
    }, writable: isApiWritable },

  // The following attributes and methods are from the HTML spec
  origin: { get: function origin() {
      return null;
    } },
  characterSet: { get: function characterSet() {
      return "UTF-8";
    } },
  contentType: { get: function contentType() {
      return this._contentType;
    } },
  URL: { get: function URL() {
      return this._address;
    } },
  domain: { get: utils.nyi, set: utils.nyi },
  referrer: { get: utils.nyi },
  cookie: { get: utils.nyi, set: utils.nyi },
  lastModified: { get: utils.nyi },
  location: {
    get: function get() {
      return this.defaultView ? this.defaultView.location : null; // gh #75
    },
    set: utils.nyi
  },
  _titleElement: {
    get: function get() {
      // The title element of a document is the first title element in the
      // document in tree order, if there is one, or null otherwise.
      return this.getElementsByTagName('title').item(0) || null;
    }
  },
  title: {
    get: function get() {
      var elt = this._titleElement;
      // The child text content of the title element, or '' if null.
      var value = elt ? elt.textContent : '';
      // Strip and collapse whitespace in value
      return value.replace(/[ \t\n\r\f]+/g, ' ').replace(/(^ )|( $)/g, '');
    },
    set: function set(value) {
      var elt = this._titleElement;
      var head = this.head;
      if (!elt && !head) {
        return; /* according to spec */
      }
      if (!elt) {
        elt = this.createElement('title');
        head.appendChild(elt);
      }
      elt.textContent = value;
    }
  },
  dir: mirrorAttr(function () {
    var htmlElement = this.documentElement;
    if (htmlElement && htmlElement.tagName === 'HTML') {
      return htmlElement;
    }
  }, 'dir', ''),
  fgColor: mirrorAttr(function () {
    return this.body;
  }, 'text', ''),
  linkColor: mirrorAttr(function () {
    return this.body;
  }, 'link', ''),
  vlinkColor: mirrorAttr(function () {
    return this.body;
  }, 'vLink', ''),
  alinkColor: mirrorAttr(function () {
    return this.body;
  }, 'aLink', ''),
  bgColor: mirrorAttr(function () {
    return this.body;
  }, 'bgColor', ''),

  // Historical aliases of Document#characterSet
  charset: { get: function get() {
      return this.characterSet;
    } },
  inputEncoding: { get: function get() {
      return this.characterSet;
    } },

  scrollingElement: {
    get: function get() {
      return this._quirks ? this.body : this.documentElement;
    }
  },

  // Return the first <body> child of the document element.
  // XXX For now, setting this attribute is not implemented.
  body: {
    get: function get() {
      return namedHTMLChild(this.documentElement, 'body');
    },
    set: utils.nyi
  },
  // Return the first <head> child of the document element.
  head: { get: function get() {
      return namedHTMLChild(this.documentElement, 'head');
    } },
  images: { get: utils.nyi },
  embeds: { get: utils.nyi },
  plugins: { get: utils.nyi },
  links: { get: utils.nyi },
  forms: { get: utils.nyi },
  scripts: { get: utils.nyi },
  applets: { get: function get() {
      return [];
    } },
  activeElement: { get: function get() {
      return null;
    } },
  innerHTML: {
    get: function get() {
      return this.serialize();
    },
    set: utils.nyi
  },
  outerHTML: {
    get: function get() {
      return this.serialize();
    },
    set: utils.nyi
  },

  write: { value: function value(args) {
      if (!this.isHTML) utils.InvalidStateError();

      // XXX: still have to implement the ignore part
      if (!this._parser /* && this._ignore_destructive_writes > 0 */) return;

      if (!this._parser) {
        // XXX call document.open, etc.
      }

      var s = arguments.join('');

      // If the Document object's reload override flag is set, then
      // append the string consisting of the concatenation of all the
      // arguments to the method to the Document's reload override
      // buffer.
      // XXX: don't know what this is about.  Still have to do it

      // If there is no pending parsing-blocking script, have the
      // tokenizer process the characters that were inserted, one at a
      // time, processing resulting tokens as they are emitted, and
      // stopping when the tokenizer reaches the insertion point or when
      // the processing of the tokenizer is aborted by the tree
      // construction stage (this can happen if a script end tag token is
      // emitted by the tokenizer).

      // XXX: still have to do the above. Sounds as if we don't
      // always call parse() here.  If we're blocked, then we just
      // insert the text into the stream but don't parse it reentrantly...

      // Invoke the parser reentrantly
      this._parser.parse(s);
    } },

  writeln: { value: function writeln(args) {
      this.write(Array.prototype.join.call(arguments, '') + '\n');
    } },

  open: { value: function value() {
      this.documentElement = null;
    } },

  close: { value: function value() {
      this.readyState = 'interactive';
      this._dispatchEvent(new Event('readystatechange'), true);
      this._dispatchEvent(new Event('DOMContentLoaded'), true);
      this.readyState = 'complete';
      this._dispatchEvent(new Event('readystatechange'), true);
      if (this.defaultView) {
        this.defaultView._dispatchEvent(new Event('load'), true);
      }
    } },

  // Utility methods
  clone: { value: function clone() {
      var d = new Document(this.isHTML, this._address);
      d._quirks = this._quirks;
      d._contentType = this._contentType;
      return d;
    } },

  // We need to adopt the nodes if we do a deep clone
  cloneNode: { value: function cloneNode(deep) {
      var clone = Node.prototype.cloneNode.call(this, false);
      if (deep) {
        for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
          clone._appendChild(clone.importNode(kid, true));
        }
      }
      clone._updateDocTypeElement();
      return clone;
    } },

  isEqual: { value: function isEqual(n) {
      // Any two documents are shallowly equal.
      // Node.isEqualNode will also test the children
      return true;
    } },

  // Implementation-specific function.  Called when a text, comment,
  // or pi value changes.
  mutateValue: { value: function value(node) {
      if (this.mutationHandler) {
        this.mutationHandler({
          type: MUTATE.VALUE,
          target: node,
          data: node.data
        });
      }
    } },

  // Invoked when an attribute's value changes. Attr holds the new
  // value.  oldval is the old value.  Attribute mutations can also
  // involve changes to the prefix (and therefore the qualified name)
  mutateAttr: { value: function value(attr, oldval) {
      // Manage id->element mapping for getElementsById()
      // XXX: this special case id handling should not go here,
      // but in the attribute declaration for the id attribute
      /*
      if (attr.localName === 'id' && attr.namespaceURI === null) {
        if (oldval) delId(oldval, attr.ownerElement);
        addId(attr.value, attr.ownerElement);
      }
      */
      if (this.mutationHandler) {
        this.mutationHandler({
          type: MUTATE.ATTR,
          target: attr.ownerElement,
          attr: attr
        });
      }
    } },

  // Used by removeAttribute and removeAttributeNS for attributes.
  mutateRemoveAttr: { value: function value(attr) {
      /*
      * This is now handled in Attributes.js
          // Manage id to element mapping
          if (attr.localName === 'id' && attr.namespaceURI === null) {
            this.delId(attr.value, attr.ownerElement);
          }
      */
      if (this.mutationHandler) {
        this.mutationHandler({
          type: MUTATE.REMOVE_ATTR,
          target: attr.ownerElement,
          attr: attr
        });
      }
    } },

  // Called by Node.removeChild, etc. to remove a rooted element from
  // the tree. Only needs to generate a single mutation event when a
  // node is removed, but must recursively mark all descendants as not
  // rooted.
  mutateRemove: { value: function value(node) {
      // Send a single mutation event
      if (this.mutationHandler) {
        this.mutationHandler({
          type: MUTATE.REMOVE,
          target: node.parentNode,
          node: node
        });
      }

      // Mark this and all descendants as not rooted
      recursivelyUproot(node);
    } },

  // Called when a new element becomes rooted.  It must recursively
  // generate mutation events for each of the children, and mark them all
  // as rooted.
  mutateInsert: { value: function value(node) {
      // Mark node and its descendants as rooted
      recursivelyRoot(node);

      // Send a single mutation event
      if (this.mutationHandler) {
        this.mutationHandler({
          type: MUTATE.INSERT,
          target: node.parentNode,
          node: node
        });
      }
    } },

  // Called when a rooted element is moved within the document
  mutateMove: { value: function value(node) {
      if (this.mutationHandler) {
        this.mutationHandler({
          type: MUTATE.MOVE,
          target: node
        });
      }
    } },

  // Add a mapping from  id to n for n.ownerDocument
  addId: { value: function addId(id, n) {
      var val = this.byId[id];
      if (!val) {
        this.byId[id] = n;
      } else {
        // TODO: Add a way to opt-out console warnings
        //console.warn('Duplicate element id ' + id);
        if (!(val instanceof MultiId)) {
          val = new MultiId(val);
          this.byId[id] = val;
        }
        val.add(n);
      }
    } },

  // Delete the mapping from id to n for n.ownerDocument
  delId: { value: function delId(id, n) {
      var val = this.byId[id];
      utils.assert(val);

      if (val instanceof MultiId) {
        val.del(n);
        if (val.length === 1) {
          // convert back to a single node
          this.byId[id] = val.downgrade();
        }
      } else {
        this.byId[id] = undefined;
      }
    } },

  _resolve: { value: function value(href) {
      //XXX: Cache the URL
      return new URL(this._documentBaseURL).resolve(href);
    } },

  _documentBaseURL: { get: function get() {
      // XXX: This is not implemented correctly yet
      var url = this._address;
      if (url === 'about:blank') url = '/';

      var base = this.querySelector('base[href]');
      if (base) {
        return new URL(url).resolve(base.getAttribute('href'));
      }
      return url;

      // The document base URL of a Document object is the
      // absolute URL obtained by running these substeps:

      //     Let fallback base url be the document's address.

      //     If fallback base url is about:blank, and the
      //     Document's browsing context has a creator browsing
      //     context, then let fallback base url be the document
      //     base URL of the creator Document instead.

      //     If the Document is an iframe srcdoc document, then
      //     let fallback base url be the document base URL of
      //     the Document's browsing context's browsing context
      //     container's Document instead.

      //     If there is no base element that has an href
      //     attribute, then the document base URL is fallback
      //     base url; abort these steps. Otherwise, let url be
      //     the value of the href attribute of the first such
      //     element.

      //     Resolve url relative to fallback base url (thus,
      //     the base href attribute isn't affected by xml:base
      //     attributes).

      //     The document base URL is the result of the previous
      //     step if it was successful; otherwise it is fallback
      //     base url.
    } },

  _templateDoc: { get: function get() {
      if (!this._templateDocCache) {
        // "associated inert template document"
        var newDoc = new Document(this.isHTML, this._address);
        this._templateDocCache = newDoc._templateDocCache = newDoc;
      }
      return this._templateDocCache;
    } },

  querySelector: { value: function value(selector) {
      return select(selector, this)[0];
    } },

  querySelectorAll: { value: function value(selector) {
      var nodes = select(selector, this);
      return nodes.item ? nodes : new NodeList(nodes);
    } }

});

var eventHandlerTypes = ['abort', 'canplay', 'canplaythrough', 'change', 'click', 'contextmenu', 'cuechange', 'dblclick', 'drag', 'dragend', 'dragenter', 'dragleave', 'dragover', 'dragstart', 'drop', 'durationchange', 'emptied', 'ended', 'input', 'invalid', 'keydown', 'keypress', 'keyup', 'loadeddata', 'loadedmetadata', 'loadstart', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'mousewheel', 'pause', 'play', 'playing', 'progress', 'ratechange', 'readystatechange', 'reset', 'seeked', 'seeking', 'select', 'show', 'stalled', 'submit', 'suspend', 'timeupdate', 'volumechange', 'waiting', 'blur', 'error', 'focus', 'load', 'scroll'];

// Add event handler idl attribute getters and setters to Document
eventHandlerTypes.forEach(function (type) {
  // Define the event handler registration IDL attribute for this type
  Object.defineProperty(Document.prototype, 'on' + type, {
    get: function get() {
      return this._getEventHandler(type);
    },
    set: function set(v) {
      this._setEventHandler(type, v);
    }
  });
});

function namedHTMLChild(parent, name) {
  if (parent && parent.isHTML) {
    for (var kid = parent.firstChild; kid !== null; kid = kid.nextSibling) {
      if (kid.nodeType === Node.ELEMENT_NODE && kid.localName === name && kid.namespaceURI === NAMESPACE.HTML) {
        return kid;
      }
    }
  }
  return null;
}

function root(n) {
  n._nid = n.ownerDocument._nextnid++;
  n.ownerDocument._nodes[n._nid] = n;
  // Manage id to element mapping
  if (n.nodeType === Node.ELEMENT_NODE) {
    var id = n.getAttribute('id');
    if (id) n.ownerDocument.addId(id, n);

    // Script elements need to know when they're inserted
    // into the document
    if (n._roothook) n._roothook();
  }
}

function uproot(n) {
  // Manage id to element mapping
  if (n.nodeType === Node.ELEMENT_NODE) {
    var id = n.getAttribute('id');
    if (id) n.ownerDocument.delId(id, n);
  }
  n.ownerDocument._nodes[n._nid] = undefined;
  n._nid = undefined;
}

function recursivelyRoot(node) {
  root(node);
  // XXX:
  // accessing childNodes on a leaf node creates a new array the
  // first time, so be careful to write this loop so that it
  // doesn't do that. node is polymorphic, so maybe this is hard to
  // optimize?  Try switching on nodeType?
  /*
    if (node.hasChildNodes()) {
      var kids = node.childNodes;
      for(var i = 0, n = kids.length;  i < n; i++)
        recursivelyRoot(kids[i]);
    }
  */
  if (node.nodeType === Node.ELEMENT_NODE) {
    for (var kid = node.firstChild; kid !== null; kid = kid.nextSibling) {
      recursivelyRoot(kid);
    }
  }
}

function recursivelyUproot(node) {
  uproot(node);
  for (var kid = node.firstChild; kid !== null; kid = kid.nextSibling) {
    recursivelyUproot(kid);
  }
}

function recursivelySetOwner(node, owner) {
  node.ownerDocument = owner;
  node._lastModTime = undefined; // mod times are document-based
  if (Object.prototype.hasOwnProperty.call(node, '_tagName')) {
    node._tagName = undefined; // Element subclasses might need to change case
  }
  for (var kid = node.firstChild; kid !== null; kid = kid.nextSibling) {
    recursivelySetOwner(kid, owner);
  }
}

// A class for storing multiple nodes with the same ID
function MultiId(node) {
  this.nodes = Object.create(null);
  this.nodes[node._nid] = node;
  this.length = 1;
  this.firstNode = undefined;
}

// Add a node to the list, with O(1) time
MultiId.prototype.add = function (node) {
  if (!this.nodes[node._nid]) {
    this.nodes[node._nid] = node;
    this.length++;
    this.firstNode = undefined;
  }
};

// Remove a node from the list, with O(1) time
MultiId.prototype.del = function (node) {
  if (this.nodes[node._nid]) {
    delete this.nodes[node._nid];
    this.length--;
    this.firstNode = undefined;
  }
};

// Get the first node from the list, in the document order
// Takes O(N) time in the size of the list, with a cache that is invalidated
// when the list is modified.
MultiId.prototype.getFirst = function () {
  /* jshint bitwise: false */
  if (!this.firstNode) {
    var nid;
    for (nid in this.nodes) {
      if (this.firstNode === undefined || this.firstNode.compareDocumentPosition(this.nodes[nid]) & Node.DOCUMENT_POSITION_PRECEDING) {
        this.firstNode = this.nodes[nid];
      }
    }
  }
  return this.firstNode;
};

// If there is only one node left, return it. Otherwise return "this".
MultiId.prototype.downgrade = function () {
  if (this.length === 1) {
    var nid;
    for (nid in this.nodes) {
      return this.nodes[nid];
    }
  }
  return this;
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = DOMException;

var INDEX_SIZE_ERR = 1;
var HIERARCHY_REQUEST_ERR = 3;
var WRONG_DOCUMENT_ERR = 4;
var INVALID_CHARACTER_ERR = 5;
var NO_MODIFICATION_ALLOWED_ERR = 7;
var NOT_FOUND_ERR = 8;
var NOT_SUPPORTED_ERR = 9;
var INVALID_STATE_ERR = 11;
var SYNTAX_ERR = 12;
var INVALID_MODIFICATION_ERR = 13;
var NAMESPACE_ERR = 14;
var INVALID_ACCESS_ERR = 15;
var TYPE_MISMATCH_ERR = 17;
var SECURITY_ERR = 18;
var NETWORK_ERR = 19;
var ABORT_ERR = 20;
var URL_MISMATCH_ERR = 21;
var QUOTA_EXCEEDED_ERR = 22;
var TIMEOUT_ERR = 23;
var INVALID_NODE_TYPE_ERR = 24;
var DATA_CLONE_ERR = 25;

// Code to name
var names = [null, // No error with code 0
'INDEX_SIZE_ERR', null, // historical
'HIERARCHY_REQUEST_ERR', 'WRONG_DOCUMENT_ERR', 'INVALID_CHARACTER_ERR', null, // historical
'NO_MODIFICATION_ALLOWED_ERR', 'NOT_FOUND_ERR', 'NOT_SUPPORTED_ERR', 'INUSE_ATTRIBUTE_ERR', // historical
'INVALID_STATE_ERR', 'SYNTAX_ERR', 'INVALID_MODIFICATION_ERR', 'NAMESPACE_ERR', 'INVALID_ACCESS_ERR', null, // historical
'TYPE_MISMATCH_ERR', 'SECURITY_ERR', 'NETWORK_ERR', 'ABORT_ERR', 'URL_MISMATCH_ERR', 'QUOTA_EXCEEDED_ERR', 'TIMEOUT_ERR', 'INVALID_NODE_TYPE_ERR', 'DATA_CLONE_ERR'];

// Code to message
// These strings are from the 13 May 2011 Editor's Draft of DOM Core.
// http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html
// Copyright © 2011 W3C® (MIT, ERCIM, Keio), All Rights Reserved.
// Used under the terms of the W3C Document License:
// http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231
var messages = [null, // No error with code 0
'INDEX_SIZE_ERR (1): the index is not in the allowed range', null, 'HIERARCHY_REQUEST_ERR (3): the operation would yield an incorrect nodes model', 'WRONG_DOCUMENT_ERR (4): the object is in the wrong Document, a call to importNode is required', 'INVALID_CHARACTER_ERR (5): the string contains invalid characters', null, 'NO_MODIFICATION_ALLOWED_ERR (7): the object can not be modified', 'NOT_FOUND_ERR (8): the object can not be found here', 'NOT_SUPPORTED_ERR (9): this operation is not supported', 'INUSE_ATTRIBUTE_ERR (10): setAttributeNode called on owned Attribute', 'INVALID_STATE_ERR (11): the object is in an invalid state', 'SYNTAX_ERR (12): the string did not match the expected pattern', 'INVALID_MODIFICATION_ERR (13): the object can not be modified in this way', 'NAMESPACE_ERR (14): the operation is not allowed by Namespaces in XML', 'INVALID_ACCESS_ERR (15): the object does not support the operation or argument', null, 'TYPE_MISMATCH_ERR (17): the type of the object does not match the expected type', 'SECURITY_ERR (18): the operation is insecure', 'NETWORK_ERR (19): a network error occurred', 'ABORT_ERR (20): the user aborted an operation', 'URL_MISMATCH_ERR (21): the given URL does not match another URL', 'QUOTA_EXCEEDED_ERR (22): the quota has been exceeded', 'TIMEOUT_ERR (23): a timeout occurred', 'INVALID_NODE_TYPE_ERR (24): the supplied node is invalid or has an invalid ancestor for this operation', 'DATA_CLONE_ERR (25): the object can not be cloned.'];

// Name to code
var constants = {
  INDEX_SIZE_ERR: INDEX_SIZE_ERR,
  DOMSTRING_SIZE_ERR: 2, // historical
  HIERARCHY_REQUEST_ERR: HIERARCHY_REQUEST_ERR,
  WRONG_DOCUMENT_ERR: WRONG_DOCUMENT_ERR,
  INVALID_CHARACTER_ERR: INVALID_CHARACTER_ERR,
  NO_DATA_ALLOWED_ERR: 6, // historical
  NO_MODIFICATION_ALLOWED_ERR: NO_MODIFICATION_ALLOWED_ERR,
  NOT_FOUND_ERR: NOT_FOUND_ERR,
  NOT_SUPPORTED_ERR: NOT_SUPPORTED_ERR,
  INUSE_ATTRIBUTE_ERR: 10, // historical
  INVALID_STATE_ERR: INVALID_STATE_ERR,
  SYNTAX_ERR: SYNTAX_ERR,
  INVALID_MODIFICATION_ERR: INVALID_MODIFICATION_ERR,
  NAMESPACE_ERR: NAMESPACE_ERR,
  INVALID_ACCESS_ERR: INVALID_ACCESS_ERR,
  VALIDATION_ERR: 16, // historical
  TYPE_MISMATCH_ERR: TYPE_MISMATCH_ERR,
  SECURITY_ERR: SECURITY_ERR,
  NETWORK_ERR: NETWORK_ERR,
  ABORT_ERR: ABORT_ERR,
  URL_MISMATCH_ERR: URL_MISMATCH_ERR,
  QUOTA_EXCEEDED_ERR: QUOTA_EXCEEDED_ERR,
  TIMEOUT_ERR: TIMEOUT_ERR,
  INVALID_NODE_TYPE_ERR: INVALID_NODE_TYPE_ERR,
  DATA_CLONE_ERR: DATA_CLONE_ERR
};

function DOMException(code) {
  Error.call(this);
  Error.captureStackTrace(this, this.constructor);
  this.code = code;
  this.message = messages[code];
  this.name = names[code];
}
DOMException.prototype.__proto__ = Error.prototype;

// Initialize the constants on DOMException and DOMException.prototype
for (var c in constants) {
  var v = { value: constants[c] };
  Object.defineProperty(DOMException, c, v);
  Object.defineProperty(DOMException.prototype, c, v);
}

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
 * This file defines Domino behaviour that can be externally configured.
 * To change these settings, set the relevant global property *before*
 * you call `require("domino")`.
 */

// exports.isApiWritable = !weex.__domino_frozen__;
exports.isApiWritable = true;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ContainerNode;

var Node = __webpack_require__(2);
var NodeList = __webpack_require__(6);

// This class defines common functionality for node subtypes that
// can have children

function ContainerNode() {
  Node.call(this);
  this._firstChild = this._childNodes = null;
}

// Primary representation is a circular linked list of siblings
ContainerNode.prototype = Object.create(Node.prototype, {

  hasChildNodes: { value: function value() {
      if (this._childNodes) {
        return this._childNodes.length > 0;
      }
      return this._firstChild !== null;
    } },

  childNodes: { get: function get() {
      this._ensureChildNodes();
      return this._childNodes;
    } },

  firstChild: { get: function get() {
      if (this._childNodes) {
        return this._childNodes.length === 0 ? null : this._childNodes[0];
      }
      return this._firstChild;
    } },

  lastChild: { get: function get() {
      var kids = this._childNodes,
          first;
      if (kids) {
        return kids.length === 0 ? null : kids[kids.length - 1];
      }
      first = this._firstChild;
      if (first === null) {
        return null;
      }
      return first._previousSibling; // circular linked list
    } },

  _ensureChildNodes: { value: function value() {
      if (this._childNodes) {
        return;
      }
      var first = this._firstChild,
          kid = first,
          childNodes = this._childNodes = new NodeList();
      if (first) do {
        childNodes.push(kid);
        kid = kid._nextSibling;
      } while (kid !== first); // circular linked list
      this._firstChild = null; // free memory
    } },

  // Remove all of this node's children.  This is a minor
  // optimization that only calls modify() once.
  removeChildren: { value: function removeChildren() {
      var root = this.rooted ? this.ownerDocument : null,
          next = this.firstChild,
          kid;
      while (next !== null) {
        kid = next;
        next = kid.nextSibling;

        if (root) root.mutateRemove(kid);
        kid.parentNode = null;
      }
      if (this._childNodes) {
        this._childNodes.length = 0;
      } else {
        this._firstChild = null;
      }
      this.modify(); // Update last modified type once only
    } }

});

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// This grammar is from the XML and XML Namespace specs. It specifies whether
// a string (such as an element or attribute name) is a valid Name or QName.
//
// Name           ::= NameStartChar (NameChar)*
// NameStartChar  ::= ":" | [A-Z] | "_" | [a-z] |
//                    [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] |
//                    [#x370-#x37D] | [#x37F-#x1FFF] |
//                    [#x200C-#x200D] | [#x2070-#x218F] |
//                    [#x2C00-#x2FEF] | [#x3001-#xD7FF] |
//                    [#xF900-#xFDCF] | [#xFDF0-#xFFFD] |
//                    [#x10000-#xEFFFF]
//
// NameChar       ::= NameStartChar | "-" | "." | [0-9] |
//                    #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
//
// QName          ::= PrefixedName| UnprefixedName
// PrefixedName   ::= Prefix ':' LocalPart
// UnprefixedName ::= LocalPart
// Prefix         ::= NCName
// LocalPart      ::= NCName
// NCName         ::= Name - (Char* ':' Char*)
//                    # An XML Name, minus the ":"
//

exports.isValidName = isValidName;
exports.isValidQName = isValidQName;

// Most names will be ASCII only. Try matching against simple regexps first
var simplename = /^[_:A-Za-z][-.:\w]+$/;
var simpleqname = /^([_A-Za-z][-.\w]+|[_A-Za-z][-.\w]+:[_A-Za-z][-.\w]+)$/;

// If the regular expressions above fail, try more complex ones that work
// for any identifiers using codepoints from the Unicode BMP
var ncnamestartchars = "_A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
var ncnamechars = "-._A-Za-z0-9\xB7\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0300-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";

var ncname = "[" + ncnamestartchars + "][" + ncnamechars + "]*";
var namestartchars = ncnamestartchars + ":";
var namechars = ncnamechars + ":";
var name = new RegExp("^[" + namestartchars + "]" + "[" + namechars + "]*$");
var qname = new RegExp("^(" + ncname + "|" + ncname + ":" + ncname + ")$");

// XML says that these characters are also legal:
// [#x10000-#xEFFFF].  So if the patterns above fail, and the
// target string includes surrogates, then try the following
// patterns that allow surrogates and then run an extra validation
// step to make sure that the surrogates are in valid pairs and in
// the right range.  Note that since the characters \uf0000 to \u1f0000
// are not allowed, it means that the high surrogate can only go up to
// \uDB7f instead of \uDBFF.
var hassurrogates = /[\uD800-\uDB7F\uDC00-\uDFFF]/;
var surrogatechars = /[\uD800-\uDB7F\uDC00-\uDFFF]/g;
var surrogatepairs = /[\uD800-\uDB7F][\uDC00-\uDFFF]/g;

// Modify the variables above to allow surrogates
ncnamestartchars += "\uD800-\uDB7F\uDC00-\uDFFF";
ncnamechars += "\uD800-\uDB7F\uDC00-\uDFFF";
ncname = "[" + ncnamestartchars + "][" + ncnamechars + "]*";
namestartchars = ncnamestartchars + ":";
namechars = ncnamechars + ":";

// Build another set of regexps that include surrogates
var surrogatename = new RegExp("^[" + namestartchars + "]" + "[" + namechars + "]*$");
var surrogateqname = new RegExp("^(" + ncname + "|" + ncname + ":" + ncname + ")$");

function isValidName(s) {
  if (simplename.test(s)) return true; // Plain ASCII
  if (name.test(s)) return true; // Unicode BMP

  // Maybe the tests above failed because s includes surrogate pairs
  // Most likely, though, they failed for some more basic syntax problem
  if (!hassurrogates.test(s)) return false;

  // Is the string a valid name if we allow surrogates?
  if (!surrogatename.test(s)) return false;

  // Finally, are the surrogates all correctly paired up?
  var chars = s.match(surrogatechars),
      pairs = s.match(surrogatepairs);
  return pairs !== null && 2 * pairs.length === chars.length;
}

function isValidQName(s) {
  if (simpleqname.test(s)) return true; // Plain ASCII
  if (qname.test(s)) return true; // Unicode BMP

  if (!hassurrogates.test(s)) return false;
  if (!surrogateqname.test(s)) return false;
  var chars = s.match(surrogatechars),
      pairs = s.match(surrogatepairs);
  return pairs !== null && 2 * pairs.length === chars.length;
}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* jshint eqnull: true */
/**
 * Zest (https://github.com/chjj/zest)
 * A css selector engine.
 * Copyright (c) 2011-2012, Christopher Jeffrey. (MIT Licensed)
 * Domino version based on Zest v0.1.3 with bugfixes applied.
 */

/**
 * Helpers
 */

var window = Object.create(null, {
  location: { get: function get() {
      throw new Error('window.location is not supported.');
    } }
});

var compareDocumentPosition = function compareDocumentPosition(a, b) {
  return a.compareDocumentPosition(b);
};

var order = function order(a, b) {
  /* jshint bitwise: false */
  return compareDocumentPosition(a, b) & 2 ? 1 : -1;
};

var next = function next(el) {
  while ((el = el.nextSibling) && el.nodeType !== 1) {}
  return el;
};

var prev = function prev(el) {
  while ((el = el.previousSibling) && el.nodeType !== 1) {}
  return el;
};

var child = function child(el) {
  /*jshint -W084 */
  if (el = el.firstChild) {
    while (el.nodeType !== 1 && (el = el.nextSibling)) {}
  }
  return el;
};

var lastChild = function lastChild(el) {
  /*jshint -W084 */
  if (el = el.lastChild) {
    while (el.nodeType !== 1 && (el = el.previousSibling)) {}
  }
  return el;
};

var parentIsElement = function parentIsElement(n) {
  if (!n.parentNode) {
    return false;
  }
  var nodeType = n.parentNode.nodeType;
  // The root `html` element can be a first- or last-child, too.
  return nodeType === 1 || nodeType === 9;
};

var unquote = function unquote(str) {
  if (!str) return str;
  var ch = str[0];
  if (ch === '"' || ch === '\'') {
    if (str[str.length - 1] === ch) {
      str = str.slice(1, -1);
    } else {
      // bad string.
      str = str.slice(1);
    }
    return str.replace(rules.str_escape, function (s) {
      var m = /^\\(?:([0-9A-Fa-f]+)|([\r\n\f]+))/.exec(s);
      if (!m) {
        return s.slice(1);
      }
      if (m[2]) {
        return ''; /* escaped newlines are ignored in strings. */
      }
      var cp = parseInt(m[1], 16);
      return String.fromCodePoint ? String.fromCodePoint(cp) :
      // Not all JavaScript implementations have String.fromCodePoint yet.
      String.fromCharCode(cp);
    });
  } else if (rules.ident.test(str)) {
    return decodeid(str);
  } else {
    // NUMBER, PERCENTAGE, DIMENSION, etc
    return str;
  }
};

var decodeid = function decodeid(str) {
  return str.replace(rules.escape, function (s) {
    var m = /^\\([0-9A-Fa-f]+)/.exec(s);
    if (!m) {
      return s[1];
    }
    var cp = parseInt(m[1], 16);
    return String.fromCodePoint ? String.fromCodePoint(cp) :
    // Not all JavaScript implementations have String.fromCodePoint yet.
    String.fromCharCode(cp);
  });
};

var indexOf = function () {
  if (Array.prototype.indexOf) {
    return Array.prototype.indexOf;
  }
  return function (obj, item) {
    var i = this.length;
    while (i--) {
      if (this[i] === item) return i;
    }
    return -1;
  };
}();

var makeInside = function makeInside(start, end) {
  var regex = rules.inside.source.replace(/</g, start).replace(/>/g, end);

  return new RegExp(regex);
};

var replace = function replace(regex, name, val) {
  regex = regex.source;
  regex = regex.replace(name, val.source || val);
  return new RegExp(regex);
};

var truncateUrl = function truncateUrl(url, num) {
  return url.replace(/^(?:\w+:\/\/|\/+)/, '').replace(/(?:\/+|\/*#.*?)$/, '').split('/', num).join('/');
};

/**
 * Handle `nth` Selectors
 */

var parseNth = function parseNth(param_, test) {
  var param = param_.replace(/\s+/g, ''),
      cap;

  if (param === 'even') {
    param = '2n+0';
  } else if (param === 'odd') {
    param = '2n+1';
  } else if (param.indexOf('n') === -1) {
    param = '0n' + param;
  }

  cap = /^([+-])?(\d+)?n([+-])?(\d+)?$/.exec(param);

  return {
    group: cap[1] === '-' ? -(cap[2] || 1) : +(cap[2] || 1),
    offset: cap[4] ? cap[3] === '-' ? -cap[4] : +cap[4] : 0
  };
};

var nth = function nth(param_, test, last) {
  var param = parseNth(param_),
      group = param.group,
      offset = param.offset,
      find = !last ? child : lastChild,
      advance = !last ? next : prev;

  return function (el) {
    if (!parentIsElement(el)) return;

    var rel = find(el.parentNode),
        pos = 0;

    while (rel) {
      if (test(rel, el)) pos++;
      if (rel === el) {
        pos -= offset;
        return group && pos ? pos % group === 0 && pos < 0 === group < 0 : !pos;
      }
      rel = advance(rel);
    }
  };
};

/**
 * Simple Selectors
 */

var selectors = {
  '*': function () {
    if (false /*function() {
              var el = document.createElement('div');
              el.appendChild(document.createComment(''));
              return !!el.getElementsByTagName('*')[0];
              }()*/) {
        return function (el) {
          if (el.nodeType === 1) return true;
        };
      }
    return function () {
      return true;
    };
  }(),
  'type': function type(_type) {
    _type = _type.toLowerCase();
    return function (el) {
      return el.nodeName.toLowerCase() === _type;
    };
  },
  'attr': function attr(key, op, val, i) {
    op = operators[op];
    return function (el) {
      var attr;
      switch (key) {
        case 'for':
          attr = el.htmlFor;
          break;
        case 'class':
          // className is '' when non-existent
          // getAttribute('class') is null
          attr = el.className;
          if (attr === '' && el.getAttribute('class') == null) {
            attr = null;
          }
          break;
        case 'href':
        case 'src':
          attr = el.getAttribute(key, 2);
          break;
        case 'title':
          // getAttribute('title') can be '' when non-existent sometimes?
          attr = el.getAttribute('title') || null;
          break;
        // careful with attributes with special getter functions
        case 'id':
        case 'lang':
        case 'dir':
        case 'accessKey':
        case 'hidden':
        case 'tabIndex':
        case 'style':
          if (el.getAttribute) {
            attr = el.getAttribute(key);
            break;
          }
        /* falls through */
        default:
          if (el.hasAttribute && !el.hasAttribute(key)) {
            break;
          }
          attr = el[key] != null ? el[key] : el.getAttribute && el.getAttribute(key);
          break;
      }
      if (attr == null) return;
      attr = attr + '';
      if (i) {
        attr = attr.toLowerCase();
        val = val.toLowerCase();
      }
      return op(attr, val);
    };
  },
  ':first-child': function firstChild(el) {
    return !prev(el) && parentIsElement(el);
  },
  ':last-child': function lastChild(el) {
    return !next(el) && parentIsElement(el);
  },
  ':only-child': function onlyChild(el) {
    return !prev(el) && !next(el) && parentIsElement(el);
  },
  ':nth-child': function nthChild(param, last) {
    return nth(param, function () {
      return true;
    }, last);
  },
  ':nth-last-child': function nthLastChild(param) {
    return selectors[':nth-child'](param, true);
  },
  ':root': function root(el) {
    return el.ownerDocument.documentElement === el;
  },
  ':empty': function empty(el) {
    return !el.firstChild;
  },
  ':not': function not(sel) {
    var test = compileGroup(sel);
    return function (el) {
      return !test(el);
    };
  },
  ':first-of-type': function firstOfType(el) {
    if (!parentIsElement(el)) return;
    var type = el.nodeName;
    /*jshint -W084 */
    while (el = prev(el)) {
      if (el.nodeName === type) return;
    }
    return true;
  },
  ':last-of-type': function lastOfType(el) {
    if (!parentIsElement(el)) return;
    var type = el.nodeName;
    /*jshint -W084 */
    while (el = next(el)) {
      if (el.nodeName === type) return;
    }
    return true;
  },
  ':only-of-type': function onlyOfType(el) {
    return selectors[':first-of-type'](el) && selectors[':last-of-type'](el);
  },
  ':nth-of-type': function nthOfType(param, last) {
    return nth(param, function (rel, el) {
      return rel.nodeName === el.nodeName;
    }, last);
  },
  ':nth-last-of-type': function nthLastOfType(param) {
    return selectors[':nth-of-type'](param, true);
  },
  ':checked': function checked(el) {
    return !!(el.checked || el.selected);
  },
  ':indeterminate': function indeterminate(el) {
    return !selectors[':checked'](el);
  },
  ':enabled': function enabled(el) {
    return !el.disabled && el.type !== 'hidden';
  },
  ':disabled': function disabled(el) {
    return !!el.disabled;
  },
  ':target': function target(el) {
    return el.id === window.location.hash.substring(1);
  },
  ':focus': function focus(el) {
    return el === el.ownerDocument.activeElement;
  },
  ':is': function is(sel) {
    return compileGroup(sel);
  },
  // :matches is an older name for :is; see
  // https://github.com/w3c/csswg-drafts/issues/3258
  ':matches': function matches(sel) {
    return selectors[':is'](sel);
  },
  ':nth-match': function nthMatch(param, last) {
    var args = param.split(/\s*,\s*/),
        arg = args.shift(),
        test = compileGroup(args.join(','));

    return nth(arg, test, last);
  },
  ':nth-last-match': function nthLastMatch(param) {
    return selectors[':nth-match'](param, true);
  },
  ':links-here': function linksHere(el) {
    return el + '' === window.location + '';
  },
  ':lang': function lang(param) {
    return function (el) {
      while (el) {
        if (el.lang) return el.lang.indexOf(param) === 0;
        el = el.parentNode;
      }
    };
  },
  ':dir': function dir(param) {
    return function (el) {
      while (el) {
        if (el.dir) return el.dir === param;
        el = el.parentNode;
      }
    };
  },
  ':scope': function scope(el, con) {
    var context = con || el.ownerDocument;
    if (context.nodeType === 9) {
      return el === context.documentElement;
    }
    return el === context;
  },
  ':any-link': function anyLink(el) {
    return typeof el.href === 'string';
  },
  ':local-link': function localLink(el) {
    if (el.nodeName) {
      return el.href && el.host === window.location.host;
    }
    var param = +el + 1;
    return function (el) {
      if (!el.href) return;

      var url = window.location + '',
          href = el + '';

      return truncateUrl(url, param) === truncateUrl(href, param);
    };
  },
  ':default': function _default(el) {
    return !!el.defaultSelected;
  },
  ':valid': function valid(el) {
    return el.willValidate || el.validity && el.validity.valid;
  },
  ':invalid': function invalid(el) {
    return !selectors[':valid'](el);
  },
  ':in-range': function inRange(el) {
    return el.value > el.min && el.value <= el.max;
  },
  ':out-of-range': function outOfRange(el) {
    return !selectors[':in-range'](el);
  },
  ':required': function required(el) {
    return !!el.required;
  },
  ':optional': function optional(el) {
    return !el.required;
  },
  ':read-only': function readOnly(el) {
    if (el.readOnly) return true;

    var attr = el.getAttribute('contenteditable'),
        prop = el.contentEditable,
        name = el.nodeName.toLowerCase();

    name = name !== 'input' && name !== 'textarea';

    return (name || el.disabled) && attr == null && prop !== 'true';
  },
  ':read-write': function readWrite(el) {
    return !selectors[':read-only'](el);
  },
  ':hover': function hover() {
    throw new Error(':hover is not supported.');
  },
  ':active': function active() {
    throw new Error(':active is not supported.');
  },
  ':link': function link() {
    throw new Error(':link is not supported.');
  },
  ':visited': function visited() {
    throw new Error(':visited is not supported.');
  },
  ':column': function column() {
    throw new Error(':column is not supported.');
  },
  ':nth-column': function nthColumn() {
    throw new Error(':nth-column is not supported.');
  },
  ':nth-last-column': function nthLastColumn() {
    throw new Error(':nth-last-column is not supported.');
  },
  ':current': function current() {
    throw new Error(':current is not supported.');
  },
  ':past': function past() {
    throw new Error(':past is not supported.');
  },
  ':future': function future() {
    throw new Error(':future is not supported.');
  },
  // Non-standard, for compatibility purposes.
  ':contains': function contains(param) {
    return function (el) {
      var text = el.innerText || el.textContent || el.value || '';
      return text.indexOf(param) !== -1;
    };
  },
  ':has': function has(param) {
    return function (el) {
      return find(param, el).length > 0;
    };
  }
  // Potentially add more pseudo selectors for
  // compatibility with sizzle and most other
  // selector engines (?).
};

/**
 * Attribute Operators
 */

var operators = {
  '-': function _() {
    return true;
  },
  '=': function _(attr, val) {
    return attr === val;
  },
  '*=': function _(attr, val) {
    return attr.indexOf(val) !== -1;
  },
  '~=': function _(attr, val) {
    var i, s, f, l;

    for (s = 0; true; s = i + 1) {
      i = attr.indexOf(val, s);
      if (i === -1) return false;
      f = attr[i - 1];
      l = attr[i + val.length];
      if ((!f || f === ' ') && (!l || l === ' ')) return true;
    }
  },
  '|=': function _(attr, val) {
    var i = attr.indexOf(val),
        l;

    if (i !== 0) return;
    l = attr[i + val.length];

    return l === '-' || !l;
  },
  '^=': function _(attr, val) {
    return attr.indexOf(val) === 0;
  },
  '$=': function $(attr, val) {
    var i = attr.lastIndexOf(val);
    return i !== -1 && i + val.length === attr.length;
  },
  // non-standard
  '!=': function _(attr, val) {
    return attr !== val;
  }
};

/**
 * Combinator Logic
 */

var combinators = {
  ' ': function _(test) {
    return function (el) {
      /*jshint -W084 */
      while (el = el.parentNode) {
        if (test(el)) return el;
      }
    };
  },
  '>': function _(test) {
    return function (el) {
      /*jshint -W084 */
      if (el = el.parentNode) {
        return test(el) && el;
      }
    };
  },
  '+': function _(test) {
    return function (el) {
      /*jshint -W084 */
      if (el = prev(el)) {
        return test(el) && el;
      }
    };
  },
  '~': function _(test) {
    return function (el) {
      /*jshint -W084 */
      while (el = prev(el)) {
        if (test(el)) return el;
      }
    };
  },
  'noop': function noop(test) {
    return function (el) {
      return test(el) && el;
    };
  },
  'ref': function ref(test, name) {
    var node;

    function ref(el) {
      var doc = el.ownerDocument,
          nodes = doc.getElementsByTagName('*'),
          i = nodes.length;

      while (i--) {
        node = nodes[i];
        if (ref.test(el)) {
          node = null;
          return true;
        }
      }

      node = null;
    }

    ref.combinator = function (el) {
      if (!node || !node.getAttribute) return;

      var attr = node.getAttribute(name) || '';
      if (attr[0] === '#') attr = attr.substring(1);

      if (attr === el.id && test(node)) {
        return node;
      }
    };

    return ref;
  }
};

/**
 * Grammar
 */

var rules = {
  escape: /\\(?:[^0-9A-Fa-f\r\n]|[0-9A-Fa-f]{1,6}[\r\n\t ]?)/g,
  str_escape: /(escape)|\\(\n|\r\n?|\f)/g,
  nonascii: /[\u00A0-\uFFFF]/,
  cssid: /(?:(?!-?[0-9])(?:escape|nonascii|[-_a-zA-Z0-9])+)/,
  qname: /^ *(cssid|\*)/,
  simple: /^(?:([.#]cssid)|pseudo|attr)/,
  ref: /^ *\/(cssid)\/ */,
  combinator: /^(?: +([^ \w*.#\\]) +|( )+|([^ \w*.#\\]))(?! *$)/,
  attr: /^\[(cssid)(?:([^\w]?=)(inside))?\]/,
  pseudo: /^(:cssid)(?:\((inside)\))?/,
  inside: /(?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|<[^"'>]*>|\\["'>]|[^"'>])*/,
  ident: /^(cssid)$/
};

rules.cssid = replace(rules.cssid, 'nonascii', rules.nonascii);
rules.cssid = replace(rules.cssid, 'escape', rules.escape);
rules.qname = replace(rules.qname, 'cssid', rules.cssid);
rules.simple = replace(rules.simple, 'cssid', rules.cssid);
rules.ref = replace(rules.ref, 'cssid', rules.cssid);
rules.attr = replace(rules.attr, 'cssid', rules.cssid);
rules.pseudo = replace(rules.pseudo, 'cssid', rules.cssid);
rules.inside = replace(rules.inside, '[^"\'>]*', rules.inside);
rules.attr = replace(rules.attr, 'inside', makeInside('\\[', '\\]'));
rules.pseudo = replace(rules.pseudo, 'inside', makeInside('\\(', '\\)'));
rules.simple = replace(rules.simple, 'pseudo', rules.pseudo);
rules.simple = replace(rules.simple, 'attr', rules.attr);
rules.ident = replace(rules.ident, 'cssid', rules.cssid);
rules.str_escape = replace(rules.str_escape, 'escape', rules.escape);

/**
 * Compiling
 */

var compile = function compile(sel_) {
  var sel = sel_.replace(/^\s+|\s+$/g, ''),
      test,
      filter = [],
      buff = [],
      subject,
      qname,
      cap,
      op,
      ref;

  /*jshint -W084 */
  while (sel) {
    if (cap = rules.qname.exec(sel)) {
      sel = sel.substring(cap[0].length);
      qname = decodeid(cap[1]);
      buff.push(tok(qname, true));
    } else if (cap = rules.simple.exec(sel)) {
      sel = sel.substring(cap[0].length);
      qname = '*';
      buff.push(tok(qname, true));
      buff.push(tok(cap));
    } else {
      throw new SyntaxError('Invalid selector.');
    }

    while (cap = rules.simple.exec(sel)) {
      sel = sel.substring(cap[0].length);
      buff.push(tok(cap));
    }

    if (sel[0] === '!') {
      sel = sel.substring(1);
      subject = makeSubject();
      subject.qname = qname;
      buff.push(subject.simple);
    }

    if (cap = rules.ref.exec(sel)) {
      sel = sel.substring(cap[0].length);
      ref = combinators.ref(makeSimple(buff), decodeid(cap[1]));
      filter.push(ref.combinator);
      buff = [];
      continue;
    }

    if (cap = rules.combinator.exec(sel)) {
      sel = sel.substring(cap[0].length);
      op = cap[1] || cap[2] || cap[3];
      if (op === ',') {
        filter.push(combinators.noop(makeSimple(buff)));
        break;
      }
    } else {
      op = 'noop';
    }

    if (!combinators[op]) {
      throw new SyntaxError('Bad combinator.');
    }
    filter.push(combinators[op](makeSimple(buff)));
    buff = [];
  }

  test = makeTest(filter);
  test.qname = qname;
  test.sel = sel;

  if (subject) {
    subject.lname = test.qname;

    subject.test = test;
    subject.qname = subject.qname;
    subject.sel = test.sel;
    test = subject;
  }

  if (ref) {
    ref.test = test;
    ref.qname = test.qname;
    ref.sel = test.sel;
    test = ref;
  }

  return test;
};

var tok = function tok(cap, qname) {
  // qname
  if (qname) {
    return cap === '*' ? selectors['*'] : selectors.type(cap);
  }

  // class/id
  if (cap[1]) {
    return cap[1][0] === '.'
    // XXX unescape here?  or in attr?
    ? selectors.attr('class', '~=', decodeid(cap[1].substring(1)), false) : selectors.attr('id', '=', decodeid(cap[1].substring(1)), false);
  }

  // pseudo-name
  // inside-pseudo
  if (cap[2]) {
    return cap[3] ? selectors[decodeid(cap[2])](unquote(cap[3])) : selectors[decodeid(cap[2])];
  }

  // attr name
  // attr op
  // attr value
  if (cap[4]) {
    var value = cap[6];
    var i = /["'\s]\s*I$/i.test(value);
    if (i) {
      value = value.replace(/\s*I$/i, '');
    }
    return selectors.attr(decodeid(cap[4]), cap[5] || '-', unquote(value), i);
  }

  throw new SyntaxError('Unknown Selector.');
};

var makeSimple = function makeSimple(func) {
  var l = func.length,
      i;

  // Potentially make sure
  // `el` is truthy.
  if (l < 2) return func[0];

  return function (el) {
    if (!el) return;
    for (i = 0; i < l; i++) {
      if (!func[i](el)) return;
    }
    return true;
  };
};

var makeTest = function makeTest(func) {
  if (func.length < 2) {
    return function (el) {
      return !!func[0](el);
    };
  }
  return function (el) {
    var i = func.length;
    while (i--) {
      if (!(el = func[i](el))) return;
    }
    return true;
  };
};

var makeSubject = function makeSubject() {
  var target;

  function subject(el) {
    var node = el.ownerDocument,
        scope = node.getElementsByTagName(subject.lname),
        i = scope.length;

    while (i--) {
      if (subject.test(scope[i]) && target === el) {
        target = null;
        return true;
      }
    }

    target = null;
  }

  subject.simple = function (el) {
    target = el;
    return true;
  };

  return subject;
};

var compileGroup = function compileGroup(sel) {
  var test = compile(sel),
      tests = [test];

  while (test.sel) {
    test = compile(test.sel);
    tests.push(test);
  }

  if (tests.length < 2) return test;

  return function (el) {
    var l = tests.length,
        i = 0;

    for (; i < l; i++) {
      if (tests[i](el)) return true;
    }
  };
};

/**
 * Selection
 */

var find = function find(sel, node) {
  var results = [],
      test = compile(sel),
      scope = node.getElementsByTagName(test.qname),
      i = 0,
      el;

  /*jshint -W084 */
  while (el = scope[i++]) {
    if (test(el)) results.push(el);
  }

  if (test.sel) {
    while (test.sel) {
      test = compile(test.sel);
      scope = node.getElementsByTagName(test.qname);
      i = 0;
      /*jshint -W084 */
      while (el = scope[i++]) {
        if (test(el) && indexOf.call(results, el) === -1) {
          results.push(el);
        }
      }
    }
    results.sort(order);
  }

  return results;
};

/**
 * Expose
 */

module.exports = exports = function exports(sel, context) {
  /* when context isn't a DocumentFragment and the selector is simple: */
  var id, r;
  if (context.nodeType !== 11 && sel.indexOf(' ') === -1) {
    if (sel[0] === '#' && context.rooted && /^#[A-Z_][-A-Z0-9_]*$/i.test(sel)) {
      if (context.doc._hasMultipleElementsWithId) {
        id = sel.substring(1);
        if (!context.doc._hasMultipleElementsWithId(id)) {
          r = context.doc.getElementById(id);
          return r ? [r] : [];
        }
      }
    }
    if (sel[0] === '.' && /^\.\w+$/.test(sel)) {
      return context.getElementsByClassName(sel.substring(1));
    }
    if (/^\w+$/.test(sel)) {
      return context.getElementsByTagName(sel);
    }
  }
  /* do things the hard/slow way */
  return find(sel, context);
};

exports.selectors = selectors;
exports.operators = operators;
exports.combinators = combinators;

exports.matches = function (el, sel) {
  var test = { sel: sel };
  do {
    test = compile(test.sel);
    if (test(el)) {
      return true;
    }
  } while (test.sel);
  return false;
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Node = __webpack_require__(2);
var LinkedList = __webpack_require__(35);

var createDocumentFragmentFromArguments = function createDocumentFragmentFromArguments(document, args) {
  var docFrag = document.createDocumentFragment();

  for (var i = 0; i < args.length; i++) {
    var argItem = args[i];
    var isNode = argItem instanceof Node;
    docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
  }

  return docFrag;
};

// The ChildNode interface contains methods that are particular to `Node`
// objects that can have a parent.  It is implemented by `Element`,
// `DocumentType`, and `CharacterData` objects.
var ChildNode = {

  // Inserts a set of Node or String objects in the children list of this
  // ChildNode's parent, just after this ChildNode.  String objects are
  // inserted as the equivalent Text nodes.
  after: { value: function after() {
      var argArr = Array.prototype.slice.call(arguments);
      var parentNode = this.parentNode,
          nextSibling = this.nextSibling;
      if (parentNode === null) {
        return;
      }
      // Find "viable next sibling"; that is, next one not in argArr
      while (nextSibling && argArr.some(function (v) {
        return v === nextSibling;
      })) {
        nextSibling = nextSibling.nextSibling;
      } // ok, parent and sibling are saved away since this node could itself
      // appear in argArr and we're about to move argArr to a document fragment.
      var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);

      parentNode.insertBefore(docFrag, nextSibling);
    } },

  // Inserts a set of Node or String objects in the children list of this
  // ChildNode's parent, just before this ChildNode.  String objects are
  // inserted as the equivalent Text nodes.
  before: { value: function before() {
      var argArr = Array.prototype.slice.call(arguments);
      var parentNode = this.parentNode,
          prevSibling = this.previousSibling;
      if (parentNode === null) {
        return;
      }
      // Find "viable prev sibling"; that is, prev one not in argArr
      while (prevSibling && argArr.some(function (v) {
        return v === prevSibling;
      })) {
        prevSibling = prevSibling.previousSibling;
      } // ok, parent and sibling are saved away since this node could itself
      // appear in argArr and we're about to move argArr to a document fragment.
      var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);

      var nextSibling = prevSibling ? prevSibling.nextSibling : parentNode.firstChild;
      parentNode.insertBefore(docFrag, nextSibling);
    } },

  // Remove this node from its parent
  remove: { value: function remove() {
      if (this.parentNode === null) return;

      // Send mutation events if necessary
      if (this.doc) {
        this.doc._preremoveNodeIterators(this);
        if (this.rooted) {
          this.doc.mutateRemove(this);
        }
      }

      // Remove this node from its parents array of children
      // and update the structure id for all ancestors
      this._remove();

      // Forget this node's parent
      this.parentNode = null;
    } },

  // Remove this node w/o uprooting or sending mutation events
  // (But do update the structure id for all ancestors)
  _remove: { value: function _remove() {
      var parent = this.parentNode;
      if (parent === null) return;
      if (parent._childNodes) {
        parent._childNodes.splice(this.index, 1);
      } else if (parent._firstChild === this) {
        if (this._nextSibling === this) {
          parent._firstChild = null;
        } else {
          parent._firstChild = this._nextSibling;
        }
      }
      LinkedList.remove(this);
      parent.modify();
    } },

  // Replace this node with the nodes or strings provided as arguments.
  replaceWith: { value: function replaceWith() {
      var argArr = Array.prototype.slice.call(arguments);
      var parentNode = this.parentNode,
          nextSibling = this.nextSibling;
      if (parentNode === null) {
        return;
      }
      // Find "viable next sibling"; that is, next one not in argArr
      while (nextSibling && argArr.some(function (v) {
        return v === nextSibling;
      })) {
        nextSibling = nextSibling.nextSibling;
      } // ok, parent and sibling are saved away since this node could itself
      // appear in argArr and we're about to move argArr to a document fragment.
      var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);
      if (this.parentNode === parentNode) {
        parentNode.replaceChild(docFrag, this);
      } else {
        // `this` was inserted into docFrag
        parentNode.insertBefore(docFrag, nextSibling);
      }
    } }

};

module.exports = ChildNode;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = URL;

function URL(url) {
  if (!url) return Object.create(URL.prototype);
  // Can't use String.trim() since it defines whitespace differently than HTML
  this.url = url.replace(/^[ \t\n\r\f]+|[ \t\n\r\f]+$/g, "");

  // See http://tools.ietf.org/html/rfc3986#appendix-B
  // and https://url.spec.whatwg.org/#parsing
  var match = URL.pattern.exec(this.url);
  if (match) {
    if (match[2]) this.scheme = match[2];
    if (match[4]) {
      // parse username/password
      var userinfo = match[4].match(URL.userinfoPattern);
      if (userinfo) {
        this.username = userinfo[1];
        this.password = userinfo[3];
        match[4] = match[4].substring(userinfo[0].length);
      }
      if (match[4].match(URL.portPattern)) {
        var pos = match[4].lastIndexOf(':');
        this.host = match[4].substring(0, pos);
        this.port = match[4].substring(pos + 1);
      } else {
        this.host = match[4];
      }
    }
    if (match[5]) this.path = match[5];
    if (match[6]) this.query = match[7];
    if (match[8]) this.fragment = match[9];
  }
}

URL.pattern = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/;
URL.userinfoPattern = /^([^@:]*)(:([^@]*))?@/;
URL.portPattern = /:\d+$/;
URL.authorityPattern = /^[^:\/?#]+:\/\//;
URL.hierarchyPattern = /^[^:\/?#]+:\//;

// Return a percentEncoded version of s.
// S should be a single-character string
// XXX: needs to do utf-8 encoding?
URL.percentEncode = function percentEncode(s) {
  var c = s.charCodeAt(0);
  if (c < 256) return "%" + c.toString(16);else throw Error("can't percent-encode codepoints > 255 yet");
};

URL.prototype = {
  constructor: URL,

  // XXX: not sure if this is the precise definition of absolute
  isAbsolute: function isAbsolute() {
    return !!this.scheme;
  },
  isAuthorityBased: function isAuthorityBased() {
    return URL.authorityPattern.test(this.url);
  },
  isHierarchical: function isHierarchical() {
    return URL.hierarchyPattern.test(this.url);
  },

  toString: function toString() {
    var s = "";
    if (this.scheme !== undefined) s += this.scheme + ":";
    if (this.isAbsolute()) {
      s += '//';
      if (this.username || this.password) {
        s += this.username || '';
        if (this.password) {
          s += ':' + this.password;
        }
        s += '@';
      }
      if (this.host) {
        s += this.host;
      }
    }
    if (this.port !== undefined) s += ":" + this.port;
    if (this.path !== undefined) s += this.path;
    if (this.query !== undefined) s += "?" + this.query;
    if (this.fragment !== undefined) s += "#" + this.fragment;
    return s;
  },

  // See: http://tools.ietf.org/html/rfc3986#section-5.2
  // and https://url.spec.whatwg.org/#constructors
  resolve: function resolve(relative) {
    var base = this; // The base url we're resolving against
    var r = new URL(relative); // The relative reference url to resolve
    var t = new URL(); // The absolute target url we will return

    if (r.scheme !== undefined) {
      t.scheme = r.scheme;
      t.username = r.username;
      t.password = r.password;
      t.host = r.host;
      t.port = r.port;
      t.path = remove_dot_segments(r.path);
      t.query = r.query;
    } else {
      t.scheme = base.scheme;
      if (r.host !== undefined) {
        t.username = r.username;
        t.password = r.password;
        t.host = r.host;
        t.port = r.port;
        t.path = remove_dot_segments(r.path);
        t.query = r.query;
      } else {
        t.username = base.username;
        t.password = base.password;
        t.host = base.host;
        t.port = base.port;
        if (!r.path) {
          // undefined or empty
          t.path = base.path;
          if (r.query !== undefined) t.query = r.query;else t.query = base.query;
        } else {
          if (r.path.charAt(0) === "/") {
            t.path = remove_dot_segments(r.path);
          } else {
            t.path = merge(base.path, r.path);
            t.path = remove_dot_segments(t.path);
          }
          t.query = r.query;
        }
      }
    }
    t.fragment = r.fragment;

    return t.toString();

    function merge(basepath, refpath) {
      if (base.host !== undefined && !base.path) return "/" + refpath;

      var lastslash = basepath.lastIndexOf("/");
      if (lastslash === -1) return refpath;else return basepath.substring(0, lastslash + 1) + refpath;
    }

    function remove_dot_segments(path) {
      if (!path) return path; // For "" or undefined

      var output = "";
      while (path.length > 0) {
        if (path === "." || path === "..") {
          path = "";
          break;
        }

        var twochars = path.substring(0, 2);
        var threechars = path.substring(0, 3);
        var fourchars = path.substring(0, 4);
        if (threechars === "../") {
          path = path.substring(3);
        } else if (twochars === "./") {
          path = path.substring(2);
        } else if (threechars === "/./") {
          path = "/" + path.substring(3);
        } else if (twochars === "/." && path.length === 2) {
          path = "/";
        } else if (fourchars === "/../" || threechars === "/.." && path.length === 3) {
          path = "/" + path.substring(4);

          output = output.replace(/\/?[^\/]*$/, "");
        } else {
          var segment = path.match(/(\/?([^\/]*))/)[0];
          output += segment;
          path = path.substring(segment.length);
        }
      }

      return output;
    }
  }
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Node = __webpack_require__(2);
var Element = __webpack_require__(9);
var CSSStyleDeclaration = __webpack_require__(25);
var utils = __webpack_require__(1);
var URLUtils = __webpack_require__(48);
var defineElement = __webpack_require__(49);

var htmlElements = exports.elements = {};
var htmlNameToImpl = Object.create(null);

exports.createElement = function (doc, localName, prefix) {
  var impl = htmlNameToImpl[localName] || HTMLUnknownElement;
  return new impl(doc, localName, prefix);
};

function define(spec) {
  return defineElement(spec, HTMLElement, htmlElements, htmlNameToImpl);
}

function URL(attr) {
  return {
    get: function get() {
      var v = this._getattr(attr);
      if (v === null) {
        return '';
      }
      var url = this.doc._resolve(v);
      return url === null ? v : url;
    },
    set: function set(value) {
      this._setattr(attr, value);
    }
  };
}

function CORS(attr) {
  return {
    get: function get() {
      var v = this._getattr(attr);
      if (v === null) {
        return null;
      }
      if (v.toLowerCase() === 'use-credentials') {
        return 'use-credentials';
      }
      return 'anonymous';
    },
    set: function set(value) {
      if (value === null || value === undefined) {
        this.removeAttribute(attr);
      } else {
        this._setattr(attr, value);
      }
    }
  };
}

var REFERRER = {
  type: ["", "no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url"],
  missing: ''
};

// XXX: the default value for tabIndex should be 0 if the element is
// focusable and -1 if it is not.  But the full definition of focusable
// is actually hard to compute, so for now, I'll follow Firefox and
// just base the default value on the type of the element.
var focusableElements = {
  "A": true, "LINK": true, "BUTTON": true, "INPUT": true,
  "SELECT": true, "TEXTAREA": true, "COMMAND": true
};

var HTMLFormElement = function HTMLFormElement(doc, localName, prefix) {
  HTMLElement.call(this, doc, localName, prefix);
  this._form = null; // Prevent later deoptimization
};

var HTMLElement = exports.HTMLElement = define({
  superclass: Element,
  ctor: function HTMLElement(doc, localName, prefix) {
    Element.call(this, doc, localName, utils.NAMESPACE.HTML, prefix);
  },
  props: {
    innerHTML: {
      get: function get() {
        return this.serialize();
      },
      set: function set(v) {
        var parser = this.ownerDocument.implementation.mozHTMLParser(this.ownerDocument._address, this);
        parser.parse(v === null ? '' : String(v), true);

        // Remove any existing children of this node
        var target = this instanceof htmlNameToImpl.template ? this.content : this;
        while (target.hasChildNodes()) {
          target.removeChild(target.firstChild);
        } // Now copy newly parsed children to this node
        target.appendChild(parser._asDocumentFragment());
      }
    },
    style: { get: function get() {
        if (!this._style) this._style = new CSSStyleDeclaration(this);
        return this._style;
      }, set: function set(v) {
        if (v === null || v === undefined) {
          v = '';
        }
        this._setattr('style', String(v));
      } },

    // These can't really be implemented server-side in a reasonable way.
    blur: { value: function value() {} },
    focus: { value: function value() {} },
    forceSpellCheck: { value: function value() {} },

    click: { value: function value() {
        if (this._click_in_progress) return;
        this._click_in_progress = true;
        try {
          if (this._pre_click_activation_steps) this._pre_click_activation_steps();

          var event = this.ownerDocument.createEvent("MouseEvent");
          event.initMouseEvent("click", true, true, this.ownerDocument.defaultView, 1, 0, 0, 0, 0,
          // These 4 should be initialized with
          // the actually current keyboard state
          // somehow...
          false, false, false, false, 0, null);

          // Dispatch this as an untrusted event since it is synthetic
          var success = this.dispatchEvent(event);

          if (success) {
            if (this._post_click_activation_steps) this._post_click_activation_steps(event);
          } else {
            if (this._cancelled_activation_steps) this._cancelled_activation_steps();
          }
        } finally {
          this._click_in_progress = false;
        }
      } },
    submit: { value: utils.nyi }
  },
  attributes: {
    title: String,
    lang: String,
    dir: { type: ["ltr", "rtl", "auto"], missing: '' },
    accessKey: String,
    hidden: Boolean,
    tabIndex: { type: "long", default: function _default() {
        if (this.tagName in focusableElements || this.contentEditable) return 0;else return -1;
      } }
  },
  events: ["abort", "canplay", "canplaythrough", "change", "click", "contextmenu", "cuechange", "dblclick", "drag", "dragend", "dragenter", "dragleave", "dragover", "dragstart", "drop", "durationchange", "emptied", "ended", "input", "invalid", "keydown", "keypress", "keyup", "loadeddata", "loadedmetadata", "loadstart", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "mousewheel", "pause", "play", "playing", "progress", "ratechange", "readystatechange", "reset", "seeked", "seeking", "select", "show", "stalled", "submit", "suspend", "timeupdate", "volumechange", "waiting",

  // These last 5 event types will be overriden by HTMLBodyElement
  "blur", "error", "focus", "load", "scroll"]
});

// XXX: reflect contextmenu as contextMenu, with element type


// style: the spec doesn't call this a reflected attribute.
//   may want to handle it manually.

// contentEditable: enumerated, not clear if it is actually
// reflected or requires custom getter/setter. Not listed as
// "limited to known values".  Raises syntax_err on bad setting,
// so I think this is custom.

// contextmenu: content is element id, idl type is an element
// draggable: boolean, but not a reflected attribute
// dropzone: reflected SettableTokenList, experimental, so don't
//   implement it right away.

// data-* attributes: need special handling in setAttribute?
// Or maybe that isn't necessary. Can I just scan the attribute list
// when building the dataset?  Liveness and caching issues?

// microdata attributes: many are simple reflected attributes, but
// I'm not going to implement this now.


var HTMLUnknownElement = define({
  ctor: function HTMLUnknownElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

var formAssociatedProps = {
  // See http://www.w3.org/TR/html5/association-of-controls-and-forms.html#form-owner
  form: { get: function get() {
      return this._form;
    } }
};

define({
  tag: 'a',
  ctor: function HTMLAnchorElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    _post_click_activation_steps: { value: function value(e) {
        if (this.href) {
          // Follow the link
          // XXX: this is just a quick hack
          // XXX: the HTML spec probably requires more than this
          this.ownerDocument.defaultView.location = this.href;
        }
      } }
  },
  attributes: {
    href: URL,
    ping: String,
    download: String,
    target: String,
    rel: String,
    media: String,
    hreflang: String,
    type: String,
    referrerPolicy: REFERRER,
    // Obsolete
    coords: String,
    charset: String,
    name: String,
    rev: String,
    shape: String
  }
});
// Latest WhatWG spec says these methods come via HTMLHyperlinkElementUtils
URLUtils._inherit(htmlNameToImpl.a.prototype);

define({
  tag: 'area',
  ctor: function HTMLAreaElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    alt: String,
    target: String,
    download: String,
    rel: String,
    media: String,
    href: URL,
    hreflang: String,
    type: String,
    shape: String,
    coords: String,
    ping: String,
    // XXX: also reflect relList
    referrerPolicy: REFERRER,
    // Obsolete
    noHref: Boolean
  }
});
// Latest WhatWG spec says these methods come via HTMLHyperlinkElementUtils
URLUtils._inherit(htmlNameToImpl.area.prototype);

define({
  tag: 'br',
  ctor: function HTMLBRElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    clear: String
  }
});

define({
  tag: 'base',
  ctor: function HTMLBaseElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    "target": String
  }
});

define({
  tag: 'body',
  ctor: function HTMLBodyElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  // Certain event handler attributes on a <body> tag actually set
  // handlers for the window rather than just that element.  Define
  // getters and setters for those here.  Note that some of these override
  // properties on HTMLElement.prototype.
  // XXX: If I add support for <frameset>, these have to go there, too
  // XXX
  // When the Window object is implemented, these attribute will have
  // to work with the same-named attributes on the Window.
  events: ["afterprint", "beforeprint", "beforeunload", "blur", "error", "focus", "hashchange", "load", "message", "offline", "online", "pagehide", "pageshow", "popstate", "resize", "scroll", "storage", "unload"],
  attributes: {
    // Obsolete
    text: { type: String, treatNullAsEmptyString: true },
    link: { type: String, treatNullAsEmptyString: true },
    vLink: { type: String, treatNullAsEmptyString: true },
    aLink: { type: String, treatNullAsEmptyString: true },
    bgColor: { type: String, treatNullAsEmptyString: true },
    background: String
  }
});

define({
  tag: 'button',
  ctor: function HTMLButtonElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    name: String,
    value: String,
    disabled: Boolean,
    autofocus: Boolean,
    type: { type: ["submit", "reset", "button", "menu"], missing: 'submit' },
    formTarget: String,
    formNoValidate: Boolean,
    formMethod: { type: ["get", "post", "dialog"], invalid: 'get', missing: '' },
    formEnctype: { type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: '' }
  }
});

define({
  tag: 'dl',
  ctor: function HTMLDListElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    compact: Boolean
  }
});

define({
  tag: 'data',
  ctor: function HTMLDataElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    value: String
  }
});

define({
  tag: 'datalist',
  ctor: function HTMLDataListElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'details',
  ctor: function HTMLDetailsElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    "open": Boolean
  }
});

define({
  tag: 'div',
  ctor: function HTMLDivElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String
  }
});

define({
  tag: 'embed',
  ctor: function HTMLEmbedElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    src: URL,
    type: String,
    width: String,
    height: String,
    // Obsolete
    align: String,
    name: String
  }
});

define({
  tag: 'fieldset',
  ctor: function HTMLFieldSetElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    disabled: Boolean,
    name: String
  }
});

define({
  tag: 'form',
  ctor: function HTMLFormElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    action: String,
    autocomplete: { type: ['on', 'off'], missing: 'on' },
    name: String,
    acceptCharset: { name: "accept-charset" },
    target: String,
    noValidate: Boolean,
    method: { type: ["get", "post", "dialog"], invalid: 'get', missing: 'get' },
    // Both enctype and encoding reflect the enctype content attribute
    enctype: { type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: "application/x-www-form-urlencoded" },
    encoding: { name: 'enctype', type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: "application/x-www-form-urlencoded" }
  }
});

define({
  tag: 'hr',
  ctor: function HTMLHRElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String,
    color: String,
    noShade: Boolean,
    size: String,
    width: String
  }
});

define({
  tag: 'head',
  ctor: function HTMLHeadElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tags: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
  ctor: function HTMLHeadingElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String
  }
});

define({
  tag: 'html',
  ctor: function HTMLHtmlElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    version: String
  }
});

define({
  tag: 'iframe',
  ctor: function HTMLIFrameElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
    var Window = __webpack_require__(26); // Avoid circular dependencies.
    this._contentWindow = new Window();
  },
  props: {
    contentWindow: { get: function get() {
        return this._contentWindow;
      } },
    contentDocument: { get: function get() {
        return this.contentWindow.document;
      } }
  },
  attributes: {
    src: URL,
    srcdoc: String,
    name: String,
    width: String,
    height: String,
    // XXX: sandbox is a reflected settable token list
    seamless: Boolean,
    allowFullscreen: Boolean,
    allowUserMedia: Boolean,
    allowPaymentRequest: Boolean,
    referrerPolicy: REFERRER,
    // Obsolete
    align: String,
    scrolling: String,
    frameBorder: String,
    longDesc: URL,
    marginHeight: { type: String, treatNullAsEmptyString: true },
    marginWidth: { type: String, treatNullAsEmptyString: true }
  }
});

define({
  tag: 'img',
  ctor: function HTMLImageElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    alt: String,
    src: URL,
    srcset: String,
    crossOrigin: CORS,
    useMap: String,
    isMap: Boolean,
    height: { type: "unsigned long", default: 0 },
    width: { type: "unsigned long", default: 0 },
    referrerPolicy: REFERRER,
    // Obsolete:
    name: String,
    lowsrc: URL,
    align: String,
    hspace: { type: "unsigned long", default: 0 },
    vspace: { type: "unsigned long", default: 0 },
    longDesc: URL,
    border: { type: String, treatNullAsEmptyString: true }
  }
});

define({
  tag: 'input',
  ctor: function HTMLInputElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: {
    form: formAssociatedProps.form,
    _post_click_activation_steps: { value: function value(e) {
        if (this.type === 'checkbox') {
          this.checked = !this.checked;
        } else if (this.type === 'radio') {
          var group = this.form.getElementsByName(this.name);
          for (var i = group.length - 1; i >= 0; i--) {
            var el = group[i];
            el.checked = el === this;
          }
        }
      } }
  },
  attributes: {
    name: String,
    disabled: Boolean,
    autofocus: Boolean,
    accept: String,
    alt: String,
    max: String,
    min: String,
    pattern: String,
    placeholder: String,
    step: String,
    dirName: String,
    defaultValue: { name: 'value' },
    multiple: Boolean,
    required: Boolean,
    readOnly: Boolean,
    checked: Boolean,
    value: String,
    src: URL,
    defaultChecked: { name: 'checked', type: Boolean },
    size: { type: 'unsigned long', default: 20, min: 1, setmin: 1 },
    width: { type: 'unsigned long', min: 0, setmin: 0, default: 0 },
    height: { type: 'unsigned long', min: 0, setmin: 0, default: 0 },
    minLength: { type: 'unsigned long', min: 0, setmin: 0, default: -1 },
    maxLength: { type: 'unsigned long', min: 0, setmin: 0, default: -1 },
    autocomplete: String, // It's complicated
    type: { type: ["text", "hidden", "search", "tel", "url", "email", "password", "datetime", "date", "month", "week", "time", "datetime-local", "number", "range", "color", "checkbox", "radio", "file", "submit", "image", "reset", "button"],
      missing: 'text' },
    formTarget: String,
    formNoValidate: Boolean,
    formMethod: { type: ["get", "post"], invalid: 'get', missing: '' },
    formEnctype: { type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: '' },
    inputMode: { type: ["verbatim", "latin", "latin-name", "latin-prose", "full-width-latin", "kana", "kana-name", "katakana", "numeric", "tel", "email", "url"], missing: '' },
    // Obsolete
    align: String,
    useMap: String
  }
});

define({
  tag: 'keygen',
  ctor: function HTMLKeygenElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    name: String,
    disabled: Boolean,
    autofocus: Boolean,
    challenge: String,
    keytype: { type: ["rsa"], missing: '' }
  }
});

define({
  tag: 'li',
  ctor: function HTMLLIElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    value: { type: "long", default: 0 },
    // Obsolete
    type: String
  }
});

define({
  tag: 'label',
  ctor: function HTMLLabelElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    htmlFor: { name: 'for', type: String }
  }
});

define({
  tag: 'legend',
  ctor: function HTMLLegendElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String
  }
});

define({
  tag: 'link',
  ctor: function HTMLLinkElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // XXX Reflect DOMSettableTokenList sizes also DOMTokenList relList
    href: URL,
    rel: String,
    media: String,
    hreflang: String,
    type: String,
    crossOrigin: CORS,
    nonce: String,
    integrity: String,
    referrerPolicy: REFERRER,
    // Obsolete
    charset: String,
    rev: String,
    target: String
  }
});

define({
  tag: 'map',
  ctor: function HTMLMapElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    name: String
  }
});

define({
  tag: 'menu',
  ctor: function HTMLMenuElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // XXX: not quite right, default should be popup if parent element is
    // popup.
    type: { type: ['context', 'popup', 'toolbar'], missing: 'toolbar' },
    label: String,
    // Obsolete
    compact: Boolean
  }
});

define({
  tag: 'meta',
  ctor: function HTMLMetaElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    name: String,
    content: String,
    httpEquiv: { name: 'http-equiv', type: String },
    // Obsolete
    scheme: String
  }
});

define({
  tag: 'meter',
  ctor: function HTMLMeterElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps
});

define({
  tags: ['ins', 'del'],
  ctor: function HTMLModElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    cite: URL,
    dateTime: String
  }
});

define({
  tag: 'ol',
  ctor: function HTMLOListElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    // Utility function (see the start attribute default value). Returns
    // the number of <li> children of this element
    _numitems: { get: function get() {
        var items = 0;
        this.childNodes.forEach(function (n) {
          if (n.nodeType === Node.ELEMENT_NODE && n.tagName === "LI") items++;
        });
        return items;
      } }
  },
  attributes: {
    type: String,
    reversed: Boolean,
    start: {
      type: "long",
      default: function _default() {
        // The default value of the start attribute is 1 unless the list is
        // reversed. Then it is the # of li children
        if (this.reversed) return this._numitems;else return 1;
      }
    },
    // Obsolete
    compact: Boolean
  }
});

define({
  tag: 'object',
  ctor: function HTMLObjectElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    data: URL,
    type: String,
    name: String,
    useMap: String,
    typeMustMatch: Boolean,
    width: String,
    height: String,
    // Obsolete
    align: String,
    archive: String,
    code: String,
    declare: Boolean,
    hspace: { type: "unsigned long", default: 0 },
    standby: String,
    vspace: { type: "unsigned long", default: 0 },
    codeBase: URL,
    codeType: String,
    border: { type: String, treatNullAsEmptyString: true }
  }
});

define({
  tag: 'optgroup',
  ctor: function HTMLOptGroupElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    disabled: Boolean,
    label: String
  }
});

define({
  tag: 'option',
  ctor: function HTMLOptionElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    form: { get: function get() {
        var p = this.parentNode;
        while (p && p.nodeType === Node.ELEMENT_NODE) {
          if (p.localName === 'select') return p.form;
          p = p.parentNode;
        }
      } },
    value: {
      get: function get() {
        return this._getattr('value') || this.text;
      },
      set: function set(v) {
        this._setattr('value', v);
      }
    },
    text: {
      get: function get() {
        // Strip and collapse whitespace
        return this.textContent.replace(/[ \t\n\f\r]+/g, ' ').trim();
      },
      set: function set(v) {
        this.textContent = v;
      }
    }
    // missing: index
  },
  attributes: {
    disabled: Boolean,
    defaultSelected: { name: 'selected', type: Boolean },
    label: String
  }
});

define({
  tag: 'output',
  ctor: function HTMLOutputElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    // XXX Reflect for/htmlFor as a settable token list
    name: String
  }
});

define({
  tag: 'p',
  ctor: function HTMLParagraphElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String
  }
});

define({
  tag: 'param',
  ctor: function HTMLParamElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    name: String,
    value: String,
    // Obsolete
    type: String,
    valueType: String
  }
});

define({
  tags: ['pre', /*legacy elements:*/'listing', 'xmp'],
  ctor: function HTMLPreElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    width: { type: "long", default: 0 }
  }
});

define({
  tag: 'progress',
  ctor: function HTMLProgressElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    max: { type: Number, float: true, default: 1.0, min: 0 }
  }
});

define({
  tags: ['q', 'blockquote'],
  ctor: function HTMLQuoteElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    cite: URL
  }
});

define({
  tag: 'script',
  ctor: function HTMLScriptElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    text: {
      get: function get() {
        var s = "";
        for (var i = 0, n = this.childNodes.length; i < n; i++) {
          var child = this.childNodes[i];
          if (child.nodeType === Node.TEXT_NODE) s += child._data;
        }
        return s;
      },
      set: function set(value) {
        this.removeChildren();
        if (value !== null && value !== "") {
          this.appendChild(this.ownerDocument.createTextNode(value));
        }
      }
    }
  },
  attributes: {
    src: URL,
    type: String,
    charset: String,
    defer: Boolean,
    async: Boolean,
    crossOrigin: CORS,
    nonce: String,
    integrity: String
  }
});

define({
  tag: 'select',
  ctor: function HTMLSelectElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: {
    form: formAssociatedProps.form,
    options: { get: function get() {
        return this.getElementsByTagName('option');
      } }
  },
  attributes: {
    autocomplete: String, // It's complicated
    name: String,
    disabled: Boolean,
    autofocus: Boolean,
    multiple: Boolean,
    required: Boolean,
    size: { type: "unsigned long", default: 0 }
  }
});

define({
  tag: 'source',
  ctor: function HTMLSourceElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    src: URL,
    type: String,
    media: String
  }
});

define({
  tag: 'span',
  ctor: function HTMLSpanElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'style',
  ctor: function HTMLStyleElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    media: String,
    type: String,
    scoped: Boolean
  }
});

define({
  tag: 'caption',
  ctor: function HTMLTableCaptionElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String
  }
});

define({
  ctor: function HTMLTableCellElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    colSpan: { type: "unsigned long", default: 1 },
    rowSpan: { type: "unsigned long", default: 1 },
    //XXX Also reflect settable token list headers
    scope: { type: ['row', 'col', 'rowgroup', 'colgroup'], missing: '' },
    abbr: String,
    // Obsolete
    align: String,
    axis: String,
    height: String,
    width: String,
    ch: { name: 'char', type: String },
    chOff: { name: 'charoff', type: String },
    noWrap: Boolean,
    vAlign: String,
    bgColor: { type: String, treatNullAsEmptyString: true }
  }
});

define({
  tags: ['col', 'colgroup'],
  ctor: function HTMLTableColElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    span: { type: 'limited unsigned long with fallback', default: 1, min: 1 },
    // Obsolete
    align: String,
    ch: { name: 'char', type: String },
    chOff: { name: 'charoff', type: String },
    vAlign: String,
    width: String
  }
});

define({
  tag: 'table',
  ctor: function HTMLTableElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    rows: { get: function get() {
        return this.getElementsByTagName('tr');
      } }
  },
  attributes: {
    // Obsolete
    align: String,
    border: String,
    frame: String,
    rules: String,
    summary: String,
    width: String,
    bgColor: { type: String, treatNullAsEmptyString: true },
    cellPadding: { type: String, treatNullAsEmptyString: true },
    cellSpacing: { type: String, treatNullAsEmptyString: true }
  }
});

define({
  tag: 'template',
  ctor: function HTMLTemplateElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
    this._contentFragment = doc._templateDoc.createDocumentFragment();
  },
  props: {
    content: { get: function get() {
        return this._contentFragment;
      } },
    serialize: { value: function value() {
        return this.content.serialize();
      } }
  }
});

define({
  tag: 'tr',
  ctor: function HTMLTableRowElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    cells: { get: function get() {
        return this.querySelectorAll('td,th');
      } }
  },
  attributes: {
    // Obsolete
    align: String,
    ch: { name: 'char', type: String },
    chOff: { name: 'charoff', type: String },
    vAlign: String,
    bgColor: { type: String, treatNullAsEmptyString: true }
  }
});

define({
  tags: ['thead', 'tfoot', 'tbody'],
  ctor: function HTMLTableSectionElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    rows: { get: function get() {
        return this.getElementsByTagName('tr');
      } }
  },
  attributes: {
    // Obsolete
    align: String,
    ch: { name: 'char', type: String },
    chOff: { name: 'charoff', type: String },
    vAlign: String
  }
});

define({
  tag: 'textarea',
  ctor: function HTMLTextAreaElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: {
    form: formAssociatedProps.form,
    type: { get: function get() {
        return 'textarea';
      } },
    defaultValue: {
      get: function get() {
        return this.textContent;
      },
      set: function set(v) {
        this.textContent = v;
      }
    },
    value: {
      get: function get() {
        return this.defaultValue; /* never dirty */
      },
      set: function set(v) {
        // This isn't completely correct: according to the spec, this
        // should "dirty" the API value, and result in
        // `this.value !== this.defaultValue`.  But for most of what
        // folks want to do, this implementation should be fine:
        this.defaultValue = v;
      }
    },
    textLength: { get: function get() {
        return this.value.length;
      } }
  },
  attributes: {
    autocomplete: String, // It's complicated
    name: String,
    disabled: Boolean,
    autofocus: Boolean,
    placeholder: String,
    wrap: String,
    dirName: String,
    required: Boolean,
    readOnly: Boolean,
    rows: { type: 'limited unsigned long with fallback', default: 2 },
    cols: { type: 'limited unsigned long with fallback', default: 20 },
    maxLength: { type: 'unsigned long', min: 0, setmin: 0, default: -1 },
    minLength: { type: 'unsigned long', min: 0, setmin: 0, default: -1 },
    inputMode: { type: ["verbatim", "latin", "latin-name", "latin-prose", "full-width-latin", "kana", "kana-name", "katakana", "numeric", "tel", "email", "url"], missing: '' }
  }
});

define({
  tag: 'time',
  ctor: function HTMLTimeElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    dateTime: String,
    pubDate: Boolean
  }
});

define({
  tag: 'title',
  ctor: function HTMLTitleElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    text: { get: function get() {
        return this.textContent;
      } }
  }
});

define({
  tag: 'ul',
  ctor: function HTMLUListElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    type: String,
    // Obsolete
    compact: Boolean
  }
});

define({
  ctor: function HTMLMediaElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    src: URL,
    crossOrigin: CORS,
    preload: { type: ["metadata", "none", "auto", { value: "", alias: "auto" }], missing: 'auto' },
    loop: Boolean,
    autoplay: Boolean,
    mediaGroup: String,
    controls: Boolean,
    defaultMuted: { name: "muted", type: Boolean }
  }
});

define({
  tag: 'audio',
  superclass: htmlElements.HTMLMediaElement,
  ctor: function HTMLAudioElement(doc, localName, prefix) {
    htmlElements.HTMLMediaElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'video',
  superclass: htmlElements.HTMLMediaElement,
  ctor: function HTMLVideoElement(doc, localName, prefix) {
    htmlElements.HTMLMediaElement.call(this, doc, localName, prefix);
  },
  attributes: {
    poster: URL,
    width: { type: "unsigned long", min: 0, default: 0 },
    height: { type: "unsigned long", min: 0, default: 0 }
  }
});

define({
  tag: 'td',
  superclass: htmlElements.HTMLTableCellElement,
  ctor: function HTMLTableDataCellElement(doc, localName, prefix) {
    htmlElements.HTMLTableCellElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'th',
  superclass: htmlElements.HTMLTableCellElement,
  ctor: function HTMLTableHeaderCellElement(doc, localName, prefix) {
    htmlElements.HTMLTableCellElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'frameset',
  ctor: function HTMLFrameSetElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'frame',
  ctor: function HTMLFrameElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'canvas',
  ctor: function HTMLCanvasElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    getContext: { value: utils.nyi },
    probablySupportsContext: { value: utils.nyi },
    setContext: { value: utils.nyi },
    transferControlToProxy: { value: utils.nyi },
    toDataURL: { value: utils.nyi },
    toBlob: { value: utils.nyi }
  },
  attributes: {
    width: { type: "unsigned long", default: 300 },
    height: { type: "unsigned long", default: 150 }
  }
});

define({
  tag: 'dialog',
  ctor: function HTMLDialogElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    show: { value: utils.nyi },
    showModal: { value: utils.nyi },
    close: { value: utils.nyi }
  },
  attributes: {
    open: Boolean,
    returnValue: String
  }
});

define({
  tag: 'menuitem',
  ctor: function HTMLMenuItemElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    // The menuitem's label
    _label: {
      get: function get() {
        var val = this._getattr('label');
        if (val !== null && val !== '') {
          return val;
        }
        val = this.textContent;
        // Strip and collapse whitespace
        return val.replace(/[ \t\n\f\r]+/g, ' ').trim();
      }
    },
    // The menuitem label IDL attribute
    label: {
      get: function get() {
        var val = this._getattr('label');
        if (val !== null) {
          return val;
        }
        return this._label;
      },
      set: function set(v) {
        this._setattr('label', v);
      }
    }
  },
  attributes: {
    type: { type: ["command", "checkbox", "radio"], missing: 'command' },
    icon: URL,
    disabled: Boolean,
    checked: Boolean,
    radiogroup: String,
    default: Boolean
  }
});

define({
  tag: 'source',
  ctor: function HTMLSourceElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    srcset: String,
    sizes: String,
    media: String,
    src: URL,
    type: String
  }
});

define({
  tag: 'track',
  ctor: function HTMLTrackElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    src: URL,
    srclang: String,
    label: String,
    default: Boolean,
    kind: { type: ["subtitles", "captions", "descriptions", "chapters", "metadata"], missing: 'subtitles', invalid: 'metadata' }
  },
  props: {
    NONE: { get: function get() {
        return 0;
      } },
    LOADING: { get: function get() {
        return 1;
      } },
    LOADED: { get: function get() {
        return 2;
      } },
    ERROR: { get: function get() {
        return 3;
      } },
    readyState: { get: utils.nyi },
    track: { get: utils.nyi }
  }
});

define({
  // obsolete
  tag: 'font',
  ctor: function HTMLFontElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    color: { type: String, treatNullAsEmptyString: true },
    face: { type: String },
    size: { type: String }
  }
});

define({
  // obsolete
  tag: 'dir',
  ctor: function HTMLDirectoryElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    compact: Boolean
  }
});

define({
  tags: ["abbr", "address", "article", "aside", "b", "bdi", "bdo", "cite", "code", "dd", "dfn", "dt", "em", "figcaption", "figure", "footer", "header", "hgroup", "i", "kbd", "main", "mark", "nav", "noscript", "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "section", "small", "strong", "sub", "summary", "sup", "u", "var", "wbr",
  // Legacy elements
  "acronym", "basefont", "big", "center", "nobr", "noembed", "noframes", "plaintext", "strike", "tt"]
});

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var parserlib = __webpack_require__(78);

module.exports = CSSStyleDeclaration;

function CSSStyleDeclaration(elt) {
  this._element = elt;
}

// Utility function for parsing style declarations
// Pass in a string like "margin-left: 5px; border-style: solid"
// and this function returns an object like
// {"margin-left":"5px", "border-style":"solid"}
function parseStyles(s) {
  var parser = new parserlib.css.Parser();
  var result = { property: Object.create(null), priority: Object.create(null) };
  parser.addListener("property", function (e) {
    if (e.invalid) return; // Skip errors
    result.property[e.property.text] = e.value.text;
    if (e.important) result.priority[e.property.text] = 'important';
  });
  s = ('' + s).replace(/^;/, '');
  parser.parseStyleAttribute(s);
  return result;
}

var NO_CHANGE = {}; // Private marker object

CSSStyleDeclaration.prototype = Object.create(Object.prototype, {

  // Return the parsed form of the element's style attribute.
  // If the element's style attribute has never been parsed
  // or if it has changed since the last parse, then reparse it
  // Note that the styles don't get parsed until they're actually needed
  _parsed: { get: function get() {
      if (!this._parsedStyles || this.cssText !== this._lastParsedText) {
        var text = this.cssText;
        this._parsedStyles = parseStyles(text);
        this._lastParsedText = text;
        delete this._names;
      }
      return this._parsedStyles;
    } },

  // Call this method any time the parsed representation of the
  // style changes.  It converts the style properties to a string and
  // sets cssText and the element's style attribute
  _serialize: { value: function value() {
      var styles = this._parsed;
      var s = "";

      for (var name in styles.property) {
        if (s) s += " ";
        s += name + ": " + styles.property[name];
        if (styles.priority[name]) {
          s += " !" + styles.priority[name];
        }
        s += ";";
      }

      this.cssText = s; // also sets the style attribute
      this._lastParsedText = s; // so we don't reparse
      delete this._names;
    } },

  cssText: {
    get: function get() {
      // XXX: this is a CSSStyleDeclaration for an element.
      // A different impl might be necessary for a set of styles
      // associated returned by getComputedStyle(), e.g.
      return this._element.getAttribute("style");
    },
    set: function set(value) {
      // XXX: I should parse and serialize the value to
      // normalize it and remove errors. FF and chrome do that.
      this._element.setAttribute("style", value);
    }
  },

  length: { get: function get() {
      if (!this._names) this._names = Object.getOwnPropertyNames(this._parsed.property);
      return this._names.length;
    } },

  item: { value: function value(n) {
      if (!this._names) this._names = Object.getOwnPropertyNames(this._parsed.property);
      return this._names[n];
    } },

  getPropertyValue: { value: function value(property) {
      property = property.toLowerCase();
      return this._parsed.property[property] || "";
    } },

  getPropertyPriority: { value: function value(property) {
      property = property.toLowerCase();
      return this._parsed.priority[property] || "";
    } },

  setProperty: { value: function value(property, _value, priority) {
      property = property.toLowerCase();
      if (_value === null || _value === undefined) {
        _value = "";
      }
      if (priority === null || priority === undefined) {
        priority = "";
      }

      // String coercion
      if (_value !== NO_CHANGE) {
        _value = "" + _value;
      }

      if (_value === "") {
        this.removeProperty(property);
        return;
      }

      if (priority !== "" && priority !== NO_CHANGE && !/^important$/i.test(priority)) {
        return;
      }

      var styles = this._parsed;
      if (_value === NO_CHANGE) {
        if (!styles.property[property]) {
          return; // Not a valid property name.
        }
        if (priority !== "") {
          styles.priority[property] = "important";
        } else {
          delete styles.priority[property];
        }
      } else {
        // We don't just accept the property value.  Instead
        // we parse it to ensure that it is something valid.
        // If it contains a semicolon it is invalid
        if (_value.indexOf(";") !== -1) return;

        var newprops = parseStyles(property + ":" + _value);
        if (Object.getOwnPropertyNames(newprops.property).length === 0) {
          return; // no valid property found
        }
        if (Object.getOwnPropertyNames(newprops.priority).length !== 0) {
          return; // if the value included '!important' it wasn't valid.
        }

        // XXX handle shorthand properties

        for (var p in newprops.property) {
          styles.property[p] = newprops.property[p];
          if (priority === NO_CHANGE) {
            continue;
          } else if (priority !== "") {
            styles.priority[p] = "important";
          } else if (styles.priority[p]) {
            delete styles.priority[p];
          }
        }
      }

      // Serialize and update cssText and element.style!
      this._serialize();
    } },

  setPropertyValue: { value: function value(property, _value2) {
      return this.setProperty(property, _value2, NO_CHANGE);
    } },

  setPropertyPriority: { value: function value(property, priority) {
      return this.setProperty(property, NO_CHANGE, priority);
    } },

  removeProperty: { value: function value(property) {
      property = property.toLowerCase();
      var styles = this._parsed;
      if (property in styles.property) {
        delete styles.property[property];
        delete styles.priority[property];

        // Serialize and update cssText and element.style!
        this._serialize();
      }
    } }
});

var cssProperties = {
  alignContent: "align-content",
  alignItems: "align-items",
  alignmentBaseline: "alignment-baseline",
  alignSelf: "align-self",
  animation: "animation",
  animationDelay: "animation-delay",
  animationDirection: "animation-direction",
  animationDuration: "animation-duration",
  animationFillMode: "animation-fill-mode",
  animationIterationCount: "animation-iteration-count",
  animationName: "animation-name",
  animationPlayState: "animation-play-state",
  animationTimingFunction: "animation-timing-function",
  backfaceVisibility: "backface-visibility",
  background: "background",
  backgroundAttachment: "background-attachment",
  backgroundClip: "background-clip",
  backgroundColor: "background-color",
  backgroundImage: "background-image",
  backgroundOrigin: "background-origin",
  backgroundPosition: "background-position",
  backgroundPositionX: "background-position-x",
  backgroundPositionY: "background-position-y",
  backgroundRepeat: "background-repeat",
  backgroundSize: "background-size",
  baselineShift: "baseline-shift",
  border: "border",
  borderBottom: "border-bottom",
  borderBottomColor: "border-bottom-color",
  borderBottomLeftRadius: "border-bottom-left-radius",
  borderBottomRightRadius: "border-bottom-right-radius",
  borderBottomStyle: "border-bottom-style",
  borderBottomWidth: "border-bottom-width",
  borderCollapse: "border-collapse",
  borderColor: "border-color",
  borderImage: "border-image",
  borderImageOutset: "border-image-outset",
  borderImageRepeat: "border-image-repeat",
  borderImageSlice: "border-image-slice",
  borderImageSource: "border-image-source",
  borderImageWidth: "border-image-width",
  borderLeft: "border-left",
  borderLeftColor: "border-left-color",
  borderLeftStyle: "border-left-style",
  borderLeftWidth: "border-left-width",
  borderRadius: "border-radius",
  borderRight: "border-right",
  borderRightColor: "border-right-color",
  borderRightStyle: "border-right-style",
  borderRightWidth: "border-right-width",
  borderSpacing: "border-spacing",
  borderStyle: "border-style",
  borderTop: "border-top",
  borderTopColor: "border-top-color",
  borderTopLeftRadius: "border-top-left-radius",
  borderTopRightRadius: "border-top-right-radius",
  borderTopStyle: "border-top-style",
  borderTopWidth: "border-top-width",
  borderWidth: "border-width",
  bottom: "bottom",
  boxShadow: "box-shadow",
  boxSizing: "box-sizing",
  breakAfter: "break-after",
  breakBefore: "break-before",
  breakInside: "break-inside",
  captionSide: "caption-side",
  clear: "clear",
  clip: "clip",
  clipPath: "clip-path",
  clipRule: "clip-rule",
  color: "color",
  colorInterpolationFilters: "color-interpolation-filters",
  columnCount: "column-count",
  columnFill: "column-fill",
  columnGap: "column-gap",
  columnRule: "column-rule",
  columnRuleColor: "column-rule-color",
  columnRuleStyle: "column-rule-style",
  columnRuleWidth: "column-rule-width",
  columns: "columns",
  columnSpan: "column-span",
  columnWidth: "column-width",
  content: "content",
  counterIncrement: "counter-increment",
  counterReset: "counter-reset",
  cssFloat: "float",
  cursor: "cursor",
  direction: "direction",
  display: "display",
  dominantBaseline: "dominant-baseline",
  emptyCells: "empty-cells",
  enableBackground: "enable-background",
  fill: "fill",
  fillOpacity: "fill-opacity",
  fillRule: "fill-rule",
  filter: "filter",
  flex: "flex",
  flexBasis: "flex-basis",
  flexDirection: "flex-direction",
  flexFlow: "flex-flow",
  flexGrow: "flex-grow",
  flexShrink: "flex-shrink",
  flexWrap: "flex-wrap",
  floodColor: "flood-color",
  floodOpacity: "flood-opacity",
  font: "font",
  fontFamily: "font-family",
  fontFeatureSettings: "font-feature-settings",
  fontSize: "font-size",
  fontSizeAdjust: "font-size-adjust",
  fontStretch: "font-stretch",
  fontStyle: "font-style",
  fontVariant: "font-variant",
  fontWeight: "font-weight",
  glyphOrientationHorizontal: "glyph-orientation-horizontal",
  glyphOrientationVertical: "glyph-orientation-vertical",
  grid: "grid",
  gridArea: "grid-area",
  gridAutoColumns: "grid-auto-columns",
  gridAutoFlow: "grid-auto-flow",
  gridAutoRows: "grid-auto-rows",
  gridColumn: "grid-column",
  gridColumnEnd: "grid-column-end",
  gridColumnGap: "grid-column-gap",
  gridColumnStart: "grid-column-start",
  gridGap: "grid-gap",
  gridRow: "grid-row",
  gridRowEnd: "grid-row-end",
  gridRowGap: "grid-row-gap",
  gridRowStart: "grid-row-start",
  gridTemplate: "grid-template",
  gridTemplateAreas: "grid-template-areas",
  gridTemplateColumns: "grid-template-columns",
  gridTemplateRows: "grid-template-rows",
  height: "height",
  imeMode: "ime-mode",
  justifyContent: "justify-content",
  kerning: "kerning",
  layoutGrid: "layout-grid",
  layoutGridChar: "layout-grid-char",
  layoutGridLine: "layout-grid-line",
  layoutGridMode: "layout-grid-mode",
  layoutGridType: "layout-grid-type",
  left: "left",
  letterSpacing: "letter-spacing",
  lightingColor: "lighting-color",
  lineBreak: "line-break",
  lineHeight: "line-height",
  listStyle: "list-style",
  listStyleImage: "list-style-image",
  listStylePosition: "list-style-position",
  listStyleType: "list-style-type",
  margin: "margin",
  marginBottom: "margin-bottom",
  marginLeft: "margin-left",
  marginRight: "margin-right",
  marginTop: "margin-top",
  marker: "marker",
  markerEnd: "marker-end",
  markerMid: "marker-mid",
  markerStart: "marker-start",
  mask: "mask",
  maxHeight: "max-height",
  maxWidth: "max-width",
  minHeight: "min-height",
  minWidth: "min-width",
  msContentZoomChaining: "-ms-content-zoom-chaining",
  msContentZooming: "-ms-content-zooming",
  msContentZoomLimit: "-ms-content-zoom-limit",
  msContentZoomLimitMax: "-ms-content-zoom-limit-max",
  msContentZoomLimitMin: "-ms-content-zoom-limit-min",
  msContentZoomSnap: "-ms-content-zoom-snap",
  msContentZoomSnapPoints: "-ms-content-zoom-snap-points",
  msContentZoomSnapType: "-ms-content-zoom-snap-type",
  msFlowFrom: "-ms-flow-from",
  msFlowInto: "-ms-flow-into",
  msFontFeatureSettings: "-ms-font-feature-settings",
  msGridColumn: "-ms-grid-column",
  msGridColumnAlign: "-ms-grid-column-align",
  msGridColumns: "-ms-grid-columns",
  msGridColumnSpan: "-ms-grid-column-span",
  msGridRow: "-ms-grid-row",
  msGridRowAlign: "-ms-grid-row-align",
  msGridRows: "-ms-grid-rows",
  msGridRowSpan: "-ms-grid-row-span",
  msHighContrastAdjust: "-ms-high-contrast-adjust",
  msHyphenateLimitChars: "-ms-hyphenate-limit-chars",
  msHyphenateLimitLines: "-ms-hyphenate-limit-lines",
  msHyphenateLimitZone: "-ms-hyphenate-limit-zone",
  msHyphens: "-ms-hyphens",
  msImeAlign: "-ms-ime-align",
  msOverflowStyle: "-ms-overflow-style",
  msScrollChaining: "-ms-scroll-chaining",
  msScrollLimit: "-ms-scroll-limit",
  msScrollLimitXMax: "-ms-scroll-limit-x-max",
  msScrollLimitXMin: "-ms-scroll-limit-x-min",
  msScrollLimitYMax: "-ms-scroll-limit-y-max",
  msScrollLimitYMin: "-ms-scroll-limit-y-min",
  msScrollRails: "-ms-scroll-rails",
  msScrollSnapPointsX: "-ms-scroll-snap-points-x",
  msScrollSnapPointsY: "-ms-scroll-snap-points-y",
  msScrollSnapType: "-ms-scroll-snap-type",
  msScrollSnapX: "-ms-scroll-snap-x",
  msScrollSnapY: "-ms-scroll-snap-y",
  msScrollTranslation: "-ms-scroll-translation",
  msTextCombineHorizontal: "-ms-text-combine-horizontal",
  msTextSizeAdjust: "-ms-text-size-adjust",
  msTouchAction: "-ms-touch-action",
  msTouchSelect: "-ms-touch-select",
  msUserSelect: "-ms-user-select",
  msWrapFlow: "-ms-wrap-flow",
  msWrapMargin: "-ms-wrap-margin",
  msWrapThrough: "-ms-wrap-through",
  opacity: "opacity",
  order: "order",
  orphans: "orphans",
  outline: "outline",
  outlineColor: "outline-color",
  outlineOffset: "outline-offset",
  outlineStyle: "outline-style",
  outlineWidth: "outline-width",
  overflow: "overflow",
  overflowX: "overflow-x",
  overflowY: "overflow-y",
  padding: "padding",
  paddingBottom: "padding-bottom",
  paddingLeft: "padding-left",
  paddingRight: "padding-right",
  paddingTop: "padding-top",
  page: "page",
  pageBreakAfter: "page-break-after",
  pageBreakBefore: "page-break-before",
  pageBreakInside: "page-break-inside",
  perspective: "perspective",
  perspectiveOrigin: "perspective-origin",
  pointerEvents: "pointer-events",
  position: "position",
  quotes: "quotes",
  right: "right",
  rotate: "rotate",
  rubyAlign: "ruby-align",
  rubyOverhang: "ruby-overhang",
  rubyPosition: "ruby-position",
  scale: "scale",
  size: "size",
  stopColor: "stop-color",
  stopOpacity: "stop-opacity",
  stroke: "stroke",
  strokeDasharray: "stroke-dasharray",
  strokeDashoffset: "stroke-dashoffset",
  strokeLinecap: "stroke-linecap",
  strokeLinejoin: "stroke-linejoin",
  strokeMiterlimit: "stroke-miterlimit",
  strokeOpacity: "stroke-opacity",
  strokeWidth: "stroke-width",
  tableLayout: "table-layout",
  textAlign: "text-align",
  textAlignLast: "text-align-last",
  textAnchor: "text-anchor",
  textDecoration: "text-decoration",
  textIndent: "text-indent",
  textJustify: "text-justify",
  textKashida: "text-kashida",
  textKashidaSpace: "text-kashida-space",
  textOverflow: "text-overflow",
  textShadow: "text-shadow",
  textTransform: "text-transform",
  textUnderlinePosition: "text-underline-position",
  top: "top",
  touchAction: "touch-action",
  transform: "transform",
  transformOrigin: "transform-origin",
  transformStyle: "transform-style",
  transition: "transition",
  transitionDelay: "transition-delay",
  transitionDuration: "transition-duration",
  transitionProperty: "transition-property",
  transitionTimingFunction: "transition-timing-function",
  translate: "translate",
  unicodeBidi: "unicode-bidi",
  verticalAlign: "vertical-align",
  visibility: "visibility",
  webkitAlignContent: "-webkit-align-content",
  webkitAlignItems: "-webkit-align-items",
  webkitAlignSelf: "-webkit-align-self",
  webkitAnimation: "-webkit-animation",
  webkitAnimationDelay: "-webkit-animation-delay",
  webkitAnimationDirection: "-webkit-animation-direction",
  webkitAnimationDuration: "-webkit-animation-duration",
  webkitAnimationFillMode: "-webkit-animation-fill-mode",
  webkitAnimationIterationCount: "-webkit-animation-iteration-count",
  webkitAnimationName: "-webkit-animation-name",
  webkitAnimationPlayState: "-webkit-animation-play-state",
  webkitAnimationTimingFunction: "-webkit-animation-timing-funciton",
  webkitAppearance: "-webkit-appearance",
  webkitBackfaceVisibility: "-webkit-backface-visibility",
  webkitBackgroundClip: "-webkit-background-clip",
  webkitBackgroundOrigin: "-webkit-background-origin",
  webkitBackgroundSize: "-webkit-background-size",
  webkitBorderBottomLeftRadius: "-webkit-border-bottom-left-radius",
  webkitBorderBottomRightRadius: "-webkit-border-bottom-right-radius",
  webkitBorderImage: "-webkit-border-image",
  webkitBorderRadius: "-webkit-border-radius",
  webkitBorderTopLeftRadius: "-webkit-border-top-left-radius",
  webkitBorderTopRightRadius: "-webkit-border-top-right-radius",
  webkitBoxAlign: "-webkit-box-align",
  webkitBoxDirection: "-webkit-box-direction",
  webkitBoxFlex: "-webkit-box-flex",
  webkitBoxOrdinalGroup: "-webkit-box-ordinal-group",
  webkitBoxOrient: "-webkit-box-orient",
  webkitBoxPack: "-webkit-box-pack",
  webkitBoxSizing: "-webkit-box-sizing",
  webkitColumnBreakAfter: "-webkit-column-break-after",
  webkitColumnBreakBefore: "-webkit-column-break-before",
  webkitColumnBreakInside: "-webkit-column-break-inside",
  webkitColumnCount: "-webkit-column-count",
  webkitColumnGap: "-webkit-column-gap",
  webkitColumnRule: "-webkit-column-rule",
  webkitColumnRuleColor: "-webkit-column-rule-color",
  webkitColumnRuleStyle: "-webkit-column-rule-style",
  webkitColumnRuleWidth: "-webkit-column-rule-width",
  webkitColumns: "-webkit-columns",
  webkitColumnSpan: "-webkit-column-span",
  webkitColumnWidth: "-webkit-column-width",
  webkitFilter: "-webkit-filter",
  webkitFlex: "-webkit-flex",
  webkitFlexBasis: "-webkit-flex-basis",
  webkitFlexDirection: "-webkit-flex-direction",
  webkitFlexFlow: "-webkit-flex-flow",
  webkitFlexGrow: "-webkit-flex-grow",
  webkitFlexShrink: "-webkit-flex-shrink",
  webkitFlexWrap: "-webkit-flex-wrap",
  webkitJustifyContent: "-webkit-justify-content",
  webkitOrder: "-webkit-order",
  webkitPerspective: "-webkit-perspective-origin",
  webkitPerspectiveOrigin: "-webkit-perspective-origin",
  webkitTapHighlightColor: "-webkit-tap-highlight-color",
  webkitTextFillColor: "-webkit-text-fill-color",
  webkitTextSizeAdjust: "-webkit-text-size-adjust",
  webkitTextStroke: "-webkit-text-stroke",
  webkitTextStrokeColor: "-webkit-text-stroke-color",
  webkitTextStrokeWidth: "-webkit-text-stroke-width",
  webkitTransform: "-webkit-transform",
  webkitTransformOrigin: "-webkit-transform-origin",
  webkitTransformStyle: "-webkit-transform-style",
  webkitTransition: "-webkit-transition",
  webkitTransitionDelay: "-webkit-transition-delay",
  webkitTransitionDuration: "-webkit-transition-duration",
  webkitTransitionProperty: "-webkit-transition-property",
  webkitTransitionTimingFunction: "-webkit-transition-timing-function",
  webkitUserModify: "-webkit-user-modify",
  webkitUserSelect: "-webkit-user-select",
  webkitWritingMode: "-webkit-writing-mode",
  whiteSpace: "white-space",
  widows: "widows",
  width: "width",
  wordBreak: "word-break",
  wordSpacing: "word-spacing",
  wordWrap: "word-wrap",
  writingMode: "writing-mode",
  zIndex: "z-index",
  zoom: "zoom",
  resize: "resize",
  userSelect: "user-select"
};

for (var prop in cssProperties) {
  defineStyleProperty(prop);
}function defineStyleProperty(jsname) {
  var cssname = cssProperties[jsname];
  Object.defineProperty(CSSStyleDeclaration.prototype, jsname, {
    get: function get() {
      return this.getPropertyValue(cssname);
    },
    set: function set(value) {
      this.setProperty(cssname, value);
    }
  });

  if (!CSSStyleDeclaration.prototype.hasOwnProperty(cssname)) {
    Object.defineProperty(CSSStyleDeclaration.prototype, cssname, {
      get: function get() {
        return this.getPropertyValue(cssname);
      },
      set: function set(value) {
        this.setProperty(cssname, value);
      }
    });
  }
}

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DOMImplementation = __webpack_require__(11);
var EventTarget = __webpack_require__(32);
var Location = __webpack_require__(79);
var sloppy = __webpack_require__(50);
var utils = __webpack_require__(1);

module.exports = Window;

function Window(document) {
  this.document = document || new DOMImplementation(null).createHTMLDocument("");
  this.document._scripting_enabled = true;
  this.document.defaultView = this;
  this.location = new Location(this, this.document._address || 'about:blank');
}

Window.prototype = Object.create(EventTarget.prototype, {
  _run: { value: sloppy.Window_run },
  console: { value: console },
  history: { value: {
      back: utils.nyi,
      forward: utils.nyi,
      go: utils.nyi
    } },
  navigator: { value: __webpack_require__(80) },

  // Self-referential properties
  window: { get: function get() {
      return this;
    } },
  self: { get: function get() {
      return this;
    } },
  frames: { get: function get() {
      return this;
    } },

  // Self-referential properties for a top-level window
  parent: { get: function get() {
      return this;
    } },
  top: { get: function get() {
      return this;
    } },

  // We don't support any other windows for now
  length: { value: 0 }, // no frames
  frameElement: { value: null }, // not part of a frame
  opener: { value: null }, // not opened by another window

  // The onload event handler.
  // XXX: need to support a bunch of other event types, too,
  // and have them interoperate with document.body.

  onload: {
    get: function get() {
      return this._getEventHandler("load");
    },
    set: function set(v) {
      this._setEventHandler("load", v);
    }
  },

  // XXX This is a completely broken implementation
  getComputedStyle: { value: function getComputedStyle(elt) {
      return elt.style;
    } }

});

utils.expose(__webpack_require__(81), Window);
utils.expose(__webpack_require__(51), Window);

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = DocumentType;

var Node = __webpack_require__(2);
var Leaf = __webpack_require__(42);
var ChildNode = __webpack_require__(22);

function DocumentType(ownerDocument, name, publicId, systemId) {
  Leaf.call(this);
  this.nodeType = Node.DOCUMENT_TYPE_NODE;
  this.ownerDocument = ownerDocument || null;
  this.name = name;
  this.publicId = publicId || "";
  this.systemId = systemId || "";
}

DocumentType.prototype = Object.create(Leaf.prototype, {
  nodeName: { get: function get() {
      return this.name;
    } },
  nodeValue: {
    get: function get() {
      return null;
    },
    set: function set() {}
  },

  // Utility methods
  clone: { value: function clone() {
      return new DocumentType(this.ownerDocument, this.name, this.publicId, this.systemId);
    } },

  isEqual: { value: function isEqual(n) {
      return this.name === n.name && this.publicId === n.publicId && this.systemId === n.systemId;
    } }
});

Object.defineProperties(DocumentType.prototype, ChildNode);

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = HTMLParser;

var Document = __webpack_require__(16);
var DocumentType = __webpack_require__(27);
var Node = __webpack_require__(2);
var NAMESPACE = __webpack_require__(1).NAMESPACE;
var html = __webpack_require__(24);
var impl = html.elements;

var pushAll = Function.prototype.apply.bind(Array.prototype.push);

/*
 * This file contains an implementation of the HTML parsing algorithm.
 * The algorithm and the implementation are complex because HTML
 * explicitly defines how the parser should behave for all possible
 * valid and invalid inputs.
 *
 * Usage:
 *
 * The file defines a single HTMLParser() function, which dom.js exposes
 * publicly as document.implementation.mozHTMLParser(). This is a
 * factory function, not a constructor.
 *
 * When you call document.implementation.mozHTMLParser(), it returns
 * an object that has parse() and document() methods. To parse HTML text,
 * pass the text (in one or more chunks) to the parse() method.  When
 * you've passed all the text (on the last chunk, or afterward) pass
 * true as the second argument to parse() to tell the parser that there
 * is no more coming. Call document() to get the document object that
 * the parser is parsing into.  You can call this at any time, before
 * or after calling parse().
 *
 * The first argument to mozHTMLParser is the absolute URL of the document.
 *
 * The second argument is optional and is for internal use only.  Pass an
 * element as the fragmentContext to do innerHTML parsing for the
 * element.  To do innerHTML parsing on a document, pass null. Otherwise,
 * omit the 2nd argument. See HTMLElement.innerHTML for an example.  Note
 * that if you pass a context element, the end() method will return an
 * unwrapped document instead of a wrapped one.
 *
 * Implementation details:
 *
 * This is a long file of almost 7000 lines. It is structured as one
 * big function nested within another big function.  The outer
 * function defines a bunch of constant data, utility functions
 * that use that data, and a couple of classes used by the parser.
 * The outer function also defines and returns the
 * inner function. This inner function is the HTMLParser factory
 * function that implements the parser and holds all the parser state
 * as local variables.  The HTMLParser function is quite big because
 * it defines many nested functions that use those local variables.
 *
 * There are three tightly coupled parser stages: a scanner, a
 * tokenizer and a tree builder. In a (possibly misguided) attempt at
 * efficiency, the stages are not implemented as separate classes:
 * everything shares state and is (mostly) implemented in imperative
 * (rather than OO) style.
 *
 * The stages of the parser work like this: When the client code calls
 * the parser's parse() method, the specified string is passed to
 * scanChars(). The scanner loops through that string and passes characters
 * (sometimes one at a time, sometimes in chunks) to the tokenizer stage.
 * The tokenizer groups the characters into tokens: tags, endtags, runs
 * of text, comments, doctype declarations, and the end-of-file (EOF)
 * token.  These tokens are then passed to the tree building stage via
 * the insertToken() function.  The tree building stage builds up the
 * document tree.
 *
 * The tokenizer stage is a finite state machine.  Each state is
 * implemented as a function with a name that ends in "_state".  The
 * initial state is data_state(). The current tokenizer state is stored
 * in the variable 'tokenizer'.  Most state functions expect a single
 * integer argument which represents a single UTF-16 codepoint.  Some
 * states want more characters and set a lookahead property on
 * themselves.  The scanChars() function in the scanner checks for this
 * lookahead property.  If it doesn't exist, then scanChars() just passes
 * the next input character to the current tokenizer state function.
 * Otherwise, scanChars() looks ahead (a given # of characters, or for a
 * matching string, or for a matching regexp) and passes a string of
 * characters to the current tokenizer state function.
 *
 * As a shortcut, certain states of the tokenizer use regular expressions
 * to look ahead in the scanner's input buffer for runs of text, simple
 * tags and attributes.  For well-formed input, these shortcuts skip a
 * lot of state transitions and speed things up a bit.
 *
 * When a tokenizer state function has consumed a complete token, it
 * emits that token, by calling insertToken(), or by calling a utility
 * function that itself calls insertToken().  These tokens are passed to
 * the tree building stage, which is also a state machine.  Like the
 * tokenizer, the tree building states are implemented as functions, and
 * these functions have names that end with _mode (because the HTML spec
 * refers to them as insertion modes). The current insertion mode is held
 * by the 'parser' variable.  Each insertion mode function takes up to 4
 * arguments.  The first is a token type, represented by the constants
 * TAG, ENDTAG, TEXT, COMMENT, DOCTYPE and EOF.  The second argument is
 * the value of the token: the text or comment data, or tagname or
 * doctype.  For tags, the 3rd argument is an array of attributes.  For
 * DOCTYPES it is the optional public id.  For tags, the 4th argument is
 * true if the tag is self-closing. For doctypes, the 4th argument is the
 * optional system id.
 *
 * Search for "***" to find the major sub-divisions in the code.
 */

/***
 * Data prolog.  Lots of constants declared here, including some
 * very large objects.  They're used throughout the code that follows
 */
// Token types for the tree builder.
var EOF = -1;
var TEXT = 1;
var TAG = 2;
var ENDTAG = 3;
var COMMENT = 4;
var DOCTYPE = 5;

// A re-usable empty array
var NOATTRS = [];

// These DTD public ids put the browser in quirks mode
var quirkyPublicIds = /^HTML$|^-\/\/W3O\/\/DTD W3 HTML Strict 3\.0\/\/EN\/\/$|^-\/W3C\/DTD HTML 4\.0 Transitional\/EN$|^\+\/\/Silmaril\/\/dtd html Pro v0r11 19970101\/\/|^-\/\/AdvaSoft Ltd\/\/DTD HTML 3\.0 asWedit \+ extensions\/\/|^-\/\/AS\/\/DTD HTML 3\.0 asWedit \+ extensions\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Level 1\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Level 2\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict Level 1\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict Level 2\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict\/\/|^-\/\/IETF\/\/DTD HTML 2\.0\/\/|^-\/\/IETF\/\/DTD HTML 2\.1E\/\/|^-\/\/IETF\/\/DTD HTML 3\.0\/\/|^-\/\/IETF\/\/DTD HTML 3\.2 Final\/\/|^-\/\/IETF\/\/DTD HTML 3\.2\/\/|^-\/\/IETF\/\/DTD HTML 3\/\/|^-\/\/IETF\/\/DTD HTML Level 0\/\/|^-\/\/IETF\/\/DTD HTML Level 1\/\/|^-\/\/IETF\/\/DTD HTML Level 2\/\/|^-\/\/IETF\/\/DTD HTML Level 3\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 0\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 1\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 2\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 3\/\/|^-\/\/IETF\/\/DTD HTML Strict\/\/|^-\/\/IETF\/\/DTD HTML\/\/|^-\/\/Metrius\/\/DTD Metrius Presentational\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 HTML Strict\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 HTML\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 Tables\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 HTML Strict\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 HTML\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 Tables\/\/|^-\/\/Netscape Comm\. Corp\.\/\/DTD HTML\/\/|^-\/\/Netscape Comm\. Corp\.\/\/DTD Strict HTML\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML 2\.0\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML Extended 1\.0\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML Extended Relaxed 1\.0\/\/|^-\/\/SoftQuad Software\/\/DTD HoTMetaL PRO 6\.0::19990601::extensions to HTML 4\.0\/\/|^-\/\/SoftQuad\/\/DTD HoTMetaL PRO 4\.0::19971010::extensions to HTML 4\.0\/\/|^-\/\/Spyglass\/\/DTD HTML 2\.0 Extended\/\/|^-\/\/SQ\/\/DTD HTML 2\.0 HoTMetaL \+ extensions\/\/|^-\/\/Sun Microsystems Corp\.\/\/DTD HotJava HTML\/\/|^-\/\/Sun Microsystems Corp\.\/\/DTD HotJava Strict HTML\/\/|^-\/\/W3C\/\/DTD HTML 3 1995-03-24\/\/|^-\/\/W3C\/\/DTD HTML 3\.2 Draft\/\/|^-\/\/W3C\/\/DTD HTML 3\.2 Final\/\/|^-\/\/W3C\/\/DTD HTML 3\.2\/\/|^-\/\/W3C\/\/DTD HTML 3\.2S Draft\/\/|^-\/\/W3C\/\/DTD HTML 4\.0 Frameset\/\/|^-\/\/W3C\/\/DTD HTML 4\.0 Transitional\/\/|^-\/\/W3C\/\/DTD HTML Experimental 19960712\/\/|^-\/\/W3C\/\/DTD HTML Experimental 970421\/\/|^-\/\/W3C\/\/DTD W3 HTML\/\/|^-\/\/W3O\/\/DTD W3 HTML 3\.0\/\/|^-\/\/WebTechs\/\/DTD Mozilla HTML 2\.0\/\/|^-\/\/WebTechs\/\/DTD Mozilla HTML\/\//i;

var quirkySystemId = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";

var conditionallyQuirkyPublicIds = /^-\/\/W3C\/\/DTD HTML 4\.01 Frameset\/\/|^-\/\/W3C\/\/DTD HTML 4\.01 Transitional\/\//i;

// These DTD public ids put the browser in limited quirks mode
var limitedQuirkyPublicIds = /^-\/\/W3C\/\/DTD XHTML 1\.0 Frameset\/\/|^-\/\/W3C\/\/DTD XHTML 1\.0 Transitional\/\//i;

// Element sets below. See the isA() function for a way to test
// whether an element is a member of a set
var specialSet = Object.create(null);
specialSet[NAMESPACE.HTML] = {
  __proto__: null,
  "address": true, "applet": true, "area": true, "article": true,
  "aside": true, "base": true, "basefont": true, "bgsound": true,
  "blockquote": true, "body": true, "br": true, "button": true,
  "caption": true, "center": true, "col": true, "colgroup": true,
  "dd": true, "details": true, "dir": true,
  "div": true, "dl": true, "dt": true, "embed": true,
  "fieldset": true, "figcaption": true, "figure": true, "footer": true,
  "form": true, "frame": true, "frameset": true, "h1": true,
  "h2": true, "h3": true, "h4": true, "h5": true,
  "h6": true, "head": true, "header": true, "hgroup": true,
  "hr": true, "html": true, "iframe": true, "img": true,
  "input": true, "li": true, "link": true,
  "listing": true, "main": true, "marquee": true, "menu": true, "meta": true,
  "nav": true, "noembed": true, "noframes": true, "noscript": true,
  "object": true, "ol": true, "p": true, "param": true,
  "plaintext": true, "pre": true, "script": true, "section": true,
  "select": true, "source": true, "style": true, "summary": true, "table": true,
  "tbody": true, "td": true, "template": true, "textarea": true, "tfoot": true,
  "th": true, "thead": true, "title": true, "tr": true, "track": true,
  // Note that "xmp" was removed from the "special" set in the latest
  // spec, apparently by accident; see
  // https://github.com/whatwg/html/pull/1919
  "ul": true, "wbr": true, "xmp": true
};
specialSet[NAMESPACE.SVG] = {
  __proto__: null,
  "foreignObject": true, "desc": true, "title": true
};
specialSet[NAMESPACE.MATHML] = {
  __proto__: null,
  "mi": true, "mo": true, "mn": true, "ms": true,
  "mtext": true, "annotation-xml": true
};

// The set of address, div, and p HTML tags
var addressdivpSet = Object.create(null);
addressdivpSet[NAMESPACE.HTML] = {
  __proto__: null,
  "address": true, "div": true, "p": true
};

var dddtSet = Object.create(null);
dddtSet[NAMESPACE.HTML] = {
  __proto__: null,
  "dd": true, "dt": true
};

var tablesectionrowSet = Object.create(null);
tablesectionrowSet[NAMESPACE.HTML] = {
  __proto__: null,
  "table": true, "thead": true, "tbody": true, "tfoot": true, "tr": true
};

var impliedEndTagsSet = Object.create(null);
impliedEndTagsSet[NAMESPACE.HTML] = {
  __proto__: null,
  "dd": true, "dt": true, "li": true, "menuitem": true, "optgroup": true,
  "option": true, "p": true, "rb": true, "rp": true, "rt": true, "rtc": true
};

var thoroughImpliedEndTagsSet = Object.create(null);
thoroughImpliedEndTagsSet[NAMESPACE.HTML] = {
  __proto__: null,
  "caption": true, "colgroup": true, "dd": true, "dt": true, "li": true,
  "optgroup": true, "option": true, "p": true, "rb": true, "rp": true,
  "rt": true, "rtc": true, "tbody": true, "td": true, "tfoot": true,
  "th": true, "thead": true, "tr": true
};

var tableContextSet = Object.create(null);
tableContextSet[NAMESPACE.HTML] = {
  __proto__: null,
  "table": true, "template": true, "html": true
};

var tableBodyContextSet = Object.create(null);
tableBodyContextSet[NAMESPACE.HTML] = {
  __proto__: null,
  "tbody": true, "tfoot": true, "thead": true, "template": true, "html": true
};

var tableRowContextSet = Object.create(null);
tableRowContextSet[NAMESPACE.HTML] = {
  __proto__: null,
  "tr": true, "template": true, "html": true
};

// See http://www.w3.org/TR/html5/forms.html#form-associated-element
var formassociatedSet = Object.create(null);
formassociatedSet[NAMESPACE.HTML] = {
  __proto__: null,
  "button": true, "fieldset": true, "input": true, "keygen": true,
  "object": true, "output": true, "select": true, "textarea": true,
  "img": true
};

var inScopeSet = Object.create(null);
inScopeSet[NAMESPACE.HTML] = {
  __proto__: null,
  "applet": true, "caption": true, "html": true, "table": true,
  "td": true, "th": true, "marquee": true, "object": true,
  "template": true
};
inScopeSet[NAMESPACE.MATHML] = {
  __proto__: null,
  "mi": true, "mo": true, "mn": true, "ms": true,
  "mtext": true, "annotation-xml": true
};
inScopeSet[NAMESPACE.SVG] = {
  __proto__: null,
  "foreignObject": true, "desc": true, "title": true
};

var inListItemScopeSet = Object.create(inScopeSet);
inListItemScopeSet[NAMESPACE.HTML] = Object.create(inScopeSet[NAMESPACE.HTML]);
inListItemScopeSet[NAMESPACE.HTML].ol = true;
inListItemScopeSet[NAMESPACE.HTML].ul = true;

var inButtonScopeSet = Object.create(inScopeSet);
inButtonScopeSet[NAMESPACE.HTML] = Object.create(inScopeSet[NAMESPACE.HTML]);
inButtonScopeSet[NAMESPACE.HTML].button = true;

var inTableScopeSet = Object.create(null);
inTableScopeSet[NAMESPACE.HTML] = {
  __proto__: null,
  "html": true, "table": true, "template": true
};

// The set of elements for select scope is the everything *except* these
var invertedSelectScopeSet = Object.create(null);
invertedSelectScopeSet[NAMESPACE.HTML] = {
  __proto__: null,
  "optgroup": true, "option": true
};

var mathmlTextIntegrationPointSet = Object.create(null);
mathmlTextIntegrationPointSet[NAMESPACE.MATHML] = {
  __proto__: null,
  mi: true,
  mo: true,
  mn: true,
  ms: true,
  mtext: true
};

var htmlIntegrationPointSet = Object.create(null);
htmlIntegrationPointSet[NAMESPACE.SVG] = {
  __proto__: null,
  foreignObject: true,
  desc: true,
  title: true
};

var foreignAttributes = {
  __proto__: null,
  "xlink:actuate": NAMESPACE.XLINK, "xlink:arcrole": NAMESPACE.XLINK,
  "xlink:href": NAMESPACE.XLINK, "xlink:role": NAMESPACE.XLINK,
  "xlink:show": NAMESPACE.XLINK, "xlink:title": NAMESPACE.XLINK,
  "xlink:type": NAMESPACE.XLINK, "xml:base": NAMESPACE.XML,
  "xml:lang": NAMESPACE.XML, "xml:space": NAMESPACE.XML,
  "xmlns": NAMESPACE.XMLNS, "xmlns:xlink": NAMESPACE.XMLNS
};

// Lowercase to mixed case mapping for SVG attributes and tagnames
var svgAttrAdjustments = {
  __proto__: null,
  attributename: "attributeName", attributetype: "attributeType",
  basefrequency: "baseFrequency", baseprofile: "baseProfile",
  calcmode: "calcMode", clippathunits: "clipPathUnits",
  diffuseconstant: "diffuseConstant",
  edgemode: "edgeMode",
  filterunits: "filterUnits",
  glyphref: "glyphRef", gradienttransform: "gradientTransform",
  gradientunits: "gradientUnits", kernelmatrix: "kernelMatrix",
  kernelunitlength: "kernelUnitLength", keypoints: "keyPoints",
  keysplines: "keySplines", keytimes: "keyTimes",
  lengthadjust: "lengthAdjust", limitingconeangle: "limitingConeAngle",
  markerheight: "markerHeight", markerunits: "markerUnits",
  markerwidth: "markerWidth", maskcontentunits: "maskContentUnits",
  maskunits: "maskUnits", numoctaves: "numOctaves",
  pathlength: "pathLength", patterncontentunits: "patternContentUnits",
  patterntransform: "patternTransform", patternunits: "patternUnits",
  pointsatx: "pointsAtX", pointsaty: "pointsAtY",
  pointsatz: "pointsAtZ", preservealpha: "preserveAlpha",
  preserveaspectratio: "preserveAspectRatio",
  primitiveunits: "primitiveUnits", refx: "refX",
  refy: "refY", repeatcount: "repeatCount",
  repeatdur: "repeatDur", requiredextensions: "requiredExtensions",
  requiredfeatures: "requiredFeatures",
  specularconstant: "specularConstant",
  specularexponent: "specularExponent", spreadmethod: "spreadMethod",
  startoffset: "startOffset", stddeviation: "stdDeviation",
  stitchtiles: "stitchTiles", surfacescale: "surfaceScale",
  systemlanguage: "systemLanguage", tablevalues: "tableValues",
  targetx: "targetX", targety: "targetY",
  textlength: "textLength", viewbox: "viewBox",
  viewtarget: "viewTarget", xchannelselector: "xChannelSelector",
  ychannelselector: "yChannelSelector", zoomandpan: "zoomAndPan"
};

var svgTagNameAdjustments = {
  __proto__: null,
  altglyph: "altGlyph", altglyphdef: "altGlyphDef",
  altglyphitem: "altGlyphItem", animatecolor: "animateColor",
  animatemotion: "animateMotion", animatetransform: "animateTransform",
  clippath: "clipPath", feblend: "feBlend",
  fecolormatrix: "feColorMatrix",
  fecomponenttransfer: "feComponentTransfer", fecomposite: "feComposite",
  feconvolvematrix: "feConvolveMatrix",
  fediffuselighting: "feDiffuseLighting",
  fedisplacementmap: "feDisplacementMap",
  fedistantlight: "feDistantLight", feflood: "feFlood",
  fefunca: "feFuncA", fefuncb: "feFuncB",
  fefuncg: "feFuncG", fefuncr: "feFuncR",
  fegaussianblur: "feGaussianBlur", feimage: "feImage",
  femerge: "feMerge", femergenode: "feMergeNode",
  femorphology: "feMorphology", feoffset: "feOffset",
  fepointlight: "fePointLight", fespecularlighting: "feSpecularLighting",
  fespotlight: "feSpotLight", fetile: "feTile",
  feturbulence: "feTurbulence", foreignobject: "foreignObject",
  glyphref: "glyphRef", lineargradient: "linearGradient",
  radialgradient: "radialGradient", textpath: "textPath"
};

// Data for parsing numeric and named character references
// These next 3 objects are direct translations of tables
// in the HTML spec into JavaScript object format
var numericCharRefReplacements = {
  __proto__: null,
  0x00: 0xFFFD, 0x80: 0x20AC, 0x82: 0x201A, 0x83: 0x0192, 0x84: 0x201E,
  0x85: 0x2026, 0x86: 0x2020, 0x87: 0x2021, 0x88: 0x02C6, 0x89: 0x2030,
  0x8A: 0x0160, 0x8B: 0x2039, 0x8C: 0x0152, 0x8E: 0x017D, 0x91: 0x2018,
  0x92: 0x2019, 0x93: 0x201C, 0x94: 0x201D, 0x95: 0x2022, 0x96: 0x2013,
  0x97: 0x2014, 0x98: 0x02DC, 0x99: 0x2122, 0x9A: 0x0161, 0x9B: 0x203A,
  0x9C: 0x0153, 0x9E: 0x017E, 0x9F: 0x0178
};

/*
 * This table is generated with test/tools/update-entities.js
 */
var namedCharRefs = {
  __proto__: null,
  "AElig": 0xc6, "AElig;": 0xc6,
  "AMP": 0x26, "AMP;": 0x26,
  "Aacute": 0xc1, "Aacute;": 0xc1,
  "Abreve;": 0x102, "Acirc": 0xc2,
  "Acirc;": 0xc2, "Acy;": 0x410,
  "Afr;": [0xd835, 0xdd04], "Agrave": 0xc0,
  "Agrave;": 0xc0, "Alpha;": 0x391,
  "Amacr;": 0x100, "And;": 0x2a53,
  "Aogon;": 0x104, "Aopf;": [0xd835, 0xdd38],
  "ApplyFunction;": 0x2061, "Aring": 0xc5,
  "Aring;": 0xc5, "Ascr;": [0xd835, 0xdc9c],
  "Assign;": 0x2254, "Atilde": 0xc3,
  "Atilde;": 0xc3, "Auml": 0xc4,
  "Auml;": 0xc4, "Backslash;": 0x2216,
  "Barv;": 0x2ae7, "Barwed;": 0x2306,
  "Bcy;": 0x411, "Because;": 0x2235,
  "Bernoullis;": 0x212c, "Beta;": 0x392,
  "Bfr;": [0xd835, 0xdd05], "Bopf;": [0xd835, 0xdd39],
  "Breve;": 0x2d8, "Bscr;": 0x212c,
  "Bumpeq;": 0x224e, "CHcy;": 0x427,
  "COPY": 0xa9, "COPY;": 0xa9,
  "Cacute;": 0x106, "Cap;": 0x22d2,
  "CapitalDifferentialD;": 0x2145, "Cayleys;": 0x212d,
  "Ccaron;": 0x10c, "Ccedil": 0xc7,
  "Ccedil;": 0xc7, "Ccirc;": 0x108,
  "Cconint;": 0x2230, "Cdot;": 0x10a,
  "Cedilla;": 0xb8, "CenterDot;": 0xb7,
  "Cfr;": 0x212d, "Chi;": 0x3a7,
  "CircleDot;": 0x2299, "CircleMinus;": 0x2296,
  "CirclePlus;": 0x2295, "CircleTimes;": 0x2297,
  "ClockwiseContourIntegral;": 0x2232, "CloseCurlyDoubleQuote;": 0x201d,
  "CloseCurlyQuote;": 0x2019, "Colon;": 0x2237,
  "Colone;": 0x2a74, "Congruent;": 0x2261,
  "Conint;": 0x222f, "ContourIntegral;": 0x222e,
  "Copf;": 0x2102, "Coproduct;": 0x2210,
  "CounterClockwiseContourIntegral;": 0x2233, "Cross;": 0x2a2f,
  "Cscr;": [0xd835, 0xdc9e], "Cup;": 0x22d3,
  "CupCap;": 0x224d, "DD;": 0x2145,
  "DDotrahd;": 0x2911, "DJcy;": 0x402,
  "DScy;": 0x405, "DZcy;": 0x40f,
  "Dagger;": 0x2021, "Darr;": 0x21a1,
  "Dashv;": 0x2ae4, "Dcaron;": 0x10e,
  "Dcy;": 0x414, "Del;": 0x2207,
  "Delta;": 0x394, "Dfr;": [0xd835, 0xdd07],
  "DiacriticalAcute;": 0xb4, "DiacriticalDot;": 0x2d9,
  "DiacriticalDoubleAcute;": 0x2dd, "DiacriticalGrave;": 0x60,
  "DiacriticalTilde;": 0x2dc, "Diamond;": 0x22c4,
  "DifferentialD;": 0x2146, "Dopf;": [0xd835, 0xdd3b],
  "Dot;": 0xa8, "DotDot;": 0x20dc,
  "DotEqual;": 0x2250, "DoubleContourIntegral;": 0x222f,
  "DoubleDot;": 0xa8, "DoubleDownArrow;": 0x21d3,
  "DoubleLeftArrow;": 0x21d0, "DoubleLeftRightArrow;": 0x21d4,
  "DoubleLeftTee;": 0x2ae4, "DoubleLongLeftArrow;": 0x27f8,
  "DoubleLongLeftRightArrow;": 0x27fa, "DoubleLongRightArrow;": 0x27f9,
  "DoubleRightArrow;": 0x21d2, "DoubleRightTee;": 0x22a8,
  "DoubleUpArrow;": 0x21d1, "DoubleUpDownArrow;": 0x21d5,
  "DoubleVerticalBar;": 0x2225, "DownArrow;": 0x2193,
  "DownArrowBar;": 0x2913, "DownArrowUpArrow;": 0x21f5,
  "DownBreve;": 0x311, "DownLeftRightVector;": 0x2950,
  "DownLeftTeeVector;": 0x295e, "DownLeftVector;": 0x21bd,
  "DownLeftVectorBar;": 0x2956, "DownRightTeeVector;": 0x295f,
  "DownRightVector;": 0x21c1, "DownRightVectorBar;": 0x2957,
  "DownTee;": 0x22a4, "DownTeeArrow;": 0x21a7,
  "Downarrow;": 0x21d3, "Dscr;": [0xd835, 0xdc9f],
  "Dstrok;": 0x110, "ENG;": 0x14a,
  "ETH": 0xd0, "ETH;": 0xd0,
  "Eacute": 0xc9, "Eacute;": 0xc9,
  "Ecaron;": 0x11a, "Ecirc": 0xca,
  "Ecirc;": 0xca, "Ecy;": 0x42d,
  "Edot;": 0x116, "Efr;": [0xd835, 0xdd08],
  "Egrave": 0xc8, "Egrave;": 0xc8,
  "Element;": 0x2208, "Emacr;": 0x112,
  "EmptySmallSquare;": 0x25fb, "EmptyVerySmallSquare;": 0x25ab,
  "Eogon;": 0x118, "Eopf;": [0xd835, 0xdd3c],
  "Epsilon;": 0x395, "Equal;": 0x2a75,
  "EqualTilde;": 0x2242, "Equilibrium;": 0x21cc,
  "Escr;": 0x2130, "Esim;": 0x2a73,
  "Eta;": 0x397, "Euml": 0xcb,
  "Euml;": 0xcb, "Exists;": 0x2203,
  "ExponentialE;": 0x2147, "Fcy;": 0x424,
  "Ffr;": [0xd835, 0xdd09], "FilledSmallSquare;": 0x25fc,
  "FilledVerySmallSquare;": 0x25aa, "Fopf;": [0xd835, 0xdd3d],
  "ForAll;": 0x2200, "Fouriertrf;": 0x2131,
  "Fscr;": 0x2131, "GJcy;": 0x403,
  "GT": 0x3e, "GT;": 0x3e,
  "Gamma;": 0x393, "Gammad;": 0x3dc,
  "Gbreve;": 0x11e, "Gcedil;": 0x122,
  "Gcirc;": 0x11c, "Gcy;": 0x413,
  "Gdot;": 0x120, "Gfr;": [0xd835, 0xdd0a],
  "Gg;": 0x22d9, "Gopf;": [0xd835, 0xdd3e],
  "GreaterEqual;": 0x2265, "GreaterEqualLess;": 0x22db,
  "GreaterFullEqual;": 0x2267, "GreaterGreater;": 0x2aa2,
  "GreaterLess;": 0x2277, "GreaterSlantEqual;": 0x2a7e,
  "GreaterTilde;": 0x2273, "Gscr;": [0xd835, 0xdca2],
  "Gt;": 0x226b, "HARDcy;": 0x42a,
  "Hacek;": 0x2c7, "Hat;": 0x5e,
  "Hcirc;": 0x124, "Hfr;": 0x210c,
  "HilbertSpace;": 0x210b, "Hopf;": 0x210d,
  "HorizontalLine;": 0x2500, "Hscr;": 0x210b,
  "Hstrok;": 0x126, "HumpDownHump;": 0x224e,
  "HumpEqual;": 0x224f, "IEcy;": 0x415,
  "IJlig;": 0x132, "IOcy;": 0x401,
  "Iacute": 0xcd, "Iacute;": 0xcd,
  "Icirc": 0xce, "Icirc;": 0xce,
  "Icy;": 0x418, "Idot;": 0x130,
  "Ifr;": 0x2111, "Igrave": 0xcc,
  "Igrave;": 0xcc, "Im;": 0x2111,
  "Imacr;": 0x12a, "ImaginaryI;": 0x2148,
  "Implies;": 0x21d2, "Int;": 0x222c,
  "Integral;": 0x222b, "Intersection;": 0x22c2,
  "InvisibleComma;": 0x2063, "InvisibleTimes;": 0x2062,
  "Iogon;": 0x12e, "Iopf;": [0xd835, 0xdd40],
  "Iota;": 0x399, "Iscr;": 0x2110,
  "Itilde;": 0x128, "Iukcy;": 0x406,
  "Iuml": 0xcf, "Iuml;": 0xcf,
  "Jcirc;": 0x134, "Jcy;": 0x419,
  "Jfr;": [0xd835, 0xdd0d], "Jopf;": [0xd835, 0xdd41],
  "Jscr;": [0xd835, 0xdca5], "Jsercy;": 0x408,
  "Jukcy;": 0x404, "KHcy;": 0x425,
  "KJcy;": 0x40c, "Kappa;": 0x39a,
  "Kcedil;": 0x136, "Kcy;": 0x41a,
  "Kfr;": [0xd835, 0xdd0e], "Kopf;": [0xd835, 0xdd42],
  "Kscr;": [0xd835, 0xdca6], "LJcy;": 0x409,
  "LT": 0x3c, "LT;": 0x3c,
  "Lacute;": 0x139, "Lambda;": 0x39b,
  "Lang;": 0x27ea, "Laplacetrf;": 0x2112,
  "Larr;": 0x219e, "Lcaron;": 0x13d,
  "Lcedil;": 0x13b, "Lcy;": 0x41b,
  "LeftAngleBracket;": 0x27e8, "LeftArrow;": 0x2190,
  "LeftArrowBar;": 0x21e4, "LeftArrowRightArrow;": 0x21c6,
  "LeftCeiling;": 0x2308, "LeftDoubleBracket;": 0x27e6,
  "LeftDownTeeVector;": 0x2961, "LeftDownVector;": 0x21c3,
  "LeftDownVectorBar;": 0x2959, "LeftFloor;": 0x230a,
  "LeftRightArrow;": 0x2194, "LeftRightVector;": 0x294e,
  "LeftTee;": 0x22a3, "LeftTeeArrow;": 0x21a4,
  "LeftTeeVector;": 0x295a, "LeftTriangle;": 0x22b2,
  "LeftTriangleBar;": 0x29cf, "LeftTriangleEqual;": 0x22b4,
  "LeftUpDownVector;": 0x2951, "LeftUpTeeVector;": 0x2960,
  "LeftUpVector;": 0x21bf, "LeftUpVectorBar;": 0x2958,
  "LeftVector;": 0x21bc, "LeftVectorBar;": 0x2952,
  "Leftarrow;": 0x21d0, "Leftrightarrow;": 0x21d4,
  "LessEqualGreater;": 0x22da, "LessFullEqual;": 0x2266,
  "LessGreater;": 0x2276, "LessLess;": 0x2aa1,
  "LessSlantEqual;": 0x2a7d, "LessTilde;": 0x2272,
  "Lfr;": [0xd835, 0xdd0f], "Ll;": 0x22d8,
  "Lleftarrow;": 0x21da, "Lmidot;": 0x13f,
  "LongLeftArrow;": 0x27f5, "LongLeftRightArrow;": 0x27f7,
  "LongRightArrow;": 0x27f6, "Longleftarrow;": 0x27f8,
  "Longleftrightarrow;": 0x27fa, "Longrightarrow;": 0x27f9,
  "Lopf;": [0xd835, 0xdd43], "LowerLeftArrow;": 0x2199,
  "LowerRightArrow;": 0x2198, "Lscr;": 0x2112,
  "Lsh;": 0x21b0, "Lstrok;": 0x141,
  "Lt;": 0x226a, "Map;": 0x2905,
  "Mcy;": 0x41c, "MediumSpace;": 0x205f,
  "Mellintrf;": 0x2133, "Mfr;": [0xd835, 0xdd10],
  "MinusPlus;": 0x2213, "Mopf;": [0xd835, 0xdd44],
  "Mscr;": 0x2133, "Mu;": 0x39c,
  "NJcy;": 0x40a, "Nacute;": 0x143,
  "Ncaron;": 0x147, "Ncedil;": 0x145,
  "Ncy;": 0x41d, "NegativeMediumSpace;": 0x200b,
  "NegativeThickSpace;": 0x200b, "NegativeThinSpace;": 0x200b,
  "NegativeVeryThinSpace;": 0x200b, "NestedGreaterGreater;": 0x226b,
  "NestedLessLess;": 0x226a, "NewLine;": 0xa,
  "Nfr;": [0xd835, 0xdd11], "NoBreak;": 0x2060,
  "NonBreakingSpace;": 0xa0, "Nopf;": 0x2115,
  "Not;": 0x2aec, "NotCongruent;": 0x2262,
  "NotCupCap;": 0x226d, "NotDoubleVerticalBar;": 0x2226,
  "NotElement;": 0x2209, "NotEqual;": 0x2260,
  "NotEqualTilde;": [0x2242, 0x338], "NotExists;": 0x2204,
  "NotGreater;": 0x226f, "NotGreaterEqual;": 0x2271,
  "NotGreaterFullEqual;": [0x2267, 0x338], "NotGreaterGreater;": [0x226b, 0x338],
  "NotGreaterLess;": 0x2279, "NotGreaterSlantEqual;": [0x2a7e, 0x338],
  "NotGreaterTilde;": 0x2275, "NotHumpDownHump;": [0x224e, 0x338],
  "NotHumpEqual;": [0x224f, 0x338], "NotLeftTriangle;": 0x22ea,
  "NotLeftTriangleBar;": [0x29cf, 0x338], "NotLeftTriangleEqual;": 0x22ec,
  "NotLess;": 0x226e, "NotLessEqual;": 0x2270,
  "NotLessGreater;": 0x2278, "NotLessLess;": [0x226a, 0x338],
  "NotLessSlantEqual;": [0x2a7d, 0x338], "NotLessTilde;": 0x2274,
  "NotNestedGreaterGreater;": [0x2aa2, 0x338], "NotNestedLessLess;": [0x2aa1, 0x338],
  "NotPrecedes;": 0x2280, "NotPrecedesEqual;": [0x2aaf, 0x338],
  "NotPrecedesSlantEqual;": 0x22e0, "NotReverseElement;": 0x220c,
  "NotRightTriangle;": 0x22eb, "NotRightTriangleBar;": [0x29d0, 0x338],
  "NotRightTriangleEqual;": 0x22ed, "NotSquareSubset;": [0x228f, 0x338],
  "NotSquareSubsetEqual;": 0x22e2, "NotSquareSuperset;": [0x2290, 0x338],
  "NotSquareSupersetEqual;": 0x22e3, "NotSubset;": [0x2282, 0x20d2],
  "NotSubsetEqual;": 0x2288, "NotSucceeds;": 0x2281,
  "NotSucceedsEqual;": [0x2ab0, 0x338], "NotSucceedsSlantEqual;": 0x22e1,
  "NotSucceedsTilde;": [0x227f, 0x338], "NotSuperset;": [0x2283, 0x20d2],
  "NotSupersetEqual;": 0x2289, "NotTilde;": 0x2241,
  "NotTildeEqual;": 0x2244, "NotTildeFullEqual;": 0x2247,
  "NotTildeTilde;": 0x2249, "NotVerticalBar;": 0x2224,
  "Nscr;": [0xd835, 0xdca9], "Ntilde": 0xd1,
  "Ntilde;": 0xd1, "Nu;": 0x39d,
  "OElig;": 0x152, "Oacute": 0xd3,
  "Oacute;": 0xd3, "Ocirc": 0xd4,
  "Ocirc;": 0xd4, "Ocy;": 0x41e,
  "Odblac;": 0x150, "Ofr;": [0xd835, 0xdd12],
  "Ograve": 0xd2, "Ograve;": 0xd2,
  "Omacr;": 0x14c, "Omega;": 0x3a9,
  "Omicron;": 0x39f, "Oopf;": [0xd835, 0xdd46],
  "OpenCurlyDoubleQuote;": 0x201c, "OpenCurlyQuote;": 0x2018,
  "Or;": 0x2a54, "Oscr;": [0xd835, 0xdcaa],
  "Oslash": 0xd8, "Oslash;": 0xd8,
  "Otilde": 0xd5, "Otilde;": 0xd5,
  "Otimes;": 0x2a37, "Ouml": 0xd6,
  "Ouml;": 0xd6, "OverBar;": 0x203e,
  "OverBrace;": 0x23de, "OverBracket;": 0x23b4,
  "OverParenthesis;": 0x23dc, "PartialD;": 0x2202,
  "Pcy;": 0x41f, "Pfr;": [0xd835, 0xdd13],
  "Phi;": 0x3a6, "Pi;": 0x3a0,
  "PlusMinus;": 0xb1, "Poincareplane;": 0x210c,
  "Popf;": 0x2119, "Pr;": 0x2abb,
  "Precedes;": 0x227a, "PrecedesEqual;": 0x2aaf,
  "PrecedesSlantEqual;": 0x227c, "PrecedesTilde;": 0x227e,
  "Prime;": 0x2033, "Product;": 0x220f,
  "Proportion;": 0x2237, "Proportional;": 0x221d,
  "Pscr;": [0xd835, 0xdcab], "Psi;": 0x3a8,
  "QUOT": 0x22, "QUOT;": 0x22,
  "Qfr;": [0xd835, 0xdd14], "Qopf;": 0x211a,
  "Qscr;": [0xd835, 0xdcac], "RBarr;": 0x2910,
  "REG": 0xae, "REG;": 0xae,
  "Racute;": 0x154, "Rang;": 0x27eb,
  "Rarr;": 0x21a0, "Rarrtl;": 0x2916,
  "Rcaron;": 0x158, "Rcedil;": 0x156,
  "Rcy;": 0x420, "Re;": 0x211c,
  "ReverseElement;": 0x220b, "ReverseEquilibrium;": 0x21cb,
  "ReverseUpEquilibrium;": 0x296f, "Rfr;": 0x211c,
  "Rho;": 0x3a1, "RightAngleBracket;": 0x27e9,
  "RightArrow;": 0x2192, "RightArrowBar;": 0x21e5,
  "RightArrowLeftArrow;": 0x21c4, "RightCeiling;": 0x2309,
  "RightDoubleBracket;": 0x27e7, "RightDownTeeVector;": 0x295d,
  "RightDownVector;": 0x21c2, "RightDownVectorBar;": 0x2955,
  "RightFloor;": 0x230b, "RightTee;": 0x22a2,
  "RightTeeArrow;": 0x21a6, "RightTeeVector;": 0x295b,
  "RightTriangle;": 0x22b3, "RightTriangleBar;": 0x29d0,
  "RightTriangleEqual;": 0x22b5, "RightUpDownVector;": 0x294f,
  "RightUpTeeVector;": 0x295c, "RightUpVector;": 0x21be,
  "RightUpVectorBar;": 0x2954, "RightVector;": 0x21c0,
  "RightVectorBar;": 0x2953, "Rightarrow;": 0x21d2,
  "Ropf;": 0x211d, "RoundImplies;": 0x2970,
  "Rrightarrow;": 0x21db, "Rscr;": 0x211b,
  "Rsh;": 0x21b1, "RuleDelayed;": 0x29f4,
  "SHCHcy;": 0x429, "SHcy;": 0x428,
  "SOFTcy;": 0x42c, "Sacute;": 0x15a,
  "Sc;": 0x2abc, "Scaron;": 0x160,
  "Scedil;": 0x15e, "Scirc;": 0x15c,
  "Scy;": 0x421, "Sfr;": [0xd835, 0xdd16],
  "ShortDownArrow;": 0x2193, "ShortLeftArrow;": 0x2190,
  "ShortRightArrow;": 0x2192, "ShortUpArrow;": 0x2191,
  "Sigma;": 0x3a3, "SmallCircle;": 0x2218,
  "Sopf;": [0xd835, 0xdd4a], "Sqrt;": 0x221a,
  "Square;": 0x25a1, "SquareIntersection;": 0x2293,
  "SquareSubset;": 0x228f, "SquareSubsetEqual;": 0x2291,
  "SquareSuperset;": 0x2290, "SquareSupersetEqual;": 0x2292,
  "SquareUnion;": 0x2294, "Sscr;": [0xd835, 0xdcae],
  "Star;": 0x22c6, "Sub;": 0x22d0,
  "Subset;": 0x22d0, "SubsetEqual;": 0x2286,
  "Succeeds;": 0x227b, "SucceedsEqual;": 0x2ab0,
  "SucceedsSlantEqual;": 0x227d, "SucceedsTilde;": 0x227f,
  "SuchThat;": 0x220b, "Sum;": 0x2211,
  "Sup;": 0x22d1, "Superset;": 0x2283,
  "SupersetEqual;": 0x2287, "Supset;": 0x22d1,
  "THORN": 0xde, "THORN;": 0xde,
  "TRADE;": 0x2122, "TSHcy;": 0x40b,
  "TScy;": 0x426, "Tab;": 0x9,
  "Tau;": 0x3a4, "Tcaron;": 0x164,
  "Tcedil;": 0x162, "Tcy;": 0x422,
  "Tfr;": [0xd835, 0xdd17], "Therefore;": 0x2234,
  "Theta;": 0x398, "ThickSpace;": [0x205f, 0x200a],
  "ThinSpace;": 0x2009, "Tilde;": 0x223c,
  "TildeEqual;": 0x2243, "TildeFullEqual;": 0x2245,
  "TildeTilde;": 0x2248, "Topf;": [0xd835, 0xdd4b],
  "TripleDot;": 0x20db, "Tscr;": [0xd835, 0xdcaf],
  "Tstrok;": 0x166, "Uacute": 0xda,
  "Uacute;": 0xda, "Uarr;": 0x219f,
  "Uarrocir;": 0x2949, "Ubrcy;": 0x40e,
  "Ubreve;": 0x16c, "Ucirc": 0xdb,
  "Ucirc;": 0xdb, "Ucy;": 0x423,
  "Udblac;": 0x170, "Ufr;": [0xd835, 0xdd18],
  "Ugrave": 0xd9, "Ugrave;": 0xd9,
  "Umacr;": 0x16a, "UnderBar;": 0x5f,
  "UnderBrace;": 0x23df, "UnderBracket;": 0x23b5,
  "UnderParenthesis;": 0x23dd, "Union;": 0x22c3,
  "UnionPlus;": 0x228e, "Uogon;": 0x172,
  "Uopf;": [0xd835, 0xdd4c], "UpArrow;": 0x2191,
  "UpArrowBar;": 0x2912, "UpArrowDownArrow;": 0x21c5,
  "UpDownArrow;": 0x2195, "UpEquilibrium;": 0x296e,
  "UpTee;": 0x22a5, "UpTeeArrow;": 0x21a5,
  "Uparrow;": 0x21d1, "Updownarrow;": 0x21d5,
  "UpperLeftArrow;": 0x2196, "UpperRightArrow;": 0x2197,
  "Upsi;": 0x3d2, "Upsilon;": 0x3a5,
  "Uring;": 0x16e, "Uscr;": [0xd835, 0xdcb0],
  "Utilde;": 0x168, "Uuml": 0xdc,
  "Uuml;": 0xdc, "VDash;": 0x22ab,
  "Vbar;": 0x2aeb, "Vcy;": 0x412,
  "Vdash;": 0x22a9, "Vdashl;": 0x2ae6,
  "Vee;": 0x22c1, "Verbar;": 0x2016,
  "Vert;": 0x2016, "VerticalBar;": 0x2223,
  "VerticalLine;": 0x7c, "VerticalSeparator;": 0x2758,
  "VerticalTilde;": 0x2240, "VeryThinSpace;": 0x200a,
  "Vfr;": [0xd835, 0xdd19], "Vopf;": [0xd835, 0xdd4d],
  "Vscr;": [0xd835, 0xdcb1], "Vvdash;": 0x22aa,
  "Wcirc;": 0x174, "Wedge;": 0x22c0,
  "Wfr;": [0xd835, 0xdd1a], "Wopf;": [0xd835, 0xdd4e],
  "Wscr;": [0xd835, 0xdcb2], "Xfr;": [0xd835, 0xdd1b],
  "Xi;": 0x39e, "Xopf;": [0xd835, 0xdd4f],
  "Xscr;": [0xd835, 0xdcb3], "YAcy;": 0x42f,
  "YIcy;": 0x407, "YUcy;": 0x42e,
  "Yacute": 0xdd, "Yacute;": 0xdd,
  "Ycirc;": 0x176, "Ycy;": 0x42b,
  "Yfr;": [0xd835, 0xdd1c], "Yopf;": [0xd835, 0xdd50],
  "Yscr;": [0xd835, 0xdcb4], "Yuml;": 0x178,
  "ZHcy;": 0x416, "Zacute;": 0x179,
  "Zcaron;": 0x17d, "Zcy;": 0x417,
  "Zdot;": 0x17b, "ZeroWidthSpace;": 0x200b,
  "Zeta;": 0x396, "Zfr;": 0x2128,
  "Zopf;": 0x2124, "Zscr;": [0xd835, 0xdcb5],
  "aacute": 0xe1, "aacute;": 0xe1,
  "abreve;": 0x103, "ac;": 0x223e,
  "acE;": [0x223e, 0x333], "acd;": 0x223f,
  "acirc": 0xe2, "acirc;": 0xe2,
  "acute": 0xb4, "acute;": 0xb4,
  "acy;": 0x430, "aelig": 0xe6,
  "aelig;": 0xe6, "af;": 0x2061,
  "afr;": [0xd835, 0xdd1e], "agrave": 0xe0,
  "agrave;": 0xe0, "alefsym;": 0x2135,
  "aleph;": 0x2135, "alpha;": 0x3b1,
  "amacr;": 0x101, "amalg;": 0x2a3f,
  "amp": 0x26, "amp;": 0x26,
  "and;": 0x2227, "andand;": 0x2a55,
  "andd;": 0x2a5c, "andslope;": 0x2a58,
  "andv;": 0x2a5a, "ang;": 0x2220,
  "ange;": 0x29a4, "angle;": 0x2220,
  "angmsd;": 0x2221, "angmsdaa;": 0x29a8,
  "angmsdab;": 0x29a9, "angmsdac;": 0x29aa,
  "angmsdad;": 0x29ab, "angmsdae;": 0x29ac,
  "angmsdaf;": 0x29ad, "angmsdag;": 0x29ae,
  "angmsdah;": 0x29af, "angrt;": 0x221f,
  "angrtvb;": 0x22be, "angrtvbd;": 0x299d,
  "angsph;": 0x2222, "angst;": 0xc5,
  "angzarr;": 0x237c, "aogon;": 0x105,
  "aopf;": [0xd835, 0xdd52], "ap;": 0x2248,
  "apE;": 0x2a70, "apacir;": 0x2a6f,
  "ape;": 0x224a, "apid;": 0x224b,
  "apos;": 0x27, "approx;": 0x2248,
  "approxeq;": 0x224a, "aring": 0xe5,
  "aring;": 0xe5, "ascr;": [0xd835, 0xdcb6],
  "ast;": 0x2a, "asymp;": 0x2248,
  "asympeq;": 0x224d, "atilde": 0xe3,
  "atilde;": 0xe3, "auml": 0xe4,
  "auml;": 0xe4, "awconint;": 0x2233,
  "awint;": 0x2a11, "bNot;": 0x2aed,
  "backcong;": 0x224c, "backepsilon;": 0x3f6,
  "backprime;": 0x2035, "backsim;": 0x223d,
  "backsimeq;": 0x22cd, "barvee;": 0x22bd,
  "barwed;": 0x2305, "barwedge;": 0x2305,
  "bbrk;": 0x23b5, "bbrktbrk;": 0x23b6,
  "bcong;": 0x224c, "bcy;": 0x431,
  "bdquo;": 0x201e, "becaus;": 0x2235,
  "because;": 0x2235, "bemptyv;": 0x29b0,
  "bepsi;": 0x3f6, "bernou;": 0x212c,
  "beta;": 0x3b2, "beth;": 0x2136,
  "between;": 0x226c, "bfr;": [0xd835, 0xdd1f],
  "bigcap;": 0x22c2, "bigcirc;": 0x25ef,
  "bigcup;": 0x22c3, "bigodot;": 0x2a00,
  "bigoplus;": 0x2a01, "bigotimes;": 0x2a02,
  "bigsqcup;": 0x2a06, "bigstar;": 0x2605,
  "bigtriangledown;": 0x25bd, "bigtriangleup;": 0x25b3,
  "biguplus;": 0x2a04, "bigvee;": 0x22c1,
  "bigwedge;": 0x22c0, "bkarow;": 0x290d,
  "blacklozenge;": 0x29eb, "blacksquare;": 0x25aa,
  "blacktriangle;": 0x25b4, "blacktriangledown;": 0x25be,
  "blacktriangleleft;": 0x25c2, "blacktriangleright;": 0x25b8,
  "blank;": 0x2423, "blk12;": 0x2592,
  "blk14;": 0x2591, "blk34;": 0x2593,
  "block;": 0x2588, "bne;": [0x3d, 0x20e5],
  "bnequiv;": [0x2261, 0x20e5], "bnot;": 0x2310,
  "bopf;": [0xd835, 0xdd53], "bot;": 0x22a5,
  "bottom;": 0x22a5, "bowtie;": 0x22c8,
  "boxDL;": 0x2557, "boxDR;": 0x2554,
  "boxDl;": 0x2556, "boxDr;": 0x2553,
  "boxH;": 0x2550, "boxHD;": 0x2566,
  "boxHU;": 0x2569, "boxHd;": 0x2564,
  "boxHu;": 0x2567, "boxUL;": 0x255d,
  "boxUR;": 0x255a, "boxUl;": 0x255c,
  "boxUr;": 0x2559, "boxV;": 0x2551,
  "boxVH;": 0x256c, "boxVL;": 0x2563,
  "boxVR;": 0x2560, "boxVh;": 0x256b,
  "boxVl;": 0x2562, "boxVr;": 0x255f,
  "boxbox;": 0x29c9, "boxdL;": 0x2555,
  "boxdR;": 0x2552, "boxdl;": 0x2510,
  "boxdr;": 0x250c, "boxh;": 0x2500,
  "boxhD;": 0x2565, "boxhU;": 0x2568,
  "boxhd;": 0x252c, "boxhu;": 0x2534,
  "boxminus;": 0x229f, "boxplus;": 0x229e,
  "boxtimes;": 0x22a0, "boxuL;": 0x255b,
  "boxuR;": 0x2558, "boxul;": 0x2518,
  "boxur;": 0x2514, "boxv;": 0x2502,
  "boxvH;": 0x256a, "boxvL;": 0x2561,
  "boxvR;": 0x255e, "boxvh;": 0x253c,
  "boxvl;": 0x2524, "boxvr;": 0x251c,
  "bprime;": 0x2035, "breve;": 0x2d8,
  "brvbar": 0xa6, "brvbar;": 0xa6,
  "bscr;": [0xd835, 0xdcb7], "bsemi;": 0x204f,
  "bsim;": 0x223d, "bsime;": 0x22cd,
  "bsol;": 0x5c, "bsolb;": 0x29c5,
  "bsolhsub;": 0x27c8, "bull;": 0x2022,
  "bullet;": 0x2022, "bump;": 0x224e,
  "bumpE;": 0x2aae, "bumpe;": 0x224f,
  "bumpeq;": 0x224f, "cacute;": 0x107,
  "cap;": 0x2229, "capand;": 0x2a44,
  "capbrcup;": 0x2a49, "capcap;": 0x2a4b,
  "capcup;": 0x2a47, "capdot;": 0x2a40,
  "caps;": [0x2229, 0xfe00], "caret;": 0x2041,
  "caron;": 0x2c7, "ccaps;": 0x2a4d,
  "ccaron;": 0x10d, "ccedil": 0xe7,
  "ccedil;": 0xe7, "ccirc;": 0x109,
  "ccups;": 0x2a4c, "ccupssm;": 0x2a50,
  "cdot;": 0x10b, "cedil": 0xb8,
  "cedil;": 0xb8, "cemptyv;": 0x29b2,
  "cent": 0xa2, "cent;": 0xa2,
  "centerdot;": 0xb7, "cfr;": [0xd835, 0xdd20],
  "chcy;": 0x447, "check;": 0x2713,
  "checkmark;": 0x2713, "chi;": 0x3c7,
  "cir;": 0x25cb, "cirE;": 0x29c3,
  "circ;": 0x2c6, "circeq;": 0x2257,
  "circlearrowleft;": 0x21ba, "circlearrowright;": 0x21bb,
  "circledR;": 0xae, "circledS;": 0x24c8,
  "circledast;": 0x229b, "circledcirc;": 0x229a,
  "circleddash;": 0x229d, "cire;": 0x2257,
  "cirfnint;": 0x2a10, "cirmid;": 0x2aef,
  "cirscir;": 0x29c2, "clubs;": 0x2663,
  "clubsuit;": 0x2663, "colon;": 0x3a,
  "colone;": 0x2254, "coloneq;": 0x2254,
  "comma;": 0x2c, "commat;": 0x40,
  "comp;": 0x2201, "compfn;": 0x2218,
  "complement;": 0x2201, "complexes;": 0x2102,
  "cong;": 0x2245, "congdot;": 0x2a6d,
  "conint;": 0x222e, "copf;": [0xd835, 0xdd54],
  "coprod;": 0x2210, "copy": 0xa9,
  "copy;": 0xa9, "copysr;": 0x2117,
  "crarr;": 0x21b5, "cross;": 0x2717,
  "cscr;": [0xd835, 0xdcb8], "csub;": 0x2acf,
  "csube;": 0x2ad1, "csup;": 0x2ad0,
  "csupe;": 0x2ad2, "ctdot;": 0x22ef,
  "cudarrl;": 0x2938, "cudarrr;": 0x2935,
  "cuepr;": 0x22de, "cuesc;": 0x22df,
  "cularr;": 0x21b6, "cularrp;": 0x293d,
  "cup;": 0x222a, "cupbrcap;": 0x2a48,
  "cupcap;": 0x2a46, "cupcup;": 0x2a4a,
  "cupdot;": 0x228d, "cupor;": 0x2a45,
  "cups;": [0x222a, 0xfe00], "curarr;": 0x21b7,
  "curarrm;": 0x293c, "curlyeqprec;": 0x22de,
  "curlyeqsucc;": 0x22df, "curlyvee;": 0x22ce,
  "curlywedge;": 0x22cf, "curren": 0xa4,
  "curren;": 0xa4, "curvearrowleft;": 0x21b6,
  "curvearrowright;": 0x21b7, "cuvee;": 0x22ce,
  "cuwed;": 0x22cf, "cwconint;": 0x2232,
  "cwint;": 0x2231, "cylcty;": 0x232d,
  "dArr;": 0x21d3, "dHar;": 0x2965,
  "dagger;": 0x2020, "daleth;": 0x2138,
  "darr;": 0x2193, "dash;": 0x2010,
  "dashv;": 0x22a3, "dbkarow;": 0x290f,
  "dblac;": 0x2dd, "dcaron;": 0x10f,
  "dcy;": 0x434, "dd;": 0x2146,
  "ddagger;": 0x2021, "ddarr;": 0x21ca,
  "ddotseq;": 0x2a77, "deg": 0xb0,
  "deg;": 0xb0, "delta;": 0x3b4,
  "demptyv;": 0x29b1, "dfisht;": 0x297f,
  "dfr;": [0xd835, 0xdd21], "dharl;": 0x21c3,
  "dharr;": 0x21c2, "diam;": 0x22c4,
  "diamond;": 0x22c4, "diamondsuit;": 0x2666,
  "diams;": 0x2666, "die;": 0xa8,
  "digamma;": 0x3dd, "disin;": 0x22f2,
  "div;": 0xf7, "divide": 0xf7,
  "divide;": 0xf7, "divideontimes;": 0x22c7,
  "divonx;": 0x22c7, "djcy;": 0x452,
  "dlcorn;": 0x231e, "dlcrop;": 0x230d,
  "dollar;": 0x24, "dopf;": [0xd835, 0xdd55],
  "dot;": 0x2d9, "doteq;": 0x2250,
  "doteqdot;": 0x2251, "dotminus;": 0x2238,
  "dotplus;": 0x2214, "dotsquare;": 0x22a1,
  "doublebarwedge;": 0x2306, "downarrow;": 0x2193,
  "downdownarrows;": 0x21ca, "downharpoonleft;": 0x21c3,
  "downharpoonright;": 0x21c2, "drbkarow;": 0x2910,
  "drcorn;": 0x231f, "drcrop;": 0x230c,
  "dscr;": [0xd835, 0xdcb9], "dscy;": 0x455,
  "dsol;": 0x29f6, "dstrok;": 0x111,
  "dtdot;": 0x22f1, "dtri;": 0x25bf,
  "dtrif;": 0x25be, "duarr;": 0x21f5,
  "duhar;": 0x296f, "dwangle;": 0x29a6,
  "dzcy;": 0x45f, "dzigrarr;": 0x27ff,
  "eDDot;": 0x2a77, "eDot;": 0x2251,
  "eacute": 0xe9, "eacute;": 0xe9,
  "easter;": 0x2a6e, "ecaron;": 0x11b,
  "ecir;": 0x2256, "ecirc": 0xea,
  "ecirc;": 0xea, "ecolon;": 0x2255,
  "ecy;": 0x44d, "edot;": 0x117,
  "ee;": 0x2147, "efDot;": 0x2252,
  "efr;": [0xd835, 0xdd22], "eg;": 0x2a9a,
  "egrave": 0xe8, "egrave;": 0xe8,
  "egs;": 0x2a96, "egsdot;": 0x2a98,
  "el;": 0x2a99, "elinters;": 0x23e7,
  "ell;": 0x2113, "els;": 0x2a95,
  "elsdot;": 0x2a97, "emacr;": 0x113,
  "empty;": 0x2205, "emptyset;": 0x2205,
  "emptyv;": 0x2205, "emsp13;": 0x2004,
  "emsp14;": 0x2005, "emsp;": 0x2003,
  "eng;": 0x14b, "ensp;": 0x2002,
  "eogon;": 0x119, "eopf;": [0xd835, 0xdd56],
  "epar;": 0x22d5, "eparsl;": 0x29e3,
  "eplus;": 0x2a71, "epsi;": 0x3b5,
  "epsilon;": 0x3b5, "epsiv;": 0x3f5,
  "eqcirc;": 0x2256, "eqcolon;": 0x2255,
  "eqsim;": 0x2242, "eqslantgtr;": 0x2a96,
  "eqslantless;": 0x2a95, "equals;": 0x3d,
  "equest;": 0x225f, "equiv;": 0x2261,
  "equivDD;": 0x2a78, "eqvparsl;": 0x29e5,
  "erDot;": 0x2253, "erarr;": 0x2971,
  "escr;": 0x212f, "esdot;": 0x2250,
  "esim;": 0x2242, "eta;": 0x3b7,
  "eth": 0xf0, "eth;": 0xf0,
  "euml": 0xeb, "euml;": 0xeb,
  "euro;": 0x20ac, "excl;": 0x21,
  "exist;": 0x2203, "expectation;": 0x2130,
  "exponentiale;": 0x2147, "fallingdotseq;": 0x2252,
  "fcy;": 0x444, "female;": 0x2640,
  "ffilig;": 0xfb03, "fflig;": 0xfb00,
  "ffllig;": 0xfb04, "ffr;": [0xd835, 0xdd23],
  "filig;": 0xfb01, "fjlig;": [0x66, 0x6a],
  "flat;": 0x266d, "fllig;": 0xfb02,
  "fltns;": 0x25b1, "fnof;": 0x192,
  "fopf;": [0xd835, 0xdd57], "forall;": 0x2200,
  "fork;": 0x22d4, "forkv;": 0x2ad9,
  "fpartint;": 0x2a0d, "frac12": 0xbd,
  "frac12;": 0xbd, "frac13;": 0x2153,
  "frac14": 0xbc, "frac14;": 0xbc,
  "frac15;": 0x2155, "frac16;": 0x2159,
  "frac18;": 0x215b, "frac23;": 0x2154,
  "frac25;": 0x2156, "frac34": 0xbe,
  "frac34;": 0xbe, "frac35;": 0x2157,
  "frac38;": 0x215c, "frac45;": 0x2158,
  "frac56;": 0x215a, "frac58;": 0x215d,
  "frac78;": 0x215e, "frasl;": 0x2044,
  "frown;": 0x2322, "fscr;": [0xd835, 0xdcbb],
  "gE;": 0x2267, "gEl;": 0x2a8c,
  "gacute;": 0x1f5, "gamma;": 0x3b3,
  "gammad;": 0x3dd, "gap;": 0x2a86,
  "gbreve;": 0x11f, "gcirc;": 0x11d,
  "gcy;": 0x433, "gdot;": 0x121,
  "ge;": 0x2265, "gel;": 0x22db,
  "geq;": 0x2265, "geqq;": 0x2267,
  "geqslant;": 0x2a7e, "ges;": 0x2a7e,
  "gescc;": 0x2aa9, "gesdot;": 0x2a80,
  "gesdoto;": 0x2a82, "gesdotol;": 0x2a84,
  "gesl;": [0x22db, 0xfe00], "gesles;": 0x2a94,
  "gfr;": [0xd835, 0xdd24], "gg;": 0x226b,
  "ggg;": 0x22d9, "gimel;": 0x2137,
  "gjcy;": 0x453, "gl;": 0x2277,
  "glE;": 0x2a92, "gla;": 0x2aa5,
  "glj;": 0x2aa4, "gnE;": 0x2269,
  "gnap;": 0x2a8a, "gnapprox;": 0x2a8a,
  "gne;": 0x2a88, "gneq;": 0x2a88,
  "gneqq;": 0x2269, "gnsim;": 0x22e7,
  "gopf;": [0xd835, 0xdd58], "grave;": 0x60,
  "gscr;": 0x210a, "gsim;": 0x2273,
  "gsime;": 0x2a8e, "gsiml;": 0x2a90,
  "gt": 0x3e, "gt;": 0x3e,
  "gtcc;": 0x2aa7, "gtcir;": 0x2a7a,
  "gtdot;": 0x22d7, "gtlPar;": 0x2995,
  "gtquest;": 0x2a7c, "gtrapprox;": 0x2a86,
  "gtrarr;": 0x2978, "gtrdot;": 0x22d7,
  "gtreqless;": 0x22db, "gtreqqless;": 0x2a8c,
  "gtrless;": 0x2277, "gtrsim;": 0x2273,
  "gvertneqq;": [0x2269, 0xfe00], "gvnE;": [0x2269, 0xfe00],
  "hArr;": 0x21d4, "hairsp;": 0x200a,
  "half;": 0xbd, "hamilt;": 0x210b,
  "hardcy;": 0x44a, "harr;": 0x2194,
  "harrcir;": 0x2948, "harrw;": 0x21ad,
  "hbar;": 0x210f, "hcirc;": 0x125,
  "hearts;": 0x2665, "heartsuit;": 0x2665,
  "hellip;": 0x2026, "hercon;": 0x22b9,
  "hfr;": [0xd835, 0xdd25], "hksearow;": 0x2925,
  "hkswarow;": 0x2926, "hoarr;": 0x21ff,
  "homtht;": 0x223b, "hookleftarrow;": 0x21a9,
  "hookrightarrow;": 0x21aa, "hopf;": [0xd835, 0xdd59],
  "horbar;": 0x2015, "hscr;": [0xd835, 0xdcbd],
  "hslash;": 0x210f, "hstrok;": 0x127,
  "hybull;": 0x2043, "hyphen;": 0x2010,
  "iacute": 0xed, "iacute;": 0xed,
  "ic;": 0x2063, "icirc": 0xee,
  "icirc;": 0xee, "icy;": 0x438,
  "iecy;": 0x435, "iexcl": 0xa1,
  "iexcl;": 0xa1, "iff;": 0x21d4,
  "ifr;": [0xd835, 0xdd26], "igrave": 0xec,
  "igrave;": 0xec, "ii;": 0x2148,
  "iiiint;": 0x2a0c, "iiint;": 0x222d,
  "iinfin;": 0x29dc, "iiota;": 0x2129,
  "ijlig;": 0x133, "imacr;": 0x12b,
  "image;": 0x2111, "imagline;": 0x2110,
  "imagpart;": 0x2111, "imath;": 0x131,
  "imof;": 0x22b7, "imped;": 0x1b5,
  "in;": 0x2208, "incare;": 0x2105,
  "infin;": 0x221e, "infintie;": 0x29dd,
  "inodot;": 0x131, "int;": 0x222b,
  "intcal;": 0x22ba, "integers;": 0x2124,
  "intercal;": 0x22ba, "intlarhk;": 0x2a17,
  "intprod;": 0x2a3c, "iocy;": 0x451,
  "iogon;": 0x12f, "iopf;": [0xd835, 0xdd5a],
  "iota;": 0x3b9, "iprod;": 0x2a3c,
  "iquest": 0xbf, "iquest;": 0xbf,
  "iscr;": [0xd835, 0xdcbe], "isin;": 0x2208,
  "isinE;": 0x22f9, "isindot;": 0x22f5,
  "isins;": 0x22f4, "isinsv;": 0x22f3,
  "isinv;": 0x2208, "it;": 0x2062,
  "itilde;": 0x129, "iukcy;": 0x456,
  "iuml": 0xef, "iuml;": 0xef,
  "jcirc;": 0x135, "jcy;": 0x439,
  "jfr;": [0xd835, 0xdd27], "jmath;": 0x237,
  "jopf;": [0xd835, 0xdd5b], "jscr;": [0xd835, 0xdcbf],
  "jsercy;": 0x458, "jukcy;": 0x454,
  "kappa;": 0x3ba, "kappav;": 0x3f0,
  "kcedil;": 0x137, "kcy;": 0x43a,
  "kfr;": [0xd835, 0xdd28], "kgreen;": 0x138,
  "khcy;": 0x445, "kjcy;": 0x45c,
  "kopf;": [0xd835, 0xdd5c], "kscr;": [0xd835, 0xdcc0],
  "lAarr;": 0x21da, "lArr;": 0x21d0,
  "lAtail;": 0x291b, "lBarr;": 0x290e,
  "lE;": 0x2266, "lEg;": 0x2a8b,
  "lHar;": 0x2962, "lacute;": 0x13a,
  "laemptyv;": 0x29b4, "lagran;": 0x2112,
  "lambda;": 0x3bb, "lang;": 0x27e8,
  "langd;": 0x2991, "langle;": 0x27e8,
  "lap;": 0x2a85, "laquo": 0xab,
  "laquo;": 0xab, "larr;": 0x2190,
  "larrb;": 0x21e4, "larrbfs;": 0x291f,
  "larrfs;": 0x291d, "larrhk;": 0x21a9,
  "larrlp;": 0x21ab, "larrpl;": 0x2939,
  "larrsim;": 0x2973, "larrtl;": 0x21a2,
  "lat;": 0x2aab, "latail;": 0x2919,
  "late;": 0x2aad, "lates;": [0x2aad, 0xfe00],
  "lbarr;": 0x290c, "lbbrk;": 0x2772,
  "lbrace;": 0x7b, "lbrack;": 0x5b,
  "lbrke;": 0x298b, "lbrksld;": 0x298f,
  "lbrkslu;": 0x298d, "lcaron;": 0x13e,
  "lcedil;": 0x13c, "lceil;": 0x2308,
  "lcub;": 0x7b, "lcy;": 0x43b,
  "ldca;": 0x2936, "ldquo;": 0x201c,
  "ldquor;": 0x201e, "ldrdhar;": 0x2967,
  "ldrushar;": 0x294b, "ldsh;": 0x21b2,
  "le;": 0x2264, "leftarrow;": 0x2190,
  "leftarrowtail;": 0x21a2, "leftharpoondown;": 0x21bd,
  "leftharpoonup;": 0x21bc, "leftleftarrows;": 0x21c7,
  "leftrightarrow;": 0x2194, "leftrightarrows;": 0x21c6,
  "leftrightharpoons;": 0x21cb, "leftrightsquigarrow;": 0x21ad,
  "leftthreetimes;": 0x22cb, "leg;": 0x22da,
  "leq;": 0x2264, "leqq;": 0x2266,
  "leqslant;": 0x2a7d, "les;": 0x2a7d,
  "lescc;": 0x2aa8, "lesdot;": 0x2a7f,
  "lesdoto;": 0x2a81, "lesdotor;": 0x2a83,
  "lesg;": [0x22da, 0xfe00], "lesges;": 0x2a93,
  "lessapprox;": 0x2a85, "lessdot;": 0x22d6,
  "lesseqgtr;": 0x22da, "lesseqqgtr;": 0x2a8b,
  "lessgtr;": 0x2276, "lesssim;": 0x2272,
  "lfisht;": 0x297c, "lfloor;": 0x230a,
  "lfr;": [0xd835, 0xdd29], "lg;": 0x2276,
  "lgE;": 0x2a91, "lhard;": 0x21bd,
  "lharu;": 0x21bc, "lharul;": 0x296a,
  "lhblk;": 0x2584, "ljcy;": 0x459,
  "ll;": 0x226a, "llarr;": 0x21c7,
  "llcorner;": 0x231e, "llhard;": 0x296b,
  "lltri;": 0x25fa, "lmidot;": 0x140,
  "lmoust;": 0x23b0, "lmoustache;": 0x23b0,
  "lnE;": 0x2268, "lnap;": 0x2a89,
  "lnapprox;": 0x2a89, "lne;": 0x2a87,
  "lneq;": 0x2a87, "lneqq;": 0x2268,
  "lnsim;": 0x22e6, "loang;": 0x27ec,
  "loarr;": 0x21fd, "lobrk;": 0x27e6,
  "longleftarrow;": 0x27f5, "longleftrightarrow;": 0x27f7,
  "longmapsto;": 0x27fc, "longrightarrow;": 0x27f6,
  "looparrowleft;": 0x21ab, "looparrowright;": 0x21ac,
  "lopar;": 0x2985, "lopf;": [0xd835, 0xdd5d],
  "loplus;": 0x2a2d, "lotimes;": 0x2a34,
  "lowast;": 0x2217, "lowbar;": 0x5f,
  "loz;": 0x25ca, "lozenge;": 0x25ca,
  "lozf;": 0x29eb, "lpar;": 0x28,
  "lparlt;": 0x2993, "lrarr;": 0x21c6,
  "lrcorner;": 0x231f, "lrhar;": 0x21cb,
  "lrhard;": 0x296d, "lrm;": 0x200e,
  "lrtri;": 0x22bf, "lsaquo;": 0x2039,
  "lscr;": [0xd835, 0xdcc1], "lsh;": 0x21b0,
  "lsim;": 0x2272, "lsime;": 0x2a8d,
  "lsimg;": 0x2a8f, "lsqb;": 0x5b,
  "lsquo;": 0x2018, "lsquor;": 0x201a,
  "lstrok;": 0x142, "lt": 0x3c,
  "lt;": 0x3c, "ltcc;": 0x2aa6,
  "ltcir;": 0x2a79, "ltdot;": 0x22d6,
  "lthree;": 0x22cb, "ltimes;": 0x22c9,
  "ltlarr;": 0x2976, "ltquest;": 0x2a7b,
  "ltrPar;": 0x2996, "ltri;": 0x25c3,
  "ltrie;": 0x22b4, "ltrif;": 0x25c2,
  "lurdshar;": 0x294a, "luruhar;": 0x2966,
  "lvertneqq;": [0x2268, 0xfe00], "lvnE;": [0x2268, 0xfe00],
  "mDDot;": 0x223a, "macr": 0xaf,
  "macr;": 0xaf, "male;": 0x2642,
  "malt;": 0x2720, "maltese;": 0x2720,
  "map;": 0x21a6, "mapsto;": 0x21a6,
  "mapstodown;": 0x21a7, "mapstoleft;": 0x21a4,
  "mapstoup;": 0x21a5, "marker;": 0x25ae,
  "mcomma;": 0x2a29, "mcy;": 0x43c,
  "mdash;": 0x2014, "measuredangle;": 0x2221,
  "mfr;": [0xd835, 0xdd2a], "mho;": 0x2127,
  "micro": 0xb5, "micro;": 0xb5,
  "mid;": 0x2223, "midast;": 0x2a,
  "midcir;": 0x2af0, "middot": 0xb7,
  "middot;": 0xb7, "minus;": 0x2212,
  "minusb;": 0x229f, "minusd;": 0x2238,
  "minusdu;": 0x2a2a, "mlcp;": 0x2adb,
  "mldr;": 0x2026, "mnplus;": 0x2213,
  "models;": 0x22a7, "mopf;": [0xd835, 0xdd5e],
  "mp;": 0x2213, "mscr;": [0xd835, 0xdcc2],
  "mstpos;": 0x223e, "mu;": 0x3bc,
  "multimap;": 0x22b8, "mumap;": 0x22b8,
  "nGg;": [0x22d9, 0x338], "nGt;": [0x226b, 0x20d2],
  "nGtv;": [0x226b, 0x338], "nLeftarrow;": 0x21cd,
  "nLeftrightarrow;": 0x21ce, "nLl;": [0x22d8, 0x338],
  "nLt;": [0x226a, 0x20d2], "nLtv;": [0x226a, 0x338],
  "nRightarrow;": 0x21cf, "nVDash;": 0x22af,
  "nVdash;": 0x22ae, "nabla;": 0x2207,
  "nacute;": 0x144, "nang;": [0x2220, 0x20d2],
  "nap;": 0x2249, "napE;": [0x2a70, 0x338],
  "napid;": [0x224b, 0x338], "napos;": 0x149,
  "napprox;": 0x2249, "natur;": 0x266e,
  "natural;": 0x266e, "naturals;": 0x2115,
  "nbsp": 0xa0, "nbsp;": 0xa0,
  "nbump;": [0x224e, 0x338], "nbumpe;": [0x224f, 0x338],
  "ncap;": 0x2a43, "ncaron;": 0x148,
  "ncedil;": 0x146, "ncong;": 0x2247,
  "ncongdot;": [0x2a6d, 0x338], "ncup;": 0x2a42,
  "ncy;": 0x43d, "ndash;": 0x2013,
  "ne;": 0x2260, "neArr;": 0x21d7,
  "nearhk;": 0x2924, "nearr;": 0x2197,
  "nearrow;": 0x2197, "nedot;": [0x2250, 0x338],
  "nequiv;": 0x2262, "nesear;": 0x2928,
  "nesim;": [0x2242, 0x338], "nexist;": 0x2204,
  "nexists;": 0x2204, "nfr;": [0xd835, 0xdd2b],
  "ngE;": [0x2267, 0x338], "nge;": 0x2271,
  "ngeq;": 0x2271, "ngeqq;": [0x2267, 0x338],
  "ngeqslant;": [0x2a7e, 0x338], "nges;": [0x2a7e, 0x338],
  "ngsim;": 0x2275, "ngt;": 0x226f,
  "ngtr;": 0x226f, "nhArr;": 0x21ce,
  "nharr;": 0x21ae, "nhpar;": 0x2af2,
  "ni;": 0x220b, "nis;": 0x22fc,
  "nisd;": 0x22fa, "niv;": 0x220b,
  "njcy;": 0x45a, "nlArr;": 0x21cd,
  "nlE;": [0x2266, 0x338], "nlarr;": 0x219a,
  "nldr;": 0x2025, "nle;": 0x2270,
  "nleftarrow;": 0x219a, "nleftrightarrow;": 0x21ae,
  "nleq;": 0x2270, "nleqq;": [0x2266, 0x338],
  "nleqslant;": [0x2a7d, 0x338], "nles;": [0x2a7d, 0x338],
  "nless;": 0x226e, "nlsim;": 0x2274,
  "nlt;": 0x226e, "nltri;": 0x22ea,
  "nltrie;": 0x22ec, "nmid;": 0x2224,
  "nopf;": [0xd835, 0xdd5f], "not": 0xac,
  "not;": 0xac, "notin;": 0x2209,
  "notinE;": [0x22f9, 0x338], "notindot;": [0x22f5, 0x338],
  "notinva;": 0x2209, "notinvb;": 0x22f7,
  "notinvc;": 0x22f6, "notni;": 0x220c,
  "notniva;": 0x220c, "notnivb;": 0x22fe,
  "notnivc;": 0x22fd, "npar;": 0x2226,
  "nparallel;": 0x2226, "nparsl;": [0x2afd, 0x20e5],
  "npart;": [0x2202, 0x338], "npolint;": 0x2a14,
  "npr;": 0x2280, "nprcue;": 0x22e0,
  "npre;": [0x2aaf, 0x338], "nprec;": 0x2280,
  "npreceq;": [0x2aaf, 0x338], "nrArr;": 0x21cf,
  "nrarr;": 0x219b, "nrarrc;": [0x2933, 0x338],
  "nrarrw;": [0x219d, 0x338], "nrightarrow;": 0x219b,
  "nrtri;": 0x22eb, "nrtrie;": 0x22ed,
  "nsc;": 0x2281, "nsccue;": 0x22e1,
  "nsce;": [0x2ab0, 0x338], "nscr;": [0xd835, 0xdcc3],
  "nshortmid;": 0x2224, "nshortparallel;": 0x2226,
  "nsim;": 0x2241, "nsime;": 0x2244,
  "nsimeq;": 0x2244, "nsmid;": 0x2224,
  "nspar;": 0x2226, "nsqsube;": 0x22e2,
  "nsqsupe;": 0x22e3, "nsub;": 0x2284,
  "nsubE;": [0x2ac5, 0x338], "nsube;": 0x2288,
  "nsubset;": [0x2282, 0x20d2], "nsubseteq;": 0x2288,
  "nsubseteqq;": [0x2ac5, 0x338], "nsucc;": 0x2281,
  "nsucceq;": [0x2ab0, 0x338], "nsup;": 0x2285,
  "nsupE;": [0x2ac6, 0x338], "nsupe;": 0x2289,
  "nsupset;": [0x2283, 0x20d2], "nsupseteq;": 0x2289,
  "nsupseteqq;": [0x2ac6, 0x338], "ntgl;": 0x2279,
  "ntilde": 0xf1, "ntilde;": 0xf1,
  "ntlg;": 0x2278, "ntriangleleft;": 0x22ea,
  "ntrianglelefteq;": 0x22ec, "ntriangleright;": 0x22eb,
  "ntrianglerighteq;": 0x22ed, "nu;": 0x3bd,
  "num;": 0x23, "numero;": 0x2116,
  "numsp;": 0x2007, "nvDash;": 0x22ad,
  "nvHarr;": 0x2904, "nvap;": [0x224d, 0x20d2],
  "nvdash;": 0x22ac, "nvge;": [0x2265, 0x20d2],
  "nvgt;": [0x3e, 0x20d2], "nvinfin;": 0x29de,
  "nvlArr;": 0x2902, "nvle;": [0x2264, 0x20d2],
  "nvlt;": [0x3c, 0x20d2], "nvltrie;": [0x22b4, 0x20d2],
  "nvrArr;": 0x2903, "nvrtrie;": [0x22b5, 0x20d2],
  "nvsim;": [0x223c, 0x20d2], "nwArr;": 0x21d6,
  "nwarhk;": 0x2923, "nwarr;": 0x2196,
  "nwarrow;": 0x2196, "nwnear;": 0x2927,
  "oS;": 0x24c8, "oacute": 0xf3,
  "oacute;": 0xf3, "oast;": 0x229b,
  "ocir;": 0x229a, "ocirc": 0xf4,
  "ocirc;": 0xf4, "ocy;": 0x43e,
  "odash;": 0x229d, "odblac;": 0x151,
  "odiv;": 0x2a38, "odot;": 0x2299,
  "odsold;": 0x29bc, "oelig;": 0x153,
  "ofcir;": 0x29bf, "ofr;": [0xd835, 0xdd2c],
  "ogon;": 0x2db, "ograve": 0xf2,
  "ograve;": 0xf2, "ogt;": 0x29c1,
  "ohbar;": 0x29b5, "ohm;": 0x3a9,
  "oint;": 0x222e, "olarr;": 0x21ba,
  "olcir;": 0x29be, "olcross;": 0x29bb,
  "oline;": 0x203e, "olt;": 0x29c0,
  "omacr;": 0x14d, "omega;": 0x3c9,
  "omicron;": 0x3bf, "omid;": 0x29b6,
  "ominus;": 0x2296, "oopf;": [0xd835, 0xdd60],
  "opar;": 0x29b7, "operp;": 0x29b9,
  "oplus;": 0x2295, "or;": 0x2228,
  "orarr;": 0x21bb, "ord;": 0x2a5d,
  "order;": 0x2134, "orderof;": 0x2134,
  "ordf": 0xaa, "ordf;": 0xaa,
  "ordm": 0xba, "ordm;": 0xba,
  "origof;": 0x22b6, "oror;": 0x2a56,
  "orslope;": 0x2a57, "orv;": 0x2a5b,
  "oscr;": 0x2134, "oslash": 0xf8,
  "oslash;": 0xf8, "osol;": 0x2298,
  "otilde": 0xf5, "otilde;": 0xf5,
  "otimes;": 0x2297, "otimesas;": 0x2a36,
  "ouml": 0xf6, "ouml;": 0xf6,
  "ovbar;": 0x233d, "par;": 0x2225,
  "para": 0xb6, "para;": 0xb6,
  "parallel;": 0x2225, "parsim;": 0x2af3,
  "parsl;": 0x2afd, "part;": 0x2202,
  "pcy;": 0x43f, "percnt;": 0x25,
  "period;": 0x2e, "permil;": 0x2030,
  "perp;": 0x22a5, "pertenk;": 0x2031,
  "pfr;": [0xd835, 0xdd2d], "phi;": 0x3c6,
  "phiv;": 0x3d5, "phmmat;": 0x2133,
  "phone;": 0x260e, "pi;": 0x3c0,
  "pitchfork;": 0x22d4, "piv;": 0x3d6,
  "planck;": 0x210f, "planckh;": 0x210e,
  "plankv;": 0x210f, "plus;": 0x2b,
  "plusacir;": 0x2a23, "plusb;": 0x229e,
  "pluscir;": 0x2a22, "plusdo;": 0x2214,
  "plusdu;": 0x2a25, "pluse;": 0x2a72,
  "plusmn": 0xb1, "plusmn;": 0xb1,
  "plussim;": 0x2a26, "plustwo;": 0x2a27,
  "pm;": 0xb1, "pointint;": 0x2a15,
  "popf;": [0xd835, 0xdd61], "pound": 0xa3,
  "pound;": 0xa3, "pr;": 0x227a,
  "prE;": 0x2ab3, "prap;": 0x2ab7,
  "prcue;": 0x227c, "pre;": 0x2aaf,
  "prec;": 0x227a, "precapprox;": 0x2ab7,
  "preccurlyeq;": 0x227c, "preceq;": 0x2aaf,
  "precnapprox;": 0x2ab9, "precneqq;": 0x2ab5,
  "precnsim;": 0x22e8, "precsim;": 0x227e,
  "prime;": 0x2032, "primes;": 0x2119,
  "prnE;": 0x2ab5, "prnap;": 0x2ab9,
  "prnsim;": 0x22e8, "prod;": 0x220f,
  "profalar;": 0x232e, "profline;": 0x2312,
  "profsurf;": 0x2313, "prop;": 0x221d,
  "propto;": 0x221d, "prsim;": 0x227e,
  "prurel;": 0x22b0, "pscr;": [0xd835, 0xdcc5],
  "psi;": 0x3c8, "puncsp;": 0x2008,
  "qfr;": [0xd835, 0xdd2e], "qint;": 0x2a0c,
  "qopf;": [0xd835, 0xdd62], "qprime;": 0x2057,
  "qscr;": [0xd835, 0xdcc6], "quaternions;": 0x210d,
  "quatint;": 0x2a16, "quest;": 0x3f,
  "questeq;": 0x225f, "quot": 0x22,
  "quot;": 0x22, "rAarr;": 0x21db,
  "rArr;": 0x21d2, "rAtail;": 0x291c,
  "rBarr;": 0x290f, "rHar;": 0x2964,
  "race;": [0x223d, 0x331], "racute;": 0x155,
  "radic;": 0x221a, "raemptyv;": 0x29b3,
  "rang;": 0x27e9, "rangd;": 0x2992,
  "range;": 0x29a5, "rangle;": 0x27e9,
  "raquo": 0xbb, "raquo;": 0xbb,
  "rarr;": 0x2192, "rarrap;": 0x2975,
  "rarrb;": 0x21e5, "rarrbfs;": 0x2920,
  "rarrc;": 0x2933, "rarrfs;": 0x291e,
  "rarrhk;": 0x21aa, "rarrlp;": 0x21ac,
  "rarrpl;": 0x2945, "rarrsim;": 0x2974,
  "rarrtl;": 0x21a3, "rarrw;": 0x219d,
  "ratail;": 0x291a, "ratio;": 0x2236,
  "rationals;": 0x211a, "rbarr;": 0x290d,
  "rbbrk;": 0x2773, "rbrace;": 0x7d,
  "rbrack;": 0x5d, "rbrke;": 0x298c,
  "rbrksld;": 0x298e, "rbrkslu;": 0x2990,
  "rcaron;": 0x159, "rcedil;": 0x157,
  "rceil;": 0x2309, "rcub;": 0x7d,
  "rcy;": 0x440, "rdca;": 0x2937,
  "rdldhar;": 0x2969, "rdquo;": 0x201d,
  "rdquor;": 0x201d, "rdsh;": 0x21b3,
  "real;": 0x211c, "realine;": 0x211b,
  "realpart;": 0x211c, "reals;": 0x211d,
  "rect;": 0x25ad, "reg": 0xae,
  "reg;": 0xae, "rfisht;": 0x297d,
  "rfloor;": 0x230b, "rfr;": [0xd835, 0xdd2f],
  "rhard;": 0x21c1, "rharu;": 0x21c0,
  "rharul;": 0x296c, "rho;": 0x3c1,
  "rhov;": 0x3f1, "rightarrow;": 0x2192,
  "rightarrowtail;": 0x21a3, "rightharpoondown;": 0x21c1,
  "rightharpoonup;": 0x21c0, "rightleftarrows;": 0x21c4,
  "rightleftharpoons;": 0x21cc, "rightrightarrows;": 0x21c9,
  "rightsquigarrow;": 0x219d, "rightthreetimes;": 0x22cc,
  "ring;": 0x2da, "risingdotseq;": 0x2253,
  "rlarr;": 0x21c4, "rlhar;": 0x21cc,
  "rlm;": 0x200f, "rmoust;": 0x23b1,
  "rmoustache;": 0x23b1, "rnmid;": 0x2aee,
  "roang;": 0x27ed, "roarr;": 0x21fe,
  "robrk;": 0x27e7, "ropar;": 0x2986,
  "ropf;": [0xd835, 0xdd63], "roplus;": 0x2a2e,
  "rotimes;": 0x2a35, "rpar;": 0x29,
  "rpargt;": 0x2994, "rppolint;": 0x2a12,
  "rrarr;": 0x21c9, "rsaquo;": 0x203a,
  "rscr;": [0xd835, 0xdcc7], "rsh;": 0x21b1,
  "rsqb;": 0x5d, "rsquo;": 0x2019,
  "rsquor;": 0x2019, "rthree;": 0x22cc,
  "rtimes;": 0x22ca, "rtri;": 0x25b9,
  "rtrie;": 0x22b5, "rtrif;": 0x25b8,
  "rtriltri;": 0x29ce, "ruluhar;": 0x2968,
  "rx;": 0x211e, "sacute;": 0x15b,
  "sbquo;": 0x201a, "sc;": 0x227b,
  "scE;": 0x2ab4, "scap;": 0x2ab8,
  "scaron;": 0x161, "sccue;": 0x227d,
  "sce;": 0x2ab0, "scedil;": 0x15f,
  "scirc;": 0x15d, "scnE;": 0x2ab6,
  "scnap;": 0x2aba, "scnsim;": 0x22e9,
  "scpolint;": 0x2a13, "scsim;": 0x227f,
  "scy;": 0x441, "sdot;": 0x22c5,
  "sdotb;": 0x22a1, "sdote;": 0x2a66,
  "seArr;": 0x21d8, "searhk;": 0x2925,
  "searr;": 0x2198, "searrow;": 0x2198,
  "sect": 0xa7, "sect;": 0xa7,
  "semi;": 0x3b, "seswar;": 0x2929,
  "setminus;": 0x2216, "setmn;": 0x2216,
  "sext;": 0x2736, "sfr;": [0xd835, 0xdd30],
  "sfrown;": 0x2322, "sharp;": 0x266f,
  "shchcy;": 0x449, "shcy;": 0x448,
  "shortmid;": 0x2223, "shortparallel;": 0x2225,
  "shy": 0xad, "shy;": 0xad,
  "sigma;": 0x3c3, "sigmaf;": 0x3c2,
  "sigmav;": 0x3c2, "sim;": 0x223c,
  "simdot;": 0x2a6a, "sime;": 0x2243,
  "simeq;": 0x2243, "simg;": 0x2a9e,
  "simgE;": 0x2aa0, "siml;": 0x2a9d,
  "simlE;": 0x2a9f, "simne;": 0x2246,
  "simplus;": 0x2a24, "simrarr;": 0x2972,
  "slarr;": 0x2190, "smallsetminus;": 0x2216,
  "smashp;": 0x2a33, "smeparsl;": 0x29e4,
  "smid;": 0x2223, "smile;": 0x2323,
  "smt;": 0x2aaa, "smte;": 0x2aac,
  "smtes;": [0x2aac, 0xfe00], "softcy;": 0x44c,
  "sol;": 0x2f, "solb;": 0x29c4,
  "solbar;": 0x233f, "sopf;": [0xd835, 0xdd64],
  "spades;": 0x2660, "spadesuit;": 0x2660,
  "spar;": 0x2225, "sqcap;": 0x2293,
  "sqcaps;": [0x2293, 0xfe00], "sqcup;": 0x2294,
  "sqcups;": [0x2294, 0xfe00], "sqsub;": 0x228f,
  "sqsube;": 0x2291, "sqsubset;": 0x228f,
  "sqsubseteq;": 0x2291, "sqsup;": 0x2290,
  "sqsupe;": 0x2292, "sqsupset;": 0x2290,
  "sqsupseteq;": 0x2292, "squ;": 0x25a1,
  "square;": 0x25a1, "squarf;": 0x25aa,
  "squf;": 0x25aa, "srarr;": 0x2192,
  "sscr;": [0xd835, 0xdcc8], "ssetmn;": 0x2216,
  "ssmile;": 0x2323, "sstarf;": 0x22c6,
  "star;": 0x2606, "starf;": 0x2605,
  "straightepsilon;": 0x3f5, "straightphi;": 0x3d5,
  "strns;": 0xaf, "sub;": 0x2282,
  "subE;": 0x2ac5, "subdot;": 0x2abd,
  "sube;": 0x2286, "subedot;": 0x2ac3,
  "submult;": 0x2ac1, "subnE;": 0x2acb,
  "subne;": 0x228a, "subplus;": 0x2abf,
  "subrarr;": 0x2979, "subset;": 0x2282,
  "subseteq;": 0x2286, "subseteqq;": 0x2ac5,
  "subsetneq;": 0x228a, "subsetneqq;": 0x2acb,
  "subsim;": 0x2ac7, "subsub;": 0x2ad5,
  "subsup;": 0x2ad3, "succ;": 0x227b,
  "succapprox;": 0x2ab8, "succcurlyeq;": 0x227d,
  "succeq;": 0x2ab0, "succnapprox;": 0x2aba,
  "succneqq;": 0x2ab6, "succnsim;": 0x22e9,
  "succsim;": 0x227f, "sum;": 0x2211,
  "sung;": 0x266a, "sup1": 0xb9,
  "sup1;": 0xb9, "sup2": 0xb2,
  "sup2;": 0xb2, "sup3": 0xb3,
  "sup3;": 0xb3, "sup;": 0x2283,
  "supE;": 0x2ac6, "supdot;": 0x2abe,
  "supdsub;": 0x2ad8, "supe;": 0x2287,
  "supedot;": 0x2ac4, "suphsol;": 0x27c9,
  "suphsub;": 0x2ad7, "suplarr;": 0x297b,
  "supmult;": 0x2ac2, "supnE;": 0x2acc,
  "supne;": 0x228b, "supplus;": 0x2ac0,
  "supset;": 0x2283, "supseteq;": 0x2287,
  "supseteqq;": 0x2ac6, "supsetneq;": 0x228b,
  "supsetneqq;": 0x2acc, "supsim;": 0x2ac8,
  "supsub;": 0x2ad4, "supsup;": 0x2ad6,
  "swArr;": 0x21d9, "swarhk;": 0x2926,
  "swarr;": 0x2199, "swarrow;": 0x2199,
  "swnwar;": 0x292a, "szlig": 0xdf,
  "szlig;": 0xdf, "target;": 0x2316,
  "tau;": 0x3c4, "tbrk;": 0x23b4,
  "tcaron;": 0x165, "tcedil;": 0x163,
  "tcy;": 0x442, "tdot;": 0x20db,
  "telrec;": 0x2315, "tfr;": [0xd835, 0xdd31],
  "there4;": 0x2234, "therefore;": 0x2234,
  "theta;": 0x3b8, "thetasym;": 0x3d1,
  "thetav;": 0x3d1, "thickapprox;": 0x2248,
  "thicksim;": 0x223c, "thinsp;": 0x2009,
  "thkap;": 0x2248, "thksim;": 0x223c,
  "thorn": 0xfe, "thorn;": 0xfe,
  "tilde;": 0x2dc, "times": 0xd7,
  "times;": 0xd7, "timesb;": 0x22a0,
  "timesbar;": 0x2a31, "timesd;": 0x2a30,
  "tint;": 0x222d, "toea;": 0x2928,
  "top;": 0x22a4, "topbot;": 0x2336,
  "topcir;": 0x2af1, "topf;": [0xd835, 0xdd65],
  "topfork;": 0x2ada, "tosa;": 0x2929,
  "tprime;": 0x2034, "trade;": 0x2122,
  "triangle;": 0x25b5, "triangledown;": 0x25bf,
  "triangleleft;": 0x25c3, "trianglelefteq;": 0x22b4,
  "triangleq;": 0x225c, "triangleright;": 0x25b9,
  "trianglerighteq;": 0x22b5, "tridot;": 0x25ec,
  "trie;": 0x225c, "triminus;": 0x2a3a,
  "triplus;": 0x2a39, "trisb;": 0x29cd,
  "tritime;": 0x2a3b, "trpezium;": 0x23e2,
  "tscr;": [0xd835, 0xdcc9], "tscy;": 0x446,
  "tshcy;": 0x45b, "tstrok;": 0x167,
  "twixt;": 0x226c, "twoheadleftarrow;": 0x219e,
  "twoheadrightarrow;": 0x21a0, "uArr;": 0x21d1,
  "uHar;": 0x2963, "uacute": 0xfa,
  "uacute;": 0xfa, "uarr;": 0x2191,
  "ubrcy;": 0x45e, "ubreve;": 0x16d,
  "ucirc": 0xfb, "ucirc;": 0xfb,
  "ucy;": 0x443, "udarr;": 0x21c5,
  "udblac;": 0x171, "udhar;": 0x296e,
  "ufisht;": 0x297e, "ufr;": [0xd835, 0xdd32],
  "ugrave": 0xf9, "ugrave;": 0xf9,
  "uharl;": 0x21bf, "uharr;": 0x21be,
  "uhblk;": 0x2580, "ulcorn;": 0x231c,
  "ulcorner;": 0x231c, "ulcrop;": 0x230f,
  "ultri;": 0x25f8, "umacr;": 0x16b,
  "uml": 0xa8, "uml;": 0xa8,
  "uogon;": 0x173, "uopf;": [0xd835, 0xdd66],
  "uparrow;": 0x2191, "updownarrow;": 0x2195,
  "upharpoonleft;": 0x21bf, "upharpoonright;": 0x21be,
  "uplus;": 0x228e, "upsi;": 0x3c5,
  "upsih;": 0x3d2, "upsilon;": 0x3c5,
  "upuparrows;": 0x21c8, "urcorn;": 0x231d,
  "urcorner;": 0x231d, "urcrop;": 0x230e,
  "uring;": 0x16f, "urtri;": 0x25f9,
  "uscr;": [0xd835, 0xdcca], "utdot;": 0x22f0,
  "utilde;": 0x169, "utri;": 0x25b5,
  "utrif;": 0x25b4, "uuarr;": 0x21c8,
  "uuml": 0xfc, "uuml;": 0xfc,
  "uwangle;": 0x29a7, "vArr;": 0x21d5,
  "vBar;": 0x2ae8, "vBarv;": 0x2ae9,
  "vDash;": 0x22a8, "vangrt;": 0x299c,
  "varepsilon;": 0x3f5, "varkappa;": 0x3f0,
  "varnothing;": 0x2205, "varphi;": 0x3d5,
  "varpi;": 0x3d6, "varpropto;": 0x221d,
  "varr;": 0x2195, "varrho;": 0x3f1,
  "varsigma;": 0x3c2, "varsubsetneq;": [0x228a, 0xfe00],
  "varsubsetneqq;": [0x2acb, 0xfe00], "varsupsetneq;": [0x228b, 0xfe00],
  "varsupsetneqq;": [0x2acc, 0xfe00], "vartheta;": 0x3d1,
  "vartriangleleft;": 0x22b2, "vartriangleright;": 0x22b3,
  "vcy;": 0x432, "vdash;": 0x22a2,
  "vee;": 0x2228, "veebar;": 0x22bb,
  "veeeq;": 0x225a, "vellip;": 0x22ee,
  "verbar;": 0x7c, "vert;": 0x7c,
  "vfr;": [0xd835, 0xdd33], "vltri;": 0x22b2,
  "vnsub;": [0x2282, 0x20d2], "vnsup;": [0x2283, 0x20d2],
  "vopf;": [0xd835, 0xdd67], "vprop;": 0x221d,
  "vrtri;": 0x22b3, "vscr;": [0xd835, 0xdccb],
  "vsubnE;": [0x2acb, 0xfe00], "vsubne;": [0x228a, 0xfe00],
  "vsupnE;": [0x2acc, 0xfe00], "vsupne;": [0x228b, 0xfe00],
  "vzigzag;": 0x299a, "wcirc;": 0x175,
  "wedbar;": 0x2a5f, "wedge;": 0x2227,
  "wedgeq;": 0x2259, "weierp;": 0x2118,
  "wfr;": [0xd835, 0xdd34], "wopf;": [0xd835, 0xdd68],
  "wp;": 0x2118, "wr;": 0x2240,
  "wreath;": 0x2240, "wscr;": [0xd835, 0xdccc],
  "xcap;": 0x22c2, "xcirc;": 0x25ef,
  "xcup;": 0x22c3, "xdtri;": 0x25bd,
  "xfr;": [0xd835, 0xdd35], "xhArr;": 0x27fa,
  "xharr;": 0x27f7, "xi;": 0x3be,
  "xlArr;": 0x27f8, "xlarr;": 0x27f5,
  "xmap;": 0x27fc, "xnis;": 0x22fb,
  "xodot;": 0x2a00, "xopf;": [0xd835, 0xdd69],
  "xoplus;": 0x2a01, "xotime;": 0x2a02,
  "xrArr;": 0x27f9, "xrarr;": 0x27f6,
  "xscr;": [0xd835, 0xdccd], "xsqcup;": 0x2a06,
  "xuplus;": 0x2a04, "xutri;": 0x25b3,
  "xvee;": 0x22c1, "xwedge;": 0x22c0,
  "yacute": 0xfd, "yacute;": 0xfd,
  "yacy;": 0x44f, "ycirc;": 0x177,
  "ycy;": 0x44b, "yen": 0xa5,
  "yen;": 0xa5, "yfr;": [0xd835, 0xdd36],
  "yicy;": 0x457, "yopf;": [0xd835, 0xdd6a],
  "yscr;": [0xd835, 0xdcce], "yucy;": 0x44e,
  "yuml": 0xff, "yuml;": 0xff,
  "zacute;": 0x17a, "zcaron;": 0x17e,
  "zcy;": 0x437, "zdot;": 0x17c,
  "zeetrf;": 0x2128, "zeta;": 0x3b6,
  "zfr;": [0xd835, 0xdd37], "zhcy;": 0x436,
  "zigrarr;": 0x21dd, "zopf;": [0xd835, 0xdd6b],
  "zscr;": [0xd835, 0xdccf], "zwj;": 0x200d,
  "zwnj;": 0x200c
};
/*
 * This regexp is generated with test/tools/update-entities.js
 * It will always match at least one character -- but note that there
 * are no entities whose names are a single character long.
 */
var NAMEDCHARREF = /(A(?:Elig;?|MP;?|acute;?|breve;|c(?:irc;?|y;)|fr;|grave;?|lpha;|macr;|nd;|o(?:gon;|pf;)|pplyFunction;|ring;?|s(?:cr;|sign;)|tilde;?|uml;?)|B(?:a(?:ckslash;|r(?:v;|wed;))|cy;|e(?:cause;|rnoullis;|ta;)|fr;|opf;|reve;|scr;|umpeq;)|C(?:Hcy;|OPY;?|a(?:cute;|p(?:;|italDifferentialD;)|yleys;)|c(?:aron;|edil;?|irc;|onint;)|dot;|e(?:dilla;|nterDot;)|fr;|hi;|ircle(?:Dot;|Minus;|Plus;|Times;)|lo(?:ckwiseContourIntegral;|seCurly(?:DoubleQuote;|Quote;))|o(?:lon(?:;|e;)|n(?:gruent;|int;|tourIntegral;)|p(?:f;|roduct;)|unterClockwiseContourIntegral;)|ross;|scr;|up(?:;|Cap;))|D(?:D(?:;|otrahd;)|Jcy;|Scy;|Zcy;|a(?:gger;|rr;|shv;)|c(?:aron;|y;)|el(?:;|ta;)|fr;|i(?:a(?:critical(?:Acute;|Do(?:t;|ubleAcute;)|Grave;|Tilde;)|mond;)|fferentialD;)|o(?:pf;|t(?:;|Dot;|Equal;)|uble(?:ContourIntegral;|Do(?:t;|wnArrow;)|L(?:eft(?:Arrow;|RightArrow;|Tee;)|ong(?:Left(?:Arrow;|RightArrow;)|RightArrow;))|Right(?:Arrow;|Tee;)|Up(?:Arrow;|DownArrow;)|VerticalBar;)|wn(?:Arrow(?:;|Bar;|UpArrow;)|Breve;|Left(?:RightVector;|TeeVector;|Vector(?:;|Bar;))|Right(?:TeeVector;|Vector(?:;|Bar;))|Tee(?:;|Arrow;)|arrow;))|s(?:cr;|trok;))|E(?:NG;|TH;?|acute;?|c(?:aron;|irc;?|y;)|dot;|fr;|grave;?|lement;|m(?:acr;|pty(?:SmallSquare;|VerySmallSquare;))|o(?:gon;|pf;)|psilon;|qu(?:al(?:;|Tilde;)|ilibrium;)|s(?:cr;|im;)|ta;|uml;?|x(?:ists;|ponentialE;))|F(?:cy;|fr;|illed(?:SmallSquare;|VerySmallSquare;)|o(?:pf;|rAll;|uriertrf;)|scr;)|G(?:Jcy;|T;?|amma(?:;|d;)|breve;|c(?:edil;|irc;|y;)|dot;|fr;|g;|opf;|reater(?:Equal(?:;|Less;)|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|scr;|t;)|H(?:ARDcy;|a(?:cek;|t;)|circ;|fr;|ilbertSpace;|o(?:pf;|rizontalLine;)|s(?:cr;|trok;)|ump(?:DownHump;|Equal;))|I(?:Ecy;|Jlig;|Ocy;|acute;?|c(?:irc;?|y;)|dot;|fr;|grave;?|m(?:;|a(?:cr;|ginaryI;)|plies;)|n(?:t(?:;|e(?:gral;|rsection;))|visible(?:Comma;|Times;))|o(?:gon;|pf;|ta;)|scr;|tilde;|u(?:kcy;|ml;?))|J(?:c(?:irc;|y;)|fr;|opf;|s(?:cr;|ercy;)|ukcy;)|K(?:Hcy;|Jcy;|appa;|c(?:edil;|y;)|fr;|opf;|scr;)|L(?:Jcy;|T;?|a(?:cute;|mbda;|ng;|placetrf;|rr;)|c(?:aron;|edil;|y;)|e(?:ft(?:A(?:ngleBracket;|rrow(?:;|Bar;|RightArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|Right(?:Arrow;|Vector;)|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;|rightarrow;)|ss(?:EqualGreater;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;))|fr;|l(?:;|eftarrow;)|midot;|o(?:ng(?:Left(?:Arrow;|RightArrow;)|RightArrow;|left(?:arrow;|rightarrow;)|rightarrow;)|pf;|wer(?:LeftArrow;|RightArrow;))|s(?:cr;|h;|trok;)|t;)|M(?:ap;|cy;|e(?:diumSpace;|llintrf;)|fr;|inusPlus;|opf;|scr;|u;)|N(?:Jcy;|acute;|c(?:aron;|edil;|y;)|e(?:gative(?:MediumSpace;|Thi(?:ckSpace;|nSpace;)|VeryThinSpace;)|sted(?:GreaterGreater;|LessLess;)|wLine;)|fr;|o(?:Break;|nBreakingSpace;|pf;|t(?:;|C(?:ongruent;|upCap;)|DoubleVerticalBar;|E(?:lement;|qual(?:;|Tilde;)|xists;)|Greater(?:;|Equal;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|Hump(?:DownHump;|Equal;)|Le(?:ftTriangle(?:;|Bar;|Equal;)|ss(?:;|Equal;|Greater;|Less;|SlantEqual;|Tilde;))|Nested(?:GreaterGreater;|LessLess;)|Precedes(?:;|Equal;|SlantEqual;)|R(?:everseElement;|ightTriangle(?:;|Bar;|Equal;))|S(?:quareSu(?:bset(?:;|Equal;)|perset(?:;|Equal;))|u(?:bset(?:;|Equal;)|cceeds(?:;|Equal;|SlantEqual;|Tilde;)|perset(?:;|Equal;)))|Tilde(?:;|Equal;|FullEqual;|Tilde;)|VerticalBar;))|scr;|tilde;?|u;)|O(?:Elig;|acute;?|c(?:irc;?|y;)|dblac;|fr;|grave;?|m(?:acr;|ega;|icron;)|opf;|penCurly(?:DoubleQuote;|Quote;)|r;|s(?:cr;|lash;?)|ti(?:lde;?|mes;)|uml;?|ver(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;))|P(?:artialD;|cy;|fr;|hi;|i;|lusMinus;|o(?:incareplane;|pf;)|r(?:;|ecedes(?:;|Equal;|SlantEqual;|Tilde;)|ime;|o(?:duct;|portion(?:;|al;)))|s(?:cr;|i;))|Q(?:UOT;?|fr;|opf;|scr;)|R(?:Barr;|EG;?|a(?:cute;|ng;|rr(?:;|tl;))|c(?:aron;|edil;|y;)|e(?:;|verse(?:E(?:lement;|quilibrium;)|UpEquilibrium;))|fr;|ho;|ight(?:A(?:ngleBracket;|rrow(?:;|Bar;|LeftArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;)|o(?:pf;|undImplies;)|rightarrow;|s(?:cr;|h;)|uleDelayed;)|S(?:H(?:CHcy;|cy;)|OFTcy;|acute;|c(?:;|aron;|edil;|irc;|y;)|fr;|hort(?:DownArrow;|LeftArrow;|RightArrow;|UpArrow;)|igma;|mallCircle;|opf;|q(?:rt;|uare(?:;|Intersection;|Su(?:bset(?:;|Equal;)|perset(?:;|Equal;))|Union;))|scr;|tar;|u(?:b(?:;|set(?:;|Equal;))|c(?:ceeds(?:;|Equal;|SlantEqual;|Tilde;)|hThat;)|m;|p(?:;|erset(?:;|Equal;)|set;)))|T(?:HORN;?|RADE;|S(?:Hcy;|cy;)|a(?:b;|u;)|c(?:aron;|edil;|y;)|fr;|h(?:e(?:refore;|ta;)|i(?:ckSpace;|nSpace;))|ilde(?:;|Equal;|FullEqual;|Tilde;)|opf;|ripleDot;|s(?:cr;|trok;))|U(?:a(?:cute;?|rr(?:;|ocir;))|br(?:cy;|eve;)|c(?:irc;?|y;)|dblac;|fr;|grave;?|macr;|n(?:der(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;)|ion(?:;|Plus;))|o(?:gon;|pf;)|p(?:Arrow(?:;|Bar;|DownArrow;)|DownArrow;|Equilibrium;|Tee(?:;|Arrow;)|arrow;|downarrow;|per(?:LeftArrow;|RightArrow;)|si(?:;|lon;))|ring;|scr;|tilde;|uml;?)|V(?:Dash;|bar;|cy;|dash(?:;|l;)|e(?:e;|r(?:bar;|t(?:;|ical(?:Bar;|Line;|Separator;|Tilde;))|yThinSpace;))|fr;|opf;|scr;|vdash;)|W(?:circ;|edge;|fr;|opf;|scr;)|X(?:fr;|i;|opf;|scr;)|Y(?:Acy;|Icy;|Ucy;|acute;?|c(?:irc;|y;)|fr;|opf;|scr;|uml;)|Z(?:Hcy;|acute;|c(?:aron;|y;)|dot;|e(?:roWidthSpace;|ta;)|fr;|opf;|scr;)|a(?:acute;?|breve;|c(?:;|E;|d;|irc;?|ute;?|y;)|elig;?|f(?:;|r;)|grave;?|l(?:e(?:fsym;|ph;)|pha;)|m(?:a(?:cr;|lg;)|p;?)|n(?:d(?:;|and;|d;|slope;|v;)|g(?:;|e;|le;|msd(?:;|a(?:a;|b;|c;|d;|e;|f;|g;|h;))|rt(?:;|vb(?:;|d;))|s(?:ph;|t;)|zarr;))|o(?:gon;|pf;)|p(?:;|E;|acir;|e;|id;|os;|prox(?:;|eq;))|ring;?|s(?:cr;|t;|ymp(?:;|eq;))|tilde;?|uml;?|w(?:conint;|int;))|b(?:Not;|a(?:ck(?:cong;|epsilon;|prime;|sim(?:;|eq;))|r(?:vee;|wed(?:;|ge;)))|brk(?:;|tbrk;)|c(?:ong;|y;)|dquo;|e(?:caus(?:;|e;)|mptyv;|psi;|rnou;|t(?:a;|h;|ween;))|fr;|ig(?:c(?:ap;|irc;|up;)|o(?:dot;|plus;|times;)|s(?:qcup;|tar;)|triangle(?:down;|up;)|uplus;|vee;|wedge;)|karow;|l(?:a(?:ck(?:lozenge;|square;|triangle(?:;|down;|left;|right;))|nk;)|k(?:1(?:2;|4;)|34;)|ock;)|n(?:e(?:;|quiv;)|ot;)|o(?:pf;|t(?:;|tom;)|wtie;|x(?:D(?:L;|R;|l;|r;)|H(?:;|D;|U;|d;|u;)|U(?:L;|R;|l;|r;)|V(?:;|H;|L;|R;|h;|l;|r;)|box;|d(?:L;|R;|l;|r;)|h(?:;|D;|U;|d;|u;)|minus;|plus;|times;|u(?:L;|R;|l;|r;)|v(?:;|H;|L;|R;|h;|l;|r;)))|prime;|r(?:eve;|vbar;?)|s(?:cr;|emi;|im(?:;|e;)|ol(?:;|b;|hsub;))|u(?:ll(?:;|et;)|mp(?:;|E;|e(?:;|q;))))|c(?:a(?:cute;|p(?:;|and;|brcup;|c(?:ap;|up;)|dot;|s;)|r(?:et;|on;))|c(?:a(?:ps;|ron;)|edil;?|irc;|ups(?:;|sm;))|dot;|e(?:dil;?|mptyv;|nt(?:;|erdot;|))|fr;|h(?:cy;|eck(?:;|mark;)|i;)|ir(?:;|E;|c(?:;|eq;|le(?:arrow(?:left;|right;)|d(?:R;|S;|ast;|circ;|dash;)))|e;|fnint;|mid;|scir;)|lubs(?:;|uit;)|o(?:lon(?:;|e(?:;|q;))|m(?:ma(?:;|t;)|p(?:;|fn;|le(?:ment;|xes;)))|n(?:g(?:;|dot;)|int;)|p(?:f;|rod;|y(?:;|sr;|)))|r(?:arr;|oss;)|s(?:cr;|u(?:b(?:;|e;)|p(?:;|e;)))|tdot;|u(?:darr(?:l;|r;)|e(?:pr;|sc;)|larr(?:;|p;)|p(?:;|brcap;|c(?:ap;|up;)|dot;|or;|s;)|r(?:arr(?:;|m;)|ly(?:eq(?:prec;|succ;)|vee;|wedge;)|ren;?|vearrow(?:left;|right;))|vee;|wed;)|w(?:conint;|int;)|ylcty;)|d(?:Arr;|Har;|a(?:gger;|leth;|rr;|sh(?:;|v;))|b(?:karow;|lac;)|c(?:aron;|y;)|d(?:;|a(?:gger;|rr;)|otseq;)|e(?:g;?|lta;|mptyv;)|f(?:isht;|r;)|har(?:l;|r;)|i(?:am(?:;|ond(?:;|suit;)|s;)|e;|gamma;|sin;|v(?:;|ide(?:;|ontimes;|)|onx;))|jcy;|lc(?:orn;|rop;)|o(?:llar;|pf;|t(?:;|eq(?:;|dot;)|minus;|plus;|square;)|ublebarwedge;|wn(?:arrow;|downarrows;|harpoon(?:left;|right;)))|r(?:bkarow;|c(?:orn;|rop;))|s(?:c(?:r;|y;)|ol;|trok;)|t(?:dot;|ri(?:;|f;))|u(?:arr;|har;)|wangle;|z(?:cy;|igrarr;))|e(?:D(?:Dot;|ot;)|a(?:cute;?|ster;)|c(?:aron;|ir(?:;|c;?)|olon;|y;)|dot;|e;|f(?:Dot;|r;)|g(?:;|rave;?|s(?:;|dot;))|l(?:;|inters;|l;|s(?:;|dot;))|m(?:acr;|pty(?:;|set;|v;)|sp(?:1(?:3;|4;)|;))|n(?:g;|sp;)|o(?:gon;|pf;)|p(?:ar(?:;|sl;)|lus;|si(?:;|lon;|v;))|q(?:c(?:irc;|olon;)|s(?:im;|lant(?:gtr;|less;))|u(?:als;|est;|iv(?:;|DD;))|vparsl;)|r(?:Dot;|arr;)|s(?:cr;|dot;|im;)|t(?:a;|h;?)|u(?:ml;?|ro;)|x(?:cl;|ist;|p(?:ectation;|onentiale;)))|f(?:allingdotseq;|cy;|emale;|f(?:ilig;|l(?:ig;|lig;)|r;)|ilig;|jlig;|l(?:at;|lig;|tns;)|nof;|o(?:pf;|r(?:all;|k(?:;|v;)))|partint;|r(?:a(?:c(?:1(?:2;?|3;|4;?|5;|6;|8;)|2(?:3;|5;)|3(?:4;?|5;|8;)|45;|5(?:6;|8;)|78;)|sl;)|own;)|scr;)|g(?:E(?:;|l;)|a(?:cute;|mma(?:;|d;)|p;)|breve;|c(?:irc;|y;)|dot;|e(?:;|l;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|l;))|l(?:;|es;)))|fr;|g(?:;|g;)|imel;|jcy;|l(?:;|E;|a;|j;)|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|opf;|rave;|s(?:cr;|im(?:;|e;|l;))|t(?:;|c(?:c;|ir;)|dot;|lPar;|quest;|r(?:a(?:pprox;|rr;)|dot;|eq(?:less;|qless;)|less;|sim;)|)|v(?:ertneqq;|nE;))|h(?:Arr;|a(?:irsp;|lf;|milt;|r(?:dcy;|r(?:;|cir;|w;)))|bar;|circ;|e(?:arts(?:;|uit;)|llip;|rcon;)|fr;|ks(?:earow;|warow;)|o(?:arr;|mtht;|ok(?:leftarrow;|rightarrow;)|pf;|rbar;)|s(?:cr;|lash;|trok;)|y(?:bull;|phen;))|i(?:acute;?|c(?:;|irc;?|y;)|e(?:cy;|xcl;?)|f(?:f;|r;)|grave;?|i(?:;|i(?:int;|nt;)|nfin;|ota;)|jlig;|m(?:a(?:cr;|g(?:e;|line;|part;)|th;)|of;|ped;)|n(?:;|care;|fin(?:;|tie;)|odot;|t(?:;|cal;|e(?:gers;|rcal;)|larhk;|prod;))|o(?:cy;|gon;|pf;|ta;)|prod;|quest;?|s(?:cr;|in(?:;|E;|dot;|s(?:;|v;)|v;))|t(?:;|ilde;)|u(?:kcy;|ml;?))|j(?:c(?:irc;|y;)|fr;|math;|opf;|s(?:cr;|ercy;)|ukcy;)|k(?:appa(?:;|v;)|c(?:edil;|y;)|fr;|green;|hcy;|jcy;|opf;|scr;)|l(?:A(?:arr;|rr;|tail;)|Barr;|E(?:;|g;)|Har;|a(?:cute;|emptyv;|gran;|mbda;|ng(?:;|d;|le;)|p;|quo;?|rr(?:;|b(?:;|fs;)|fs;|hk;|lp;|pl;|sim;|tl;)|t(?:;|ail;|e(?:;|s;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|quo(?:;|r;)|r(?:dhar;|ushar;)|sh;)|e(?:;|ft(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|leftarrows;|right(?:arrow(?:;|s;)|harpoons;|squigarrow;)|threetimes;)|g;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|r;))|g(?:;|es;)|s(?:approx;|dot;|eq(?:gtr;|qgtr;)|gtr;|sim;)))|f(?:isht;|loor;|r;)|g(?:;|E;)|h(?:ar(?:d;|u(?:;|l;))|blk;)|jcy;|l(?:;|arr;|corner;|hard;|tri;)|m(?:idot;|oust(?:;|ache;))|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|o(?:a(?:ng;|rr;)|brk;|ng(?:left(?:arrow;|rightarrow;)|mapsto;|rightarrow;)|oparrow(?:left;|right;)|p(?:ar;|f;|lus;)|times;|w(?:ast;|bar;)|z(?:;|enge;|f;))|par(?:;|lt;)|r(?:arr;|corner;|har(?:;|d;)|m;|tri;)|s(?:aquo;|cr;|h;|im(?:;|e;|g;)|q(?:b;|uo(?:;|r;))|trok;)|t(?:;|c(?:c;|ir;)|dot;|hree;|imes;|larr;|quest;|r(?:Par;|i(?:;|e;|f;))|)|ur(?:dshar;|uhar;)|v(?:ertneqq;|nE;))|m(?:DDot;|a(?:cr;?|l(?:e;|t(?:;|ese;))|p(?:;|sto(?:;|down;|left;|up;))|rker;)|c(?:omma;|y;)|dash;|easuredangle;|fr;|ho;|i(?:cro;?|d(?:;|ast;|cir;|dot;?)|nus(?:;|b;|d(?:;|u;)))|l(?:cp;|dr;)|nplus;|o(?:dels;|pf;)|p;|s(?:cr;|tpos;)|u(?:;|ltimap;|map;))|n(?:G(?:g;|t(?:;|v;))|L(?:eft(?:arrow;|rightarrow;)|l;|t(?:;|v;))|Rightarrow;|V(?:Dash;|dash;)|a(?:bla;|cute;|ng;|p(?:;|E;|id;|os;|prox;)|tur(?:;|al(?:;|s;)))|b(?:sp;?|ump(?:;|e;))|c(?:a(?:p;|ron;)|edil;|ong(?:;|dot;)|up;|y;)|dash;|e(?:;|Arr;|ar(?:hk;|r(?:;|ow;))|dot;|quiv;|s(?:ear;|im;)|xist(?:;|s;))|fr;|g(?:E;|e(?:;|q(?:;|q;|slant;)|s;)|sim;|t(?:;|r;))|h(?:Arr;|arr;|par;)|i(?:;|s(?:;|d;)|v;)|jcy;|l(?:Arr;|E;|arr;|dr;|e(?:;|ft(?:arrow;|rightarrow;)|q(?:;|q;|slant;)|s(?:;|s;))|sim;|t(?:;|ri(?:;|e;)))|mid;|o(?:pf;|t(?:;|in(?:;|E;|dot;|v(?:a;|b;|c;))|ni(?:;|v(?:a;|b;|c;))|))|p(?:ar(?:;|allel;|sl;|t;)|olint;|r(?:;|cue;|e(?:;|c(?:;|eq;))))|r(?:Arr;|arr(?:;|c;|w;)|ightarrow;|tri(?:;|e;))|s(?:c(?:;|cue;|e;|r;)|hort(?:mid;|parallel;)|im(?:;|e(?:;|q;))|mid;|par;|qsu(?:be;|pe;)|u(?:b(?:;|E;|e;|set(?:;|eq(?:;|q;)))|cc(?:;|eq;)|p(?:;|E;|e;|set(?:;|eq(?:;|q;)))))|t(?:gl;|ilde;?|lg;|riangle(?:left(?:;|eq;)|right(?:;|eq;)))|u(?:;|m(?:;|ero;|sp;))|v(?:Dash;|Harr;|ap;|dash;|g(?:e;|t;)|infin;|l(?:Arr;|e;|t(?:;|rie;))|r(?:Arr;|trie;)|sim;)|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|near;))|o(?:S;|a(?:cute;?|st;)|c(?:ir(?:;|c;?)|y;)|d(?:ash;|blac;|iv;|ot;|sold;)|elig;|f(?:cir;|r;)|g(?:on;|rave;?|t;)|h(?:bar;|m;)|int;|l(?:arr;|c(?:ir;|ross;)|ine;|t;)|m(?:acr;|ega;|i(?:cron;|d;|nus;))|opf;|p(?:ar;|erp;|lus;)|r(?:;|arr;|d(?:;|er(?:;|of;)|f;?|m;?)|igof;|or;|slope;|v;)|s(?:cr;|lash;?|ol;)|ti(?:lde;?|mes(?:;|as;))|uml;?|vbar;)|p(?:ar(?:;|a(?:;|llel;|)|s(?:im;|l;)|t;)|cy;|er(?:cnt;|iod;|mil;|p;|tenk;)|fr;|h(?:i(?:;|v;)|mmat;|one;)|i(?:;|tchfork;|v;)|l(?:an(?:ck(?:;|h;)|kv;)|us(?:;|acir;|b;|cir;|d(?:o;|u;)|e;|mn;?|sim;|two;))|m;|o(?:intint;|pf;|und;?)|r(?:;|E;|ap;|cue;|e(?:;|c(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;))|ime(?:;|s;)|n(?:E;|ap;|sim;)|o(?:d;|f(?:alar;|line;|surf;)|p(?:;|to;))|sim;|urel;)|s(?:cr;|i;)|uncsp;)|q(?:fr;|int;|opf;|prime;|scr;|u(?:at(?:ernions;|int;)|est(?:;|eq;)|ot;?))|r(?:A(?:arr;|rr;|tail;)|Barr;|Har;|a(?:c(?:e;|ute;)|dic;|emptyv;|ng(?:;|d;|e;|le;)|quo;?|rr(?:;|ap;|b(?:;|fs;)|c;|fs;|hk;|lp;|pl;|sim;|tl;|w;)|t(?:ail;|io(?:;|nals;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|ldhar;|quo(?:;|r;)|sh;)|e(?:al(?:;|ine;|part;|s;)|ct;|g;?)|f(?:isht;|loor;|r;)|h(?:ar(?:d;|u(?:;|l;))|o(?:;|v;))|i(?:ght(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|left(?:arrows;|harpoons;)|rightarrows;|squigarrow;|threetimes;)|ng;|singdotseq;)|l(?:arr;|har;|m;)|moust(?:;|ache;)|nmid;|o(?:a(?:ng;|rr;)|brk;|p(?:ar;|f;|lus;)|times;)|p(?:ar(?:;|gt;)|polint;)|rarr;|s(?:aquo;|cr;|h;|q(?:b;|uo(?:;|r;)))|t(?:hree;|imes;|ri(?:;|e;|f;|ltri;))|uluhar;|x;)|s(?:acute;|bquo;|c(?:;|E;|a(?:p;|ron;)|cue;|e(?:;|dil;)|irc;|n(?:E;|ap;|sim;)|polint;|sim;|y;)|dot(?:;|b;|e;)|e(?:Arr;|ar(?:hk;|r(?:;|ow;))|ct;?|mi;|swar;|tm(?:inus;|n;)|xt;)|fr(?:;|own;)|h(?:arp;|c(?:hcy;|y;)|ort(?:mid;|parallel;)|y;?)|i(?:gma(?:;|f;|v;)|m(?:;|dot;|e(?:;|q;)|g(?:;|E;)|l(?:;|E;)|ne;|plus;|rarr;))|larr;|m(?:a(?:llsetminus;|shp;)|eparsl;|i(?:d;|le;)|t(?:;|e(?:;|s;)))|o(?:ftcy;|l(?:;|b(?:;|ar;))|pf;)|pa(?:des(?:;|uit;)|r;)|q(?:c(?:ap(?:;|s;)|up(?:;|s;))|su(?:b(?:;|e;|set(?:;|eq;))|p(?:;|e;|set(?:;|eq;)))|u(?:;|ar(?:e;|f;)|f;))|rarr;|s(?:cr;|etmn;|mile;|tarf;)|t(?:ar(?:;|f;)|r(?:aight(?:epsilon;|phi;)|ns;))|u(?:b(?:;|E;|dot;|e(?:;|dot;)|mult;|n(?:E;|e;)|plus;|rarr;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;)))|cc(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;)|m;|ng;|p(?:1;?|2;?|3;?|;|E;|d(?:ot;|sub;)|e(?:;|dot;)|hs(?:ol;|ub;)|larr;|mult;|n(?:E;|e;)|plus;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;))))|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|nwar;)|zlig;?)|t(?:a(?:rget;|u;)|brk;|c(?:aron;|edil;|y;)|dot;|elrec;|fr;|h(?:e(?:re(?:4;|fore;)|ta(?:;|sym;|v;))|i(?:ck(?:approx;|sim;)|nsp;)|k(?:ap;|sim;)|orn;?)|i(?:lde;|mes(?:;|b(?:;|ar;)|d;|)|nt;)|o(?:ea;|p(?:;|bot;|cir;|f(?:;|ork;))|sa;)|prime;|r(?:ade;|i(?:angle(?:;|down;|left(?:;|eq;)|q;|right(?:;|eq;))|dot;|e;|minus;|plus;|sb;|time;)|pezium;)|s(?:c(?:r;|y;)|hcy;|trok;)|w(?:ixt;|ohead(?:leftarrow;|rightarrow;)))|u(?:Arr;|Har;|a(?:cute;?|rr;)|br(?:cy;|eve;)|c(?:irc;?|y;)|d(?:arr;|blac;|har;)|f(?:isht;|r;)|grave;?|h(?:ar(?:l;|r;)|blk;)|l(?:c(?:orn(?:;|er;)|rop;)|tri;)|m(?:acr;|l;?)|o(?:gon;|pf;)|p(?:arrow;|downarrow;|harpoon(?:left;|right;)|lus;|si(?:;|h;|lon;)|uparrows;)|r(?:c(?:orn(?:;|er;)|rop;)|ing;|tri;)|scr;|t(?:dot;|ilde;|ri(?:;|f;))|u(?:arr;|ml;?)|wangle;)|v(?:Arr;|Bar(?:;|v;)|Dash;|a(?:ngrt;|r(?:epsilon;|kappa;|nothing;|p(?:hi;|i;|ropto;)|r(?:;|ho;)|s(?:igma;|u(?:bsetneq(?:;|q;)|psetneq(?:;|q;)))|t(?:heta;|riangle(?:left;|right;))))|cy;|dash;|e(?:e(?:;|bar;|eq;)|llip;|r(?:bar;|t;))|fr;|ltri;|nsu(?:b;|p;)|opf;|prop;|rtri;|s(?:cr;|u(?:bn(?:E;|e;)|pn(?:E;|e;)))|zigzag;)|w(?:circ;|e(?:d(?:bar;|ge(?:;|q;))|ierp;)|fr;|opf;|p;|r(?:;|eath;)|scr;)|x(?:c(?:ap;|irc;|up;)|dtri;|fr;|h(?:Arr;|arr;)|i;|l(?:Arr;|arr;)|map;|nis;|o(?:dot;|p(?:f;|lus;)|time;)|r(?:Arr;|arr;)|s(?:cr;|qcup;)|u(?:plus;|tri;)|vee;|wedge;)|y(?:ac(?:ute;?|y;)|c(?:irc;|y;)|en;?|fr;|icy;|opf;|scr;|u(?:cy;|ml;?))|z(?:acute;|c(?:aron;|y;)|dot;|e(?:etrf;|ta;)|fr;|hcy;|igrarr;|opf;|scr;|w(?:j;|nj;)))|[\s\S]/g;

var NAMEDCHARREF_MAXLEN = 32;

// Regular expression constants used by the tokenizer and parser

// Note that \r is included in all of these regexps because it will need
// to be converted to LF by the scanChars() function.
var DBLQUOTEATTRVAL = /[^\r"&\u0000]+/g;
var SINGLEQUOTEATTRVAL = /[^\r'&\u0000]+/g;
var UNQUOTEDATTRVAL = /[^\r\t\n\f &>\u0000]+/g;
var TAGNAME = /[^\r\t\n\f \/>A-Z\u0000]+/g;
var ATTRNAME = /[^\r\t\n\f \/=>A-Z\u0000]+/g;

var CDATATEXT = /[^\]\r\u0000\uffff]*/g;
var DATATEXT = /[^&<\r\u0000\uffff]*/g;
var RAWTEXT = /[^<\r\u0000\uffff]*/g;
var PLAINTEXT = /[^\r\u0000\uffff]*/g;
// Since we don't have the 'sticky tag', add '|.' to the end of SIMPLETAG
// and SIMPLEATTR so that we are guaranteed to always match.  This prevents
// us from scanning past the lastIndex set. (Note that the desired matches
// are always greater than 1 char long, so longest-match will ensure that .
// is not matched unless the desired match fails.)
var SIMPLETAG = /(?:(\/)?([a-z]+)>)|[\s\S]/g;
var SIMPLEATTR = /(?:([-a-z]+)[ \t\n\f]*=[ \t\n\f]*('[^'&\r\u0000]*'|"[^"&\r\u0000]*"|[^\t\n\r\f "&'\u0000>][^&> \t\n\r\f\u0000]*[ \t\n\f]))|[\s\S]/g;

var NONWS = /[^\x09\x0A\x0C\x0D\x20]/;
var ALLNONWS = /[^\x09\x0A\x0C\x0D\x20]/g; // like above, with g flag
var NONWSNONNUL = /[^\x00\x09\x0A\x0C\x0D\x20]/; // don't allow NUL either
var LEADINGWS = /^[\x09\x0A\x0C\x0D\x20]+/;
var NULCHARS = /\x00/g;

/***
 * These are utility functions that don't use any of the parser's
 * internal state.
 */
function buf2str(buf) {
  var CHUNKSIZE = 16384;
  if (buf.length < CHUNKSIZE) {
    return String.fromCharCode.apply(String, buf);
  }
  // special case for large strings, to avoid busting the stack.
  var result = '';
  for (var i = 0; i < buf.length; i += CHUNKSIZE) {
    result += String.fromCharCode.apply(String, buf.slice(i, i + CHUNKSIZE));
  }
  return result;
}

function str2buf(s) {
  var result = [];
  for (var i = 0; i < s.length; i++) {
    result[i] = s.charCodeAt(i);
  }
  return result;
}

// Determine whether the element is a member of the set.
// The set is an object that maps namespaces to objects. The objects
// then map local tagnames to the value true if that tag is part of the set
function isA(elt, set) {
  if (typeof set === 'string') {
    // convenience case for testing a particular HTML element
    return elt.namespaceURI === NAMESPACE.HTML && elt.localName === set;
  }
  var tagnames = set[elt.namespaceURI];
  return tagnames && tagnames[elt.localName];
}

function isMathmlTextIntegrationPoint(n) {
  return isA(n, mathmlTextIntegrationPointSet);
}

function isHTMLIntegrationPoint(n) {
  if (isA(n, htmlIntegrationPointSet)) return true;
  if (n.namespaceURI === NAMESPACE.MATHML && n.localName === "annotation-xml") {
    var encoding = n.getAttribute("encoding");
    if (encoding) encoding = encoding.toLowerCase();
    if (encoding === "text/html" || encoding === "application/xhtml+xml") return true;
  }
  return false;
}

function adjustSVGTagName(name) {
  if (name in svgTagNameAdjustments) return svgTagNameAdjustments[name];else return name;
}

function adjustSVGAttributes(attrs) {
  for (var i = 0, n = attrs.length; i < n; i++) {
    if (attrs[i][0] in svgAttrAdjustments) {
      attrs[i][0] = svgAttrAdjustments[attrs[i][0]];
    }
  }
}

function adjustMathMLAttributes(attrs) {
  for (var i = 0, n = attrs.length; i < n; i++) {
    if (attrs[i][0] === "definitionurl") {
      attrs[i][0] = "definitionURL";
      break;
    }
  }
}

function adjustForeignAttributes(attrs) {
  for (var i = 0, n = attrs.length; i < n; i++) {
    if (attrs[i][0] in foreignAttributes) {
      // Attributes with namespaces get a 3rd element:
      // [Qname, value, namespace]
      attrs[i].push(foreignAttributes[attrs[i][0]]);
    }
  }
}

// For each attribute in attrs, if elt doesn't have an attribute
// by that name, add the attribute to elt
// XXX: I'm ignoring namespaces for now
function transferAttributes(attrs, elt) {
  for (var i = 0, n = attrs.length; i < n; i++) {
    var name = attrs[i][0],
        value = attrs[i][1];
    if (elt.hasAttribute(name)) continue;
    elt._setAttribute(name, value);
  }
}

/***
 * The ElementStack class
 */
HTMLParser.ElementStack = function ElementStack() {
  this.elements = [];
  this.top = null; // stack.top is the "current node" in the spec
};

/*
// This is for debugging only
HTMLParser.ElementStack.prototype.toString = function(e) {
  return "STACK: " +
  this.elements.map(function(e) {return e.localName;}).join("-");
}
*/

HTMLParser.ElementStack.prototype.push = function (e) {
  this.elements.push(e);
  this.top = e;
};

HTMLParser.ElementStack.prototype.pop = function (e) {
  this.elements.pop();
  this.top = this.elements[this.elements.length - 1];
};

// Pop elements off the stack up to and including the first
// element with the specified (HTML) tagname
HTMLParser.ElementStack.prototype.popTag = function (tag) {
  for (var i = this.elements.length - 1; i > 0; i--) {
    var e = this.elements[i];
    if (isA(e, tag)) break;
  }
  this.elements.length = i;
  this.top = this.elements[i - 1];
};

// Pop elements off the stack up to and including the first
// element that is an instance of the specified type
HTMLParser.ElementStack.prototype.popElementType = function (type) {
  for (var i = this.elements.length - 1; i > 0; i--) {
    if (this.elements[i] instanceof type) break;
  }
  this.elements.length = i;
  this.top = this.elements[i - 1];
};

// Pop elements off the stack up to and including the element e.
// Note that this is very different from removeElement()
// This requires that e is on the stack.
HTMLParser.ElementStack.prototype.popElement = function (e) {
  for (var i = this.elements.length - 1; i > 0; i--) {
    if (this.elements[i] === e) break;
  }
  this.elements.length = i;
  this.top = this.elements[i - 1];
};

// Remove a specific element from the stack.
// Do nothing if the element is not on the stack
HTMLParser.ElementStack.prototype.removeElement = function (e) {
  if (this.top === e) this.pop();else {
    var idx = this.elements.lastIndexOf(e);
    if (idx !== -1) this.elements.splice(idx, 1);
  }
};

HTMLParser.ElementStack.prototype.clearToContext = function (set) {
  // Note that we don't loop to 0. Never pop the <html> elt off.
  for (var i = this.elements.length - 1; i > 0; i--) {
    if (isA(this.elements[i], set)) break;
  }
  this.elements.length = i + 1;
  this.top = this.elements[i];
};

HTMLParser.ElementStack.prototype.contains = function (tag) {
  return this.inSpecificScope(tag, Object.create(null));
};

HTMLParser.ElementStack.prototype.inSpecificScope = function (tag, set) {
  for (var i = this.elements.length - 1; i >= 0; i--) {
    var elt = this.elements[i];
    if (isA(elt, tag)) return true;
    if (isA(elt, set)) return false;
  }
  return false;
};

// Like the above, but for a specific element, not a tagname
HTMLParser.ElementStack.prototype.elementInSpecificScope = function (target, set) {
  for (var i = this.elements.length - 1; i >= 0; i--) {
    var elt = this.elements[i];
    if (elt === target) return true;
    if (isA(elt, set)) return false;
  }
  return false;
};

// Like the above, but for an element interface, not a tagname
HTMLParser.ElementStack.prototype.elementTypeInSpecificScope = function (target, set) {
  for (var i = this.elements.length - 1; i >= 0; i--) {
    var elt = this.elements[i];
    if (elt instanceof target) return true;
    if (isA(elt, set)) return false;
  }
  return false;
};

HTMLParser.ElementStack.prototype.inScope = function (tag) {
  return this.inSpecificScope(tag, inScopeSet);
};

HTMLParser.ElementStack.prototype.elementInScope = function (e) {
  return this.elementInSpecificScope(e, inScopeSet);
};

HTMLParser.ElementStack.prototype.elementTypeInScope = function (type) {
  return this.elementTypeInSpecificScope(type, inScopeSet);
};

HTMLParser.ElementStack.prototype.inButtonScope = function (tag) {
  return this.inSpecificScope(tag, inButtonScopeSet);
};

HTMLParser.ElementStack.prototype.inListItemScope = function (tag) {
  return this.inSpecificScope(tag, inListItemScopeSet);
};

HTMLParser.ElementStack.prototype.inTableScope = function (tag) {
  return this.inSpecificScope(tag, inTableScopeSet);
};

HTMLParser.ElementStack.prototype.inSelectScope = function (tag) {
  // Can't implement this one with inSpecificScope, since it involves
  // a set defined by inverting another set. So implement manually.
  for (var i = this.elements.length - 1; i >= 0; i--) {
    var elt = this.elements[i];
    if (elt.namespaceURI !== NAMESPACE.HTML) return false;
    var localname = elt.localName;
    if (localname === tag) return true;
    if (localname !== "optgroup" && localname !== "option") return false;
  }
  return false;
};

HTMLParser.ElementStack.prototype.generateImpliedEndTags = function (butnot, thorough) {
  var endTagSet = thorough ? thoroughImpliedEndTagsSet : impliedEndTagsSet;
  for (var i = this.elements.length - 1; i >= 0; i--) {
    var e = this.elements[i];
    if (butnot && isA(e, butnot)) break;
    if (!isA(this.elements[i], endTagSet)) break;
  }

  this.elements.length = i + 1;
  this.top = this.elements[i];
};

/***
 * The ActiveFormattingElements class
 */
HTMLParser.ActiveFormattingElements = function AFE() {
  this.list = []; // elements
  this.attrs = []; // attribute tokens for cloning
};

HTMLParser.ActiveFormattingElements.prototype.MARKER = { localName: "|" };

/*
// For debugging
HTMLParser.ActiveFormattingElements.prototype.toString = function() {
  return "AFE: " +
  this.list.map(function(e) { return e.localName; }).join("-");
}
*/

HTMLParser.ActiveFormattingElements.prototype.insertMarker = function () {
  this.list.push(this.MARKER);
  this.attrs.push(this.MARKER);
};

HTMLParser.ActiveFormattingElements.prototype.push = function (elt, attrs) {
  // Scan backwards: if there are already 3 copies of this element
  // before we encounter a marker, then drop the last one
  var count = 0;
  for (var i = this.list.length - 1; i >= 0; i--) {
    if (this.list[i] === this.MARKER) break;
    // equal() is defined below
    if (equal(elt, this.list[i], this.attrs[i])) {
      count++;
      if (count === 3) {
        this.list.splice(i, 1);
        this.attrs.splice(i, 1);
        break;
      }
    }
  }

  // Now push the element onto the list
  this.list.push(elt);

  // Copy the attributes and push those on, too
  var attrcopy = [];
  for (var ii = 0; ii < attrs.length; ii++) {
    attrcopy[ii] = attrs[ii];
  }

  this.attrs.push(attrcopy);

  // This function defines equality of two elements for the purposes
  // of the AFE list.  Note that it compares the new elements
  // attributes to the saved array of attributes associated with
  // the old element because a script could have changed the
  // old element's set of attributes
  function equal(newelt, oldelt, oldattrs) {
    if (newelt.localName !== oldelt.localName) return false;
    if (newelt._numattrs !== oldattrs.length) return false;
    for (var i = 0, n = oldattrs.length; i < n; i++) {
      var oldname = oldattrs[i][0];
      var oldval = oldattrs[i][1];
      if (!newelt.hasAttribute(oldname)) return false;
      if (newelt.getAttribute(oldname) !== oldval) return false;
    }
    return true;
  }
};

HTMLParser.ActiveFormattingElements.prototype.clearToMarker = function () {
  for (var i = this.list.length - 1; i >= 0; i--) {
    if (this.list[i] === this.MARKER) break;
  }
  if (i < 0) i = 0;
  this.list.length = i;
  this.attrs.length = i;
};

// Find and return the last element with the specified tag between the
// end of the list and the last marker on the list.
// Used when parsing <a> in_body_mode()
HTMLParser.ActiveFormattingElements.prototype.findElementByTag = function (tag) {
  for (var i = this.list.length - 1; i >= 0; i--) {
    var elt = this.list[i];
    if (elt === this.MARKER) break;
    if (elt.localName === tag) return elt;
  }
  return null;
};

HTMLParser.ActiveFormattingElements.prototype.indexOf = function (e) {
  return this.list.lastIndexOf(e);
};

// Find the element e in the list and remove it
// Used when parsing <a> in_body()
HTMLParser.ActiveFormattingElements.prototype.remove = function (e) {
  var idx = this.list.lastIndexOf(e);
  if (idx !== -1) {
    this.list.splice(idx, 1);
    this.attrs.splice(idx, 1);
  }
};

// Find element a in the list and replace it with element b
// XXX: Do I need to handle attributes here?
HTMLParser.ActiveFormattingElements.prototype.replace = function (a, b, attrs) {
  var idx = this.list.lastIndexOf(a);
  if (idx !== -1) {
    this.list[idx] = b;
    this.attrs[idx] = attrs;
  }
};

// Find a in the list and insert b after it
// This is only used for insert a bookmark object, so the
// attrs array doesn't really matter
HTMLParser.ActiveFormattingElements.prototype.insertAfter = function (a, b) {
  var idx = this.list.lastIndexOf(a);
  if (idx !== -1) {
    this.list.splice(idx, 0, b);
    this.attrs.splice(idx, 0, b);
  }
};

/***
 * This is the parser factory function. It is the return value of
 * the outer closure that it is defined within.  Most of the parser
 * implementation details are inside this function.
 */
function HTMLParser(address, fragmentContext, options) {
  /***
   * These are the parser's state variables
   */
  // Scanner state
  var chars = null;
  var numchars = 0; // Length of chars
  var nextchar = 0; // Index of next char
  var input_complete = false; // Becomes true when end() called.
  var scanner_skip_newline = false; // If previous char was CR
  var reentrant_invocations = 0;
  var saved_scanner_state = [];
  var leftovers = "";
  var first_batch = true;
  var paused = 0; // Becomes non-zero while loading scripts


  // Tokenizer state
  var tokenizer = data_state; // Current tokenizer state
  var return_state;
  var character_reference_code;
  var tagnamebuf = "";
  var lasttagname = ""; // holds the target end tag for text states
  var tempbuf = [];
  var attrnamebuf = "";
  var attrvaluebuf = "";
  var commentbuf = [];
  var doctypenamebuf = [];
  var doctypepublicbuf = [];
  var doctypesystembuf = [];
  var attributes = [];
  var is_end_tag = false;

  // Tree builder state
  var parser = initial_mode; // Current insertion mode
  var originalInsertionMode = null; // A saved insertion mode
  var templateInsertionModes = []; // Stack of template insertion modes.
  var stack = new HTMLParser.ElementStack(); // Stack of open elements
  var afe = new HTMLParser.ActiveFormattingElements(); // mis-nested tags
  var fragment = fragmentContext !== undefined; // For innerHTML, etc.
  var head_element_pointer = null;
  var form_element_pointer = null;
  var scripting_enabled = true;
  if (fragmentContext) {
    scripting_enabled = fragmentContext.ownerDocument._scripting_enabled;
  }
  if (options && options.scripting_enabled === false) scripting_enabled = false;
  var frameset_ok = true;
  var force_quirks = false;
  var pending_table_text;
  var text_integration_mode; // XXX a spec bug workaround?

  // A single run of characters, buffered up to be sent to
  // the parser as a single string.
  var textrun = [];
  var textIncludesNUL = false;
  var ignore_linefeed = false;

  /***
   * This is the parser object that will be the return value of this
   * factory function, which is some 5000 lines below.
   * Note that the variable "parser" is the current state of the
   * parser's state machine.  This variable "htmlparser" is the
   * return value and defines the public API of the parser
   */
  var htmlparser = {
    document: function document() {
      return doc;
    },

    // Convenience function for internal use. Can only be called once,
    // as it removes the nodes from `doc` to add them to fragment.
    _asDocumentFragment: function _asDocumentFragment() {
      var frag = doc.createDocumentFragment();
      var root = doc.firstChild;
      while (root.hasChildNodes()) {
        frag.appendChild(root.firstChild);
      }
      return frag;
    },

    // Internal function used from HTMLScriptElement to pause the
    // parser while a script is being loaded from the network
    pause: function pause() {
      // print("pausing parser");
      paused++;
    },

    // Called when a script finishes loading
    resume: function resume() {
      // print("resuming parser");
      paused--;
      // XXX: added this to force a resumption.
      // Is this the right thing to do?
      this.parse("");
    },

    // Parse the HTML text s.
    // The second argument should be true if there is no more
    // text to be parsed, and should be false or omitted otherwise.
    // The second argument must not be set for recursive invocations
    // from document.write()
    parse: function parse(s, end, shouldPauseFunc) {
      var moreToDo;

      // If we're paused, remember the text to parse, but
      // don't parse it now.
      // (Don't invoke shouldPauseFunc because we haven't handled 'end' yet.)
      if (paused > 0) {
        leftovers += s;
        return true; // more to do
      }

      if (reentrant_invocations === 0) {
        // A normal, top-level invocation
        if (leftovers) {
          s = leftovers + s;
          leftovers = "";
        }

        // Add a special marker character to the end of
        // the buffer.  If the scanner is at the end of
        // the buffer and input_complete is set, then this
        // character will transform into an EOF token.
        // Having an actual character that represents EOF
        // in the character buffer makes lookahead regexp
        // matching work more easily, and this is
        // important for character references.
        if (end) {
          s += '\uFFFF';
          input_complete = true; // Makes scanChars() send EOF
        }

        chars = s;
        numchars = s.length;
        nextchar = 0;

        if (first_batch) {
          // We skip a leading Byte Order Mark (\uFEFF)
          // on first batch of text we're given
          first_batch = false;
          if (chars.charCodeAt(0) === 0xFEFF) nextchar = 1;
        }

        reentrant_invocations++;
        moreToDo = scanChars(shouldPauseFunc);
        leftovers = chars.substring(nextchar, numchars);
        reentrant_invocations--;
      } else {
        // This is the re-entrant case, which we have to
        // handle a little differently.
        reentrant_invocations++;

        // Save current scanner state
        saved_scanner_state.push(chars, numchars, nextchar);

        // Set new scanner state
        chars = s;
        numchars = s.length;
        nextchar = 0;

        // Now scan as many of these new chars as we can
        scanChars();
        moreToDo = false;

        leftovers = chars.substring(nextchar, numchars);

        // restore old scanner state
        nextchar = saved_scanner_state.pop();
        numchars = saved_scanner_state.pop();
        chars = saved_scanner_state.pop();

        // If there were leftover chars from this invocation
        // insert them into the pending invocation's buffer
        // and trim already processed chars at the same time
        if (leftovers) {
          chars = leftovers + chars.substring(nextchar);
          numchars = chars.length;
          nextchar = 0;
          leftovers = "";
        }

        // Decrement the counter
        reentrant_invocations--;
      }
      return moreToDo;
    }
  };

  // This is the document we'll be building up
  var doc = new Document(true, address);

  // The document needs to know about the parser, for document.write().
  // This _parser property will be deleted when we're done parsing.
  doc._parser = htmlparser;

  // XXX I think that any document we use this parser on should support
  // scripts. But I may need to configure that through a parser parameter
  // Only documents with windows ("browsing contexts" to be precise)
  // allow scripting.
  doc._scripting_enabled = scripting_enabled;

  /***
   * The actual code of the HTMLParser() factory function begins here.
   */

  if (fragmentContext) {
    // for innerHTML parsing
    if (fragmentContext.ownerDocument._quirks) doc._quirks = true;
    if (fragmentContext.ownerDocument._limitedQuirks) doc._limitedQuirks = true;

    // Set the initial tokenizer state
    if (fragmentContext.namespaceURI === NAMESPACE.HTML) {
      switch (fragmentContext.localName) {
        case "title":
        case "textarea":
          tokenizer = rcdata_state;
          break;
        case "style":
        case "xmp":
        case "iframe":
        case "noembed":
        case "noframes":
        case "script":
        case "plaintext":
          tokenizer = plaintext_state;
          break;
        case "noscript":
          if (scripting_enabled) tokenizer = plaintext_state;
      }
    }

    var root = doc.createElement("html");
    doc._appendChild(root);
    stack.push(root);
    if (fragmentContext instanceof impl.HTMLTemplateElement) {
      templateInsertionModes.push(in_template_mode);
    }
    resetInsertionMode();

    for (var e = fragmentContext; e !== null; e = e.parentElement) {
      if (e instanceof impl.HTMLFormElement) {
        form_element_pointer = e;
        break;
      }
    }
  }

  /***
   * Scanner functions
   */
  // Loop through the characters in chars, and pass them one at a time
  // to the tokenizer FSM. Return when no more characters can be processed
  // (This may leave 1 or more characters in the buffer: like a CR
  // waiting to see if the next char is LF, or for states that require
  // lookahead...)
  function scanChars(shouldPauseFunc) {
    var codepoint, s, pattern, eof;

    while (nextchar < numchars) {

      // If we just tokenized a </script> tag, then the paused flag
      // may have been set to tell us to stop tokenizing while
      // the script is loading
      if (paused > 0 || shouldPauseFunc && shouldPauseFunc()) {
        return true;
      }

      switch (_typeof(tokenizer.lookahead)) {
        case 'undefined':
          codepoint = chars.charCodeAt(nextchar++);
          if (scanner_skip_newline) {
            scanner_skip_newline = false;
            if (codepoint === 0x000A) {
              nextchar++;
              continue;
            }
          }
          switch (codepoint) {
            case 0x000D:
              // CR always turns into LF, but if the next character
              // is LF, then that second LF is skipped.
              if (nextchar < numchars) {
                if (chars.charCodeAt(nextchar) === 0x000A) nextchar++;
              } else {
                // We don't know the next char right now, so we
                // can't check if it is a LF.  So set a flag
                scanner_skip_newline = true;
              }

              // In either case, emit a LF
              tokenizer(0x000A);

              break;
            case 0xFFFF:
              if (input_complete && nextchar === numchars) {
                tokenizer(EOF); // codepoint will be 0xFFFF here
                break;
              }
            /* falls through */
            default:
              tokenizer(codepoint);
              break;
          }
          break;

        case 'number':
          codepoint = chars.charCodeAt(nextchar);

          // The only tokenizer states that require fixed lookahead
          // only consume alphanum characters, so we don't have
          // to worry about CR and LF in this case

          // tokenizer wants n chars of lookahead
          var n = tokenizer.lookahead;
          var needsString = true;
          if (n < 0) {
            needsString = false;
            n = -n;
          }

          if (n < numchars - nextchar) {
            // If we can look ahead that far
            s = needsString ? chars.substring(nextchar, nextchar + n) : null;
            eof = false;
          } else {
            // if we don't have that many characters
            if (input_complete) {
              // If no more are coming
              // Just return what we have
              s = needsString ? chars.substring(nextchar, numchars) : null;
              eof = true;
              if (codepoint === 0xFFFF && nextchar === numchars - 1) codepoint = EOF;
            } else {
              // Return now and wait for more chars later
              return true;
            }
          }
          tokenizer(codepoint, s, eof);
          break;
        case 'string':
          codepoint = chars.charCodeAt(nextchar);

          // tokenizer wants characters up to a matching string
          pattern = tokenizer.lookahead;
          var pos = chars.indexOf(pattern, nextchar);
          if (pos !== -1) {
            s = chars.substring(nextchar, pos + pattern.length);
            eof = false;
          } else {
            // No match
            // If more characters coming, wait for them
            if (!input_complete) return true;

            // Otherwise, we've got to return what we've got
            s = chars.substring(nextchar, numchars);
            if (codepoint === 0xFFFF && nextchar === numchars - 1) codepoint = EOF;
            eof = true;
          }

          // The tokenizer states that require this kind of
          // lookahead have to be careful to handle CR characters
          // correctly
          tokenizer(codepoint, s, eof);
          break;
      }
    }
    return false; // no more characters to scan!
  }

  /***
   * Tokenizer utility functions
   */
  function addAttribute(name, value) {
    // Make sure there isn't already an attribute with this name
    // If there is, ignore this one.
    for (var i = 0; i < attributes.length; i++) {
      if (attributes[i][0] === name) return;
    }

    if (value !== undefined) {
      attributes.push([name, value]);
    } else {
      attributes.push([name]);
    }
  }

  // Shortcut for simple attributes
  function handleSimpleAttribute() {
    SIMPLEATTR.lastIndex = nextchar - 1;
    var matched = SIMPLEATTR.exec(chars);
    if (!matched) throw new Error("should never happen");
    var name = matched[1];
    if (!name) return false;
    var value = matched[2];
    var len = value.length;
    switch (value[0]) {
      case '"':
      case "'":
        value = value.substring(1, len - 1);
        nextchar += matched[0].length - 1;
        tokenizer = after_attribute_value_quoted_state;
        break;
      default:
        tokenizer = before_attribute_name_state;
        nextchar += matched[0].length - 1;
        value = value.substring(0, len - 1);
        break;
    }

    // Make sure there isn't already an attribute with this name
    // If there is, ignore this one.
    for (var i = 0; i < attributes.length; i++) {
      if (attributes[i][0] === name) return true;
    }

    attributes.push([name, value]);
    return true;
  }

  function beginTagName() {
    is_end_tag = false;
    tagnamebuf = "";
    attributes.length = 0;
  }
  function beginEndTagName() {
    is_end_tag = true;
    tagnamebuf = "";
    attributes.length = 0;
  }

  function beginTempBuf() {
    tempbuf.length = 0;
  }
  function beginAttrName() {
    attrnamebuf = "";
  }
  function beginAttrValue() {
    attrvaluebuf = "";
  }
  function beginComment() {
    commentbuf.length = 0;
  }
  function beginDoctype() {
    doctypenamebuf.length = 0;
    doctypepublicbuf = null;
    doctypesystembuf = null;
  }
  function beginDoctypePublicId() {
    doctypepublicbuf = [];
  }
  function beginDoctypeSystemId() {
    doctypesystembuf = [];
  }
  function forcequirks() {
    force_quirks = true;
  }
  function cdataAllowed() {
    return stack.top && stack.top.namespaceURI !== "http://www.w3.org/1999/xhtml";
  }

  // Return true if the codepoints in the specified buffer match the
  // characters of lasttagname
  function appropriateEndTag(buf) {
    return lasttagname === buf;
  }

  function flushText() {
    if (textrun.length > 0) {
      var s = buf2str(textrun);
      textrun.length = 0;

      if (ignore_linefeed) {
        ignore_linefeed = false;
        if (s[0] === "\n") s = s.substring(1);
        if (s.length === 0) return;
      }

      insertToken(TEXT, s);
      textIncludesNUL = false;
    }
    ignore_linefeed = false;
  }

  // Consume chars matched by the pattern and return them as a string. Starts
  // matching at the current position, so users should drop the current char
  // otherwise.
  function getMatchingChars(pattern) {
    pattern.lastIndex = nextchar - 1;
    var match = pattern.exec(chars);
    if (match && match.index === nextchar - 1) {
      match = match[0];
      nextchar += match.length - 1;
      /* Careful!  Make sure we haven't matched the EOF character! */
      if (input_complete && nextchar === numchars) {
        // Oops, backup one.
        match = match.slice(0, -1);
        nextchar--;
      }
      return match;
    } else {
      throw new Error("should never happen");
    }
  }

  // emit a string of chars that match a regexp
  // Returns false if no chars matched.
  function emitCharsWhile(pattern) {
    pattern.lastIndex = nextchar - 1;
    var match = pattern.exec(chars)[0];
    if (!match) return false;
    emitCharString(match);
    nextchar += match.length - 1;
    return true;
  }

  // This is used by CDATA sections
  function emitCharString(s) {
    if (textrun.length > 0) flushText();

    if (ignore_linefeed) {
      ignore_linefeed = false;
      if (s[0] === "\n") s = s.substring(1);
      if (s.length === 0) return;
    }

    insertToken(TEXT, s);
  }

  function emitTag() {
    if (is_end_tag) insertToken(ENDTAG, tagnamebuf);else {
      // Remember the last open tag we emitted
      var tagname = tagnamebuf;
      tagnamebuf = "";
      lasttagname = tagname;
      insertToken(TAG, tagname, attributes);
    }
  }

  // A shortcut: look ahead and if this is a open or close tag
  // in lowercase with no spaces and no attributes, just emit it now.
  function emitSimpleTag() {
    if (nextchar === numchars) {
      return false; /* not even 1 char left */
    }
    SIMPLETAG.lastIndex = nextchar;
    var matched = SIMPLETAG.exec(chars);
    if (!matched) throw new Error("should never happen");
    var tagname = matched[2];
    if (!tagname) return false;
    var endtag = matched[1];
    if (endtag) {
      nextchar += tagname.length + 2;
      insertToken(ENDTAG, tagname);
    } else {
      nextchar += tagname.length + 1;
      lasttagname = tagname;
      insertToken(TAG, tagname, NOATTRS);
    }
    return true;
  }

  function emitSelfClosingTag() {
    if (is_end_tag) insertToken(ENDTAG, tagnamebuf, null, true);else {
      insertToken(TAG, tagnamebuf, attributes, true);
    }
  }

  function emitDoctype() {
    insertToken(DOCTYPE, buf2str(doctypenamebuf), doctypepublicbuf ? buf2str(doctypepublicbuf) : undefined, doctypesystembuf ? buf2str(doctypesystembuf) : undefined);
  }

  function emitEOF() {
    flushText();
    parser(EOF); // EOF never goes to insertForeignContent()
    doc.modclock = 1; // Start tracking modifications
  }

  // Insert a token, either using the current parser insertion mode
  // (for HTML stuff) or using the insertForeignToken() method.
  var insertToken = htmlparser.insertToken = function insertToken(t, value, arg3, arg4) {
    flushText();
    var current = stack.top;

    if (!current || current.namespaceURI === NAMESPACE.HTML) {
      // This is the common case
      parser(t, value, arg3, arg4);
    } else {
      // Otherwise we may need to insert this token as foreign content
      if (t !== TAG && t !== TEXT) {
        insertForeignToken(t, value, arg3, arg4);
      } else {
        // But in some cases we treat it as regular content
        if (isMathmlTextIntegrationPoint(current) && (t === TEXT || t === TAG && value !== "mglyph" && value !== "malignmark") || t === TAG && value === "svg" && current.namespaceURI === NAMESPACE.MATHML && current.localName === "annotation-xml" || isHTMLIntegrationPoint(current)) {

          // XXX: the text_integration_mode stuff is an
          // attempted bug workaround of mine
          text_integration_mode = true;
          parser(t, value, arg3, arg4);
          text_integration_mode = false;
        }
        // Otherwise it is foreign content
        else {
            insertForeignToken(t, value, arg3, arg4);
          }
      }
    }
  };

  /***
   * Tree building utility functions
   */
  function insertComment(data) {
    var parent = stack.top;
    if (foster_parent_mode && isA(parent, tablesectionrowSet)) {
      fosterParent(function (doc) {
        return doc.createComment(data);
      });
    } else {
      // "If the adjusted insertion location is inside a template element,
      // let it instead be inside the template element's template contents"
      if (parent instanceof impl.HTMLTemplateElement) {
        parent = parent.content;
      }
      parent._appendChild(parent.ownerDocument.createComment(data));
    }
  }

  function insertText(s) {
    var parent = stack.top;
    if (foster_parent_mode && isA(parent, tablesectionrowSet)) {
      fosterParent(function (doc) {
        return doc.createTextNode(s);
      });
    } else {
      // "If the adjusted insertion location is inside a template element,
      // let it instead be inside the template element's template contents"
      if (parent instanceof impl.HTMLTemplateElement) {
        parent = parent.content;
      }
      // "If there is a Text node immediately before the adjusted insertion
      // location, then append data to that Text node's data."
      var lastChild = parent.lastChild;
      if (lastChild && lastChild.nodeType === Node.TEXT_NODE) {
        lastChild.appendData(s);
      } else {
        parent._appendChild(parent.ownerDocument.createTextNode(s));
      }
    }
  }

  function createHTMLElt(doc, name, attrs) {
    // Create the element this way, rather than with
    // doc.createElement because createElement() does error
    // checking on the element name that we need to avoid here.
    var elt = html.createElement(doc, name, null);

    if (attrs) {
      for (var i = 0, n = attrs.length; i < n; i++) {
        // Use the _ version to avoid testing the validity
        // of the attribute name
        elt._setAttribute(attrs[i][0], attrs[i][1]);
      }
    }
    // XXX
    // If the element is a resettable form element,
    // run its reset algorithm now
    // XXX
    // handle case where form-element-pointer is not null
    return elt;
  }

  // The in_table insertion mode turns on this flag, and that makes
  // insertHTMLElement use the foster parenting algorithm for elements
  // tags inside a table
  var foster_parent_mode = false;

  function insertHTMLElement(name, attrs) {
    var elt = insertElement(function (doc) {
      return createHTMLElt(doc, name, attrs);
    });

    // XXX
    // If this is a form element, set its form attribute property here
    if (isA(elt, formassociatedSet)) {
      elt._form = form_element_pointer;
    }

    return elt;
  }

  // Insert the element into the open element or foster parent it
  function insertElement(eltFunc) {
    var elt;
    if (foster_parent_mode && isA(stack.top, tablesectionrowSet)) {
      elt = fosterParent(eltFunc);
    } else if (stack.top instanceof impl.HTMLTemplateElement) {
      // "If the adjusted insertion location is inside a template element,
      // let it instead be inside the template element's template contents"
      elt = eltFunc(stack.top.content.ownerDocument);
      stack.top.content._appendChild(elt);
    } else {
      elt = eltFunc(stack.top.ownerDocument);
      stack.top._appendChild(elt);
    }

    stack.push(elt);
    return elt;
  }

  function insertForeignElement(name, attrs, ns) {
    return insertElement(function (doc) {
      // We need to prevent createElementNS from trying to parse `name` as a
      // `qname`, so use an internal Document#_createElementNS() interface.
      var elt = doc._createElementNS(name, ns, null);
      if (attrs) {
        for (var i = 0, n = attrs.length; i < n; i++) {
          var attr = attrs[i];
          if (attr.length === 2) elt._setAttribute(attr[0], attr[1]);else {
            elt._setAttributeNS(attr[2], attr[0], attr[1]);
          }
        }
      }
      return elt;
    });
  }

  function lastElementOfType(type) {
    for (var i = stack.elements.length - 1; i >= 0; i--) {
      if (stack.elements[i] instanceof type) {
        return i;
      }
    }
    return -1;
  }

  function fosterParent(eltFunc) {
    var parent,
        before,
        lastTable = -1,
        lastTemplate = -1,
        elt;

    lastTable = lastElementOfType(impl.HTMLTableElement);
    lastTemplate = lastElementOfType(impl.HTMLTemplateElement);

    if (lastTemplate >= 0 && (lastTable < 0 || lastTemplate > lastTable)) {
      parent = stack.elements[lastTemplate];
    } else if (lastTable >= 0) {
      parent = stack.elements[lastTable].parentNode;
      if (parent) {
        before = stack.elements[lastTable];
      } else {
        parent = stack.elements[lastTable - 1];
      }
    }
    if (!parent) parent = stack.elements[0]; // the `html` element.

    // "If the adjusted insertion location is inside a template element,
    // let it instead be inside the template element's template contents"
    if (parent instanceof impl.HTMLTemplateElement) {
      parent = parent.content;
    }
    // Create element in the appropriate document.
    elt = eltFunc(parent.ownerDocument);

    if (elt.nodeType === Node.TEXT_NODE) {
      var prev;
      if (before) prev = before.previousSibling;else prev = parent.lastChild;
      if (prev && prev.nodeType === Node.TEXT_NODE) {
        prev.appendData(elt.data);
        return elt;
      }
    }
    if (before) parent.insertBefore(elt, before);else parent._appendChild(elt);
    return elt;
  }

  function resetInsertionMode() {
    var last = false;
    for (var i = stack.elements.length - 1; i >= 0; i--) {
      var node = stack.elements[i];
      if (i === 0) {
        last = true;
        if (fragment) {
          node = fragmentContext;
        }
      }
      if (node.namespaceURI === NAMESPACE.HTML) {
        var tag = node.localName;
        switch (tag) {
          case "select":
            for (var j = i; j > 0;) {
              var ancestor = stack.elements[--j];
              if (ancestor instanceof impl.HTMLTemplateElement) {
                break;
              } else if (ancestor instanceof impl.HTMLTableElement) {
                parser = in_select_in_table_mode;
                return;
              }
            }
            parser = in_select_mode;
            return;
          case "tr":
            parser = in_row_mode;
            return;
          case "tbody":
          case "tfoot":
          case "thead":
            parser = in_table_body_mode;
            return;
          case "caption":
            parser = in_caption_mode;
            return;
          case "colgroup":
            parser = in_column_group_mode;
            return;
          case "table":
            parser = in_table_mode;
            return;
          case "template":
            parser = templateInsertionModes[templateInsertionModes.length - 1];
            return;
          case "body":
            parser = in_body_mode;
            return;
          case "frameset":
            parser = in_frameset_mode;
            return;
          case "html":
            if (head_element_pointer === null) {
              parser = before_head_mode;
            } else {
              parser = after_head_mode;
            }
            return;
          default:
            if (!last) {
              if (tag === "head") {
                parser = in_head_mode;
                return;
              }
              if (tag === "td" || tag === "th") {
                parser = in_cell_mode;
                return;
              }
            }
        }
      }
      if (last) {
        parser = in_body_mode;
        return;
      }
    }
  }

  function parseRawText(name, attrs) {
    insertHTMLElement(name, attrs);
    tokenizer = rawtext_state;
    originalInsertionMode = parser;
    parser = text_mode;
  }

  function parseRCDATA(name, attrs) {
    insertHTMLElement(name, attrs);
    tokenizer = rcdata_state;
    originalInsertionMode = parser;
    parser = text_mode;
  }

  // Make a copy of element i on the list of active formatting
  // elements, using its original attributes, not current
  // attributes (which may have been modified by a script)
  function afeclone(doc, i) {
    return {
      elt: createHTMLElt(doc, afe.list[i].localName, afe.attrs[i]),
      attrs: afe.attrs[i]
    };
  }

  function afereconstruct() {
    if (afe.list.length === 0) return;
    var entry = afe.list[afe.list.length - 1];
    // If the last is a marker , do nothing
    if (entry === afe.MARKER) return;
    // Or if it is an open element, do nothing
    if (stack.elements.lastIndexOf(entry) !== -1) return;

    // Loop backward through the list until we find a marker or an
    // open element, and then move forward one from there.
    for (var i = afe.list.length - 2; i >= 0; i--) {
      entry = afe.list[i];
      if (entry === afe.MARKER) break;
      if (stack.elements.lastIndexOf(entry) !== -1) break;
    }

    // Now loop forward, starting from the element after the current
    // one, recreating formatting elements and pushing them back onto
    // the list of open elements
    for (i = i + 1; i < afe.list.length; i++) {
      var newelt = insertElement(function (doc) {
        return afeclone(doc, i).elt;
      });
      afe.list[i] = newelt;
    }
  }

  // Used by the adoptionAgency() function
  var BOOKMARK = { localName: "BM" };

  function adoptionAgency(tag) {
    // If the current node is an HTML element whose tag name is subject,
    // and the current node is not in the list of active formatting
    // elements, then pop the current node off the stack of open
    // elements and abort these steps.
    if (isA(stack.top, tag) && afe.indexOf(stack.top) === -1) {
      stack.pop();
      return true; // no more handling required
    }

    // Let outer loop counter be zero.
    var outer = 0;

    // Outer loop: If outer loop counter is greater than or
    // equal to eight, then abort these steps.
    while (outer < 8) {
      // Increment outer loop counter by one.
      outer++;

      // Let the formatting element be the last element in the list
      // of active formatting elements that: is between the end of
      // the list and the last scope marker in the list, if any, or
      // the start of the list otherwise, and has the same tag name
      // as the token.
      var fmtelt = afe.findElementByTag(tag);

      // If there is no such node, then abort these steps and instead
      // act as described in the "any other end tag" entry below.
      if (!fmtelt) {
        return false; // false means handle by the default case
      }

      // Otherwise, if there is such a node, but that node is not in
      // the stack of open elements, then this is a parse error;
      // remove the element from the list, and abort these steps.
      var index = stack.elements.lastIndexOf(fmtelt);
      if (index === -1) {
        afe.remove(fmtelt);
        return true; // true means no more handling required
      }

      // Otherwise, if there is such a node, and that node is also in
      // the stack of open elements, but the element is not in scope,
      // then this is a parse error; ignore the token, and abort
      // these steps.
      if (!stack.elementInScope(fmtelt)) {
        return true;
      }

      // Let the furthest block be the topmost node in the stack of
      // open elements that is lower in the stack than the formatting
      // element, and is an element in the special category. There
      // might not be one.
      var furthestblock = null,
          furthestblockindex;
      for (var i = index + 1; i < stack.elements.length; i++) {
        if (isA(stack.elements[i], specialSet)) {
          furthestblock = stack.elements[i];
          furthestblockindex = i;
          break;
        }
      }

      // If there is no furthest block, then the UA must skip the
      // subsequent steps and instead just pop all the nodes from the
      // bottom of the stack of open elements, from the current node
      // up to and including the formatting element, and remove the
      // formatting element from the list of active formatting
      // elements.
      if (!furthestblock) {
        stack.popElement(fmtelt);
        afe.remove(fmtelt);
        return true;
      } else {
        // Let the common ancestor be the element immediately above
        // the formatting element in the stack of open elements.
        var ancestor = stack.elements[index - 1];

        // Let a bookmark note the position of the formatting
        // element in the list of active formatting elements
        // relative to the elements on either side of it in the
        // list.
        afe.insertAfter(fmtelt, BOOKMARK);

        // Let node and last node be the furthest block.
        var node = furthestblock;
        var lastnode = furthestblock;
        var nodeindex = furthestblockindex;
        var nodeafeindex;

        // Let inner loop counter be zero.
        var inner = 0;

        while (true) {

          // Increment inner loop counter by one.
          inner++;

          // Let node be the element immediately above node in
          // the stack of open elements, or if node is no longer
          // in the stack of open elements (e.g. because it got
          // removed by this algorithm), the element that was
          // immediately above node in the stack of open elements
          // before node was removed.
          node = stack.elements[--nodeindex];

          // If node is the formatting element, then go
          // to the next step in the overall algorithm.
          if (node === fmtelt) break;

          // If the inner loop counter is greater than three and node
          // is in the list of active formatting elements, then remove
          // node from the list of active formatting elements.
          nodeafeindex = afe.indexOf(node);
          if (inner > 3 && nodeafeindex !== -1) {
            afe.remove(node);
            nodeafeindex = -1;
          }

          // If node is not in the list of active formatting
          // elements, then remove node from the stack of open
          // elements and then go back to the step labeled inner
          // loop.
          if (nodeafeindex === -1) {
            stack.removeElement(node);
            continue;
          }

          // Create an element for the token for which the
          // element node was created with common ancestor as
          // the intended parent, replace the entry for node
          // in the list of active formatting elements with an
          // entry for the new element, replace the entry for
          // node in the stack of open elements with an entry for
          // the new element, and let node be the new element.
          var newelt = afeclone(ancestor.ownerDocument, nodeafeindex);
          afe.replace(node, newelt.elt, newelt.attrs);
          stack.elements[nodeindex] = newelt.elt;
          node = newelt.elt;

          // If last node is the furthest block, then move the
          // aforementioned bookmark to be immediately after the
          // new node in the list of active formatting elements.
          if (lastnode === furthestblock) {
            afe.remove(BOOKMARK);
            afe.insertAfter(newelt.elt, BOOKMARK);
          }

          // Insert last node into node, first removing it from
          // its previous parent node if any.
          node._appendChild(lastnode);

          // Let last node be node.
          lastnode = node;
        }

        // If the common ancestor node is a table, tbody, tfoot,
        // thead, or tr element, then, foster parent whatever last
        // node ended up being in the previous step, first removing
        // it from its previous parent node if any.
        if (foster_parent_mode && isA(ancestor, tablesectionrowSet)) {
          fosterParent(function () {
            return lastnode;
          });
        }
        // Otherwise, append whatever last node ended up being in
        // the previous step to the common ancestor node, first
        // removing it from its previous parent node if any.
        else if (ancestor instanceof impl.HTMLTemplateElement) {
            ancestor.content._appendChild(lastnode);
          } else {
            ancestor._appendChild(lastnode);
          }

        // Create an element for the token for which the
        // formatting element was created, with furthest block
        // as the intended parent.
        var newelt2 = afeclone(furthestblock.ownerDocument, afe.indexOf(fmtelt));

        // Take all of the child nodes of the furthest block and
        // append them to the element created in the last step.
        while (furthestblock.hasChildNodes()) {
          newelt2.elt._appendChild(furthestblock.firstChild);
        }

        // Append that new element to the furthest block.
        furthestblock._appendChild(newelt2.elt);

        // Remove the formatting element from the list of active
        // formatting elements, and insert the new element into the
        // list of active formatting elements at the position of
        // the aforementioned bookmark.
        afe.remove(fmtelt);
        afe.replace(BOOKMARK, newelt2.elt, newelt2.attrs);

        // Remove the formatting element from the stack of open
        // elements, and insert the new element into the stack of
        // open elements immediately below the position of the
        // furthest block in that stack.
        stack.removeElement(fmtelt);
        var pos = stack.elements.lastIndexOf(furthestblock);
        stack.elements.splice(pos + 1, 0, newelt2.elt);
      }
    }

    return true;
  }

  // We do this when we get /script in in_text_mode
  function handleScriptEnd() {
    // XXX:
    // This is just a stub implementation right now and doesn't run scripts.
    // Getting this method right involves the event loop, URL resolution
    // script fetching etc. For now I just want to be able to parse
    // documents and test the parser.

    //var script = stack.top;
    stack.pop();
    parser = originalInsertionMode;
    //script._prepare();
    return;

    // XXX: here is what this method is supposed to do

    // Provide a stable state.

    // Let script be the current node (which will be a script
    // element).

    // Pop the current node off the stack of open elements.

    // Switch the insertion mode to the original insertion mode.

    // Let the old insertion point have the same value as the current
    // insertion point. Let the insertion point be just before the
    // next input character.

    // Increment the parser's script nesting level by one.

    // Prepare the script. This might cause some script to execute,
    // which might cause new characters to be inserted into the
    // tokenizer, and might cause the tokenizer to output more tokens,
    // resulting in a reentrant invocation of the parser.

    // Decrement the parser's script nesting level by one. If the
    // parser's script nesting level is zero, then set the parser
    // pause flag to false.

    // Let the insertion point have the value of the old insertion
    // point. (In other words, restore the insertion point to its
    // previous value. This value might be the "undefined" value.)

    // At this stage, if there is a pending parsing-blocking script,
    // then:

    // If the script nesting level is not zero:

    //   Set the parser pause flag to true, and abort the processing
    //   of any nested invocations of the tokenizer, yielding
    //   control back to the caller. (Tokenization will resume when
    //   the caller returns to the "outer" tree construction stage.)

    //   The tree construction stage of this particular parser is
    //   being called reentrantly, say from a call to
    //   document.write().

    // Otherwise:

    //     Run these steps:

    //       Let the script be the pending parsing-blocking
    //       script. There is no longer a pending
    //       parsing-blocking script.

    //       Block the tokenizer for this instance of the HTML
    //       parser, such that the event loop will not run tasks
    //       that invoke the tokenizer.

    //       If the parser's Document has a style sheet that is
    //       blocking scripts or the script's "ready to be
    //       parser-executed" flag is not set: spin the event
    //       loop until the parser's Document has no style sheet
    //       that is blocking scripts and the script's "ready to
    //       be parser-executed" flag is set.

    //       Unblock the tokenizer for this instance of the HTML
    //       parser, such that tasks that invoke the tokenizer
    //       can again be run.

    //       Let the insertion point be just before the next
    //       input character.

    //       Increment the parser's script nesting level by one
    //       (it should be zero before this step, so this sets
    //       it to one).

    //       Execute the script.

    //       Decrement the parser's script nesting level by
    //       one. If the parser's script nesting level is zero
    //       (which it always should be at this point), then set
    //       the parser pause flag to false.

    //       Let the insertion point be undefined again.

    //       If there is once again a pending parsing-blocking
    //       script, then repeat these steps from step 1.

  }

  function stopParsing() {
    // XXX This is just a temporary implementation to get the parser working.
    // A full implementation involves scripts and events and the event loop.

    // Remove the link from document to parser.
    // This is instead of "set the insertion point to undefined".
    // It means that document.write() can't write into the doc anymore.
    delete doc._parser;

    stack.elements.length = 0; // pop everything off

    // If there is a window object associated with the document
    // then trigger an load event on it
    if (doc.defaultView) {
      doc.defaultView.dispatchEvent(new impl.Event("load", {}));
    }
  }

  /****
   * Tokenizer states
   */

  /**
   * This file was partially mechanically generated from
   * http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html
   *
   * After mechanical conversion, it was further converted from
   * prose to JS by hand, but the intent is that it is a very
   * faithful rendering of the HTML tokenization spec in
   * JavaScript.
   *
   * It is not a goal of this tokenizer to detect or report
   * parse errors.
   *
   * XXX The tokenizer is supposed to work with straight UTF32
   * codepoints. But I don't think it has any dependencies on
   * any character outside of the BMP so I think it is safe to
   * pass it UTF16 characters. I don't think it will ever change
   * state in the middle of a surrogate pair.
   */

  /*
   * Each state is represented by a function.  For most states, the
   * scanner simply passes the next character (as an integer
   * codepoint) to the current state function and automatically
   * consumes the character.  If the state function can't process
   * the character it can call pushback() to push it back to the
   * scanner.
   *
   * Some states require lookahead, though.  If a state function has
   * a lookahead property, then it is invoked differently.  In this
   * case, the scanner invokes the function with 3 arguments: 1) the
   * next codepoint 2) a string of lookahead text 3) a boolean that
   * is true if the lookahead goes all the way to the EOF. (XXX
   * actually maybe this third is not necessary... the lookahead
   * could just include \uFFFF?)
   *
   * If the lookahead property of a state function is an integer, it
   * specifies the number of characters required. If it is a string,
   * then the scanner will scan for that string and return all
   * characters up to and including that sequence, or up to EOF.  If
   * the lookahead property is a regexp, then the scanner will match
   * the regexp at the current point and return the matching string.
   *
   * States that require lookahead are responsible for explicitly
   * consuming the characters they process. They do this by
   * incrementing nextchar by the number of processed characters.
   */
  function reconsume(c, new_state) {
    tokenizer = new_state;
    nextchar--; // pushback
  }

  function data_state(c) {
    switch (c) {
      case 0x0026:
        // AMPERSAND
        return_state = data_state;
        tokenizer = character_reference_state;
        break;
      case 0x003C:
        // LESS-THAN SIGN
        if (emitSimpleTag()) // Shortcut for <p>, <dl>, </div> etc.
          break;
        tokenizer = tag_open_state;
        break;
      case 0x0000:
        // NULL
        // Usually null characters emitted by the tokenizer will be
        // ignored by the tree builder, but sometimes they'll be
        // converted to \uFFFD.  I don't want to have the search every
        // string emitted to replace NULs, so I'll set a flag
        // if I've emitted a NUL.
        textrun.push(c);
        textIncludesNUL = true;
        break;
      case -1:
        // EOF
        emitEOF();
        break;
      default:
        // Instead of just pushing a single character and then
        // coming back to the very same place, lookahead and
        // emit everything we can at once.
        /*jshint -W030 */
        emitCharsWhile(DATATEXT) || textrun.push(c);
        break;
    }
  }

  function rcdata_state(c) {
    // Save the open tag so we can find a matching close tag
    switch (c) {
      case 0x0026:
        // AMPERSAND
        return_state = rcdata_state;
        tokenizer = character_reference_state;
        break;
      case 0x003C:
        // LESS-THAN SIGN
        tokenizer = rcdata_less_than_sign_state;
        break;
      case 0x0000:
        // NULL
        textrun.push(0xFFFD); // REPLACEMENT CHARACTER
        textIncludesNUL = true;
        break;
      case -1:
        // EOF
        emitEOF();
        break;
      default:
        textrun.push(c);
        break;
    }
  }

  function rawtext_state(c) {
    switch (c) {
      case 0x003C:
        // LESS-THAN SIGN
        tokenizer = rawtext_less_than_sign_state;
        break;
      case 0x0000:
        // NULL
        textrun.push(0xFFFD); // REPLACEMENT CHARACTER
        break;
      case -1:
        // EOF
        emitEOF();
        break;
      default:
        /*jshint -W030 */
        emitCharsWhile(RAWTEXT) || textrun.push(c);
        break;
    }
  }

  function script_data_state(c) {
    switch (c) {
      case 0x003C:
        // LESS-THAN SIGN
        tokenizer = script_data_less_than_sign_state;
        break;
      case 0x0000:
        // NULL
        textrun.push(0xFFFD); // REPLACEMENT CHARACTER
        break;
      case -1:
        // EOF
        emitEOF();
        break;
      default:
        /*jshint -W030 */
        emitCharsWhile(RAWTEXT) || textrun.push(c);
        break;
    }
  }

  function plaintext_state(c) {
    switch (c) {
      case 0x0000:
        // NULL
        textrun.push(0xFFFD); // REPLACEMENT CHARACTER
        break;
      case -1:
        // EOF
        emitEOF();
        break;
      default:
        /*jshint -W030 */
        emitCharsWhile(PLAINTEXT) || textrun.push(c);
        break;
    }
  }

  function tag_open_state(c) {
    switch (c) {
      case 0x0021:
        // EXCLAMATION MARK
        tokenizer = markup_declaration_open_state;
        break;
      case 0x002F:
        // SOLIDUS
        tokenizer = end_tag_open_state;
        break;
      case 0x0041: // [A-Z]
      case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
      case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
      case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
      case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
      case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      case 0x0061: // [a-z]
      case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
      case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
      case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
      case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
      case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
        beginTagName();
        reconsume(c, tag_name_state);
        break;
      case 0x003F:
        // QUESTION MARK
        reconsume(c, bogus_comment_state);
        break;
      default:
        textrun.push(0x003C); // LESS-THAN SIGN
        reconsume(c, data_state);
        break;
    }
  }

  function end_tag_open_state(c) {
    switch (c) {
      case 0x0041: // [A-Z]
      case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
      case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
      case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
      case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
      case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      case 0x0061: // [a-z]
      case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
      case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
      case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
      case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
      case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
        beginEndTagName();
        reconsume(c, tag_name_state);
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        tokenizer = data_state;
        break;
      case -1:
        // EOF
        textrun.push(0x003C); // LESS-THAN SIGN
        textrun.push(0x002F); // SOLIDUS
        emitEOF();
        break;
      default:
        reconsume(c, bogus_comment_state);
        break;
    }
  }

  function tag_name_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        tokenizer = before_attribute_name_state;
        break;
      case 0x002F:
        // SOLIDUS
        tokenizer = self_closing_start_tag_state;
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        tokenizer = data_state;
        emitTag();
        break;
      case 0x0041: // [A-Z]
      case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
      case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
      case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
      case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
      case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
        tagnamebuf += String.fromCharCode(c + 0x0020);
        break;
      case 0x0000:
        // NULL
        tagnamebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
        break;
      case -1:
        // EOF
        emitEOF();
        break;
      default:
        tagnamebuf += getMatchingChars(TAGNAME);
        break;
    }
  }

  function rcdata_less_than_sign_state(c) {
    /* identical to the RAWTEXT less-than sign state, except s/RAWTEXT/RCDATA/g */
    if (c === 0x002F) {
      // SOLIDUS
      beginTempBuf();
      tokenizer = rcdata_end_tag_open_state;
    } else {
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, rcdata_state);
    }
  }

  function rcdata_end_tag_open_state(c) {
    /* identical to the RAWTEXT (and Script data) end tag open state, except s/RAWTEXT/RCDATA/g */
    switch (c) {
      case 0x0041: // [A-Z]
      case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
      case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
      case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
      case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
      case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      case 0x0061: // [a-z]
      case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
      case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
      case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
      case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
      case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
        beginEndTagName();
        reconsume(c, rcdata_end_tag_name_state);
        break;
      default:
        textrun.push(0x003C); // LESS-THAN SIGN
        textrun.push(0x002F); // SOLIDUS
        reconsume(c, rcdata_state);
        break;
    }
  }

  function rcdata_end_tag_name_state(c) {
    /* identical to the RAWTEXT (and Script data) end tag name state, except s/RAWTEXT/RCDATA/g */
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        if (appropriateEndTag(tagnamebuf)) {
          tokenizer = before_attribute_name_state;
          return;
        }
        break;
      case 0x002F:
        // SOLIDUS
        if (appropriateEndTag(tagnamebuf)) {
          tokenizer = self_closing_start_tag_state;
          return;
        }
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        if (appropriateEndTag(tagnamebuf)) {
          tokenizer = data_state;
          emitTag();
          return;
        }
        break;
      case 0x0041: // [A-Z]
      case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
      case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
      case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
      case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
      case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:

        tagnamebuf += String.fromCharCode(c + 0x0020);
        tempbuf.push(c);
        return;
      case 0x0061: // [a-z]
      case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
      case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
      case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
      case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
      case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:

        tagnamebuf += String.fromCharCode(c);
        tempbuf.push(c);
        return;
      default:
        break;
    }

    // If we don't return in one of the cases above, then this was not
    // an appropriately matching close tag, so back out by emitting all
    // the characters as text
    textrun.push(0x003C); // LESS-THAN SIGN
    textrun.push(0x002F); // SOLIDUS
    pushAll(textrun, tempbuf);
    reconsume(c, rcdata_state);
  }

  function rawtext_less_than_sign_state(c) {
    /* identical to the RCDATA less-than sign state, except s/RCDATA/RAWTEXT/g
     */
    if (c === 0x002F) {
      // SOLIDUS
      beginTempBuf();
      tokenizer = rawtext_end_tag_open_state;
    } else {
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, rawtext_state);
    }
  }

  function rawtext_end_tag_open_state(c) {
    /* identical to the RCDATA (and Script data) end tag open state, except s/RCDATA/RAWTEXT/g */
    switch (c) {
      case 0x0041: // [A-Z]
      case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
      case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
      case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
      case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
      case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      case 0x0061: // [a-z]
      case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
      case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
      case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
      case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
      case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
        beginEndTagName();
        reconsume(c, rawtext_end_tag_name_state);
        break;
      default:
        textrun.push(0x003C); // LESS-THAN SIGN
        textrun.push(0x002F); // SOLIDUS
        reconsume(c, rawtext_state);
        break;
    }
  }

  function rawtext_end_tag_name_state(c) {
    /* identical to the RCDATA (and Script data) end tag name state, except s/RCDATA/RAWTEXT/g */
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        if (appropriateEndTag(tagnamebuf)) {
          tokenizer = before_attribute_name_state;
          return;
        }
        break;
      case 0x002F:
        // SOLIDUS
        if (appropriateEndTag(tagnamebuf)) {
          tokenizer = self_closing_start_tag_state;
          return;
        }
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        if (appropriateEndTag(tagnamebuf)) {
          tokenizer = data_state;
          emitTag();
          return;
        }
        break;
      case 0x0041: // [A-Z]
      case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
      case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
      case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
      case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
      case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
        tagnamebuf += String.fromCharCode(c + 0x0020);
        tempbuf.push(c);
        return;
      case 0x0061: // [a-z]
      case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
      case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
      case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
      case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
      case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
        tagnamebuf += String.fromCharCode(c);
        tempbuf.push(c);
        return;
      default:
        break;
    }

    // If we don't return in one of the cases above, then this was not
    // an appropriately matching close tag, so back out by emitting all
    // the characters as text
    textrun.push(0x003C); // LESS-THAN SIGN
    textrun.push(0x002F); // SOLIDUS
    pushAll(textrun, tempbuf);
    reconsume(c, rawtext_state);
  }

  function script_data_less_than_sign_state(c) {
    switch (c) {
      case 0x002F:
        // SOLIDUS
        beginTempBuf();
        tokenizer = script_data_end_tag_open_state;
        break;
      case 0x0021:
        // EXCLAMATION MARK
        tokenizer = script_data_escape_start_state;
        textrun.push(0x003C); // LESS-THAN SIGN
        textrun.push(0x0021); // EXCLAMATION MARK
        break;
      default:
        textrun.push(0x003C); // LESS-THAN SIGN
        reconsume(c, script_data_state);
        break;
    }
  }

  function script_data_end_tag_open_state(c) {
    /* identical to the RCDATA (and RAWTEXT) end tag open state, except s/RCDATA/Script data/g */
    switch (c) {
      case 0x0041: // [A-Z]
      case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
      case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
      case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
      case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
      case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      case 0x0061: // [a-z]
      case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
      case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
      case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
      case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
      case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
        beginEndTagName();
        reconsume(c, script_data_end_tag_name_state);
        break;
      default:
        textrun.push(0x003C); // LESS-THAN SIGN
        textrun.push(0x002F); // SOLIDUS
        reconsume(c, script_data_state);
        break;
    }
  }

  function script_data_end_tag_name_state(c) {
    /* identical to the RCDATA (and RAWTEXT) end tag name state, except s/RCDATA/Script data/g */
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        if (appropriateEndTag(tagnamebuf)) {
          tokenizer = before_attribute_name_state;
          return;
        }
        break;
      case 0x002F:
        // SOLIDUS
        if (appropriateEndTag(tagnamebuf)) {
          tokenizer = self_closing_start_tag_state;
          return;
        }
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        if (appropriateEndTag(tagnamebuf)) {
          tokenizer = data_state;
          emitTag();
          return;
        }
        break;
      case 0x0041: // [A-Z]
      case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
      case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
      case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
      case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
      case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:

        tagnamebuf += String.fromCharCode(c + 0x0020);
        tempbuf.push(c);
        return;
      case 0x0061: // [a-z]
      case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
      case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
      case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
      case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
      case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:

        tagnamebuf += String.fromCharCode(c);
        tempbuf.push(c);
        return;
      default:
        break;
    }

    // If we don't return in one of the cases above, then this was not
    // an appropriately matching close tag, so back out by emitting all
    // the characters as text
    textrun.push(0x003C); // LESS-THAN SIGN
    textrun.push(0x002F); // SOLIDUS
    pushAll(textrun, tempbuf);
    reconsume(c, script_data_state);
  }

  function script_data_escape_start_state(c) {
    if (c === 0x002D) {
      // HYPHEN-MINUS
      tokenizer = script_data_escape_start_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
    } else {
      reconsume(c, script_data_state);
    }
  }

  function script_data_escape_start_dash_state(c) {
    if (c === 0x002D) {
      // HYPHEN-MINUS
      tokenizer = script_data_escaped_dash_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
    } else {
      reconsume(c, script_data_state);
    }
  }

  function script_data_escaped_state(c) {
    switch (c) {
      case 0x002D:
        // HYPHEN-MINUS
        tokenizer = script_data_escaped_dash_state;
        textrun.push(0x002D); // HYPHEN-MINUS
        break;
      case 0x003C:
        // LESS-THAN SIGN
        tokenizer = script_data_escaped_less_than_sign_state;
        break;
      case 0x0000:
        // NULL
        textrun.push(0xFFFD); // REPLACEMENT CHARACTER
        break;
      case -1:
        // EOF
        emitEOF();
        break;
      default:
        textrun.push(c);
        break;
    }
  }

  function script_data_escaped_dash_state(c) {
    switch (c) {
      case 0x002D:
        // HYPHEN-MINUS
        tokenizer = script_data_escaped_dash_dash_state;
        textrun.push(0x002D); // HYPHEN-MINUS
        break;
      case 0x003C:
        // LESS-THAN SIGN
        tokenizer = script_data_escaped_less_than_sign_state;
        break;
      case 0x0000:
        // NULL
        tokenizer = script_data_escaped_state;
        textrun.push(0xFFFD); // REPLACEMENT CHARACTER
        break;
      case -1:
        // EOF
        emitEOF();
        break;
      default:
        tokenizer = script_data_escaped_state;
        textrun.push(c);
        break;
    }
  }

  function script_data_escaped_dash_dash_state(c) {
    switch (c) {
      case 0x002D:
        // HYPHEN-MINUS
        textrun.push(0x002D); // HYPHEN-MINUS
        break;
      case 0x003C:
        // LESS-THAN SIGN
        tokenizer = script_data_escaped_less_than_sign_state;
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        tokenizer = script_data_state;
        textrun.push(0x003E); // GREATER-THAN SIGN
        break;
      case 0x0000:
        // NULL
        tokenizer = script_data_escaped_state;
        textrun.push(0xFFFD); // REPLACEMENT CHARACTER
        break;
      case -1:
        // EOF
        emitEOF();
        break;
      default:
        tokenizer = script_data_escaped_state;
        textrun.push(c);
        break;
    }
  }

  function script_data_escaped_less_than_sign_state(c) {
    switch (c) {
      case 0x002F:
        // SOLIDUS
        beginTempBuf();
        tokenizer = script_data_escaped_end_tag_open_state;
        break;
      case 0x0041: // [A-Z]
      case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
      case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
      case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
      case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
      case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      case 0x0061: // [a-z]
      case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
      case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
      case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
      case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
      case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
        beginTempBuf();
        textrun.push(0x003C); // LESS-THAN SIGN
        reconsume(c, script_data_double_escape_start_state);
        break;
      default:
        textrun.push(0x003C); // LESS-THAN SIGN
        reconsume(c, script_data_escaped_state);
        break;
    }
  }

  function script_data_escaped_end_tag_open_state(c) {
    switch (c) {
      case 0x0041: // [A-Z]
      case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
      case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
      case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
      case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
      case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      case 0x0061: // [a-z]
      case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
      case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
      case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
      case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
      case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
        beginEndTagName();
        reconsume(c, script_data_escaped_end_tag_name_state);
        break;
      default:
        textrun.push(0x003C); // LESS-THAN SIGN
        textrun.push(0x002F); // SOLIDUS
        reconsume(c, script_data_escaped_state);
        break;
    }
  }

  function script_data_escaped_end_tag_name_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        if (appropriateEndTag(tagnamebuf)) {
          tokenizer = before_attribute_name_state;
          return;
        }
        break;
      case 0x002F:
        // SOLIDUS
        if (appropriateEndTag(tagnamebuf)) {
          tokenizer = self_closing_start_tag_state;
          return;
        }
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        if (appropriateEndTag(tagnamebuf)) {
          tokenizer = data_state;
          emitTag();
          return;
        }
        break;
      case 0x0041: // [A-Z]
      case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
      case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
      case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
      case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
      case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
        tagnamebuf += String.fromCharCode(c + 0x0020);
        tempbuf.push(c);
        return;
      case 0x0061: // [a-z]
      case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
      case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
      case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
      case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
      case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
        tagnamebuf += String.fromCharCode(c);
        tempbuf.push(c);
        return;
      default:
        break;
    }

    // We get here in the default case, and if the closing tagname
    // is not an appropriate tagname.
    textrun.push(0x003C); // LESS-THAN SIGN
    textrun.push(0x002F); // SOLIDUS
    pushAll(textrun, tempbuf);
    reconsume(c, script_data_escaped_state);
  }

  function script_data_double_escape_start_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020: // SPACE
      case 0x002F: // SOLIDUS
      case 0x003E:
        // GREATER-THAN SIGN
        if (buf2str(tempbuf) === "script") {
          tokenizer = script_data_double_escaped_state;
        } else {
          tokenizer = script_data_escaped_state;
        }
        textrun.push(c);
        break;
      case 0x0041: // [A-Z]
      case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
      case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
      case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
      case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
      case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
        tempbuf.push(c + 0x0020);
        textrun.push(c);
        break;
      case 0x0061: // [a-z]
      case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
      case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
      case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
      case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
      case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
        tempbuf.push(c);
        textrun.push(c);
        break;
      default:
        reconsume(c, script_data_escaped_state);
        break;
    }
  }

  function script_data_double_escaped_state(c) {
    switch (c) {
      case 0x002D:
        // HYPHEN-MINUS
        tokenizer = script_data_double_escaped_dash_state;
        textrun.push(0x002D); // HYPHEN-MINUS
        break;
      case 0x003C:
        // LESS-THAN SIGN
        tokenizer = script_data_double_escaped_less_than_sign_state;
        textrun.push(0x003C); // LESS-THAN SIGN
        break;
      case 0x0000:
        // NULL
        textrun.push(0xFFFD); // REPLACEMENT CHARACTER
        break;
      case -1:
        // EOF
        emitEOF();
        break;
      default:
        textrun.push(c);
        break;
    }
  }

  function script_data_double_escaped_dash_state(c) {
    switch (c) {
      case 0x002D:
        // HYPHEN-MINUS
        tokenizer = script_data_double_escaped_dash_dash_state;
        textrun.push(0x002D); // HYPHEN-MINUS
        break;
      case 0x003C:
        // LESS-THAN SIGN
        tokenizer = script_data_double_escaped_less_than_sign_state;
        textrun.push(0x003C); // LESS-THAN SIGN
        break;
      case 0x0000:
        // NULL
        tokenizer = script_data_double_escaped_state;
        textrun.push(0xFFFD); // REPLACEMENT CHARACTER
        break;
      case -1:
        // EOF
        emitEOF();
        break;
      default:
        tokenizer = script_data_double_escaped_state;
        textrun.push(c);
        break;
    }
  }

  function script_data_double_escaped_dash_dash_state(c) {
    switch (c) {
      case 0x002D:
        // HYPHEN-MINUS
        textrun.push(0x002D); // HYPHEN-MINUS
        break;
      case 0x003C:
        // LESS-THAN SIGN
        tokenizer = script_data_double_escaped_less_than_sign_state;
        textrun.push(0x003C); // LESS-THAN SIGN
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        tokenizer = script_data_state;
        textrun.push(0x003E); // GREATER-THAN SIGN
        break;
      case 0x0000:
        // NULL
        tokenizer = script_data_double_escaped_state;
        textrun.push(0xFFFD); // REPLACEMENT CHARACTER
        break;
      case -1:
        // EOF
        emitEOF();
        break;
      default:
        tokenizer = script_data_double_escaped_state;
        textrun.push(c);
        break;
    }
  }

  function script_data_double_escaped_less_than_sign_state(c) {
    if (c === 0x002F) {
      // SOLIDUS
      beginTempBuf();
      tokenizer = script_data_double_escape_end_state;
      textrun.push(0x002F); // SOLIDUS
    } else {
      reconsume(c, script_data_double_escaped_state);
    }
  }

  function script_data_double_escape_end_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020: // SPACE
      case 0x002F: // SOLIDUS
      case 0x003E:
        // GREATER-THAN SIGN
        if (buf2str(tempbuf) === "script") {
          tokenizer = script_data_escaped_state;
        } else {
          tokenizer = script_data_double_escaped_state;
        }
        textrun.push(c);
        break;
      case 0x0041: // [A-Z]
      case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
      case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
      case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
      case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
      case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
        tempbuf.push(c + 0x0020);
        textrun.push(c);
        break;
      case 0x0061: // [a-z]
      case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
      case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
      case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
      case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
      case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
        tempbuf.push(c);
        textrun.push(c);
        break;
      default:
        reconsume(c, script_data_double_escaped_state);
        break;
    }
  }

  function before_attribute_name_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        /* Ignore the character. */
        break;
      // For SOLIDUS, GREATER-THAN SIGN, and EOF, spec says "reconsume in
      // the after attribute name state", but in our implementation that
      // state always has an active attribute in attrnamebuf.  Just clone
      // the rules here, without the addAttribute business.
      case 0x002F:
        // SOLIDUS
        tokenizer = self_closing_start_tag_state;
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        tokenizer = data_state;
        emitTag();
        break;
      case -1:
        // EOF
        emitEOF();
        break;
      case 0x003D:
        // EQUALS SIGN
        beginAttrName();
        attrnamebuf += String.fromCharCode(c);
        tokenizer = attribute_name_state;
        break;
      default:
        if (handleSimpleAttribute()) break;
        beginAttrName();
        reconsume(c, attribute_name_state);
        break;
    }
  }

  // beginAttrName() must have been called before this point
  // There is an active attribute in attrnamebuf (but not attrvaluebuf)
  function attribute_name_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020: // SPACE
      case 0x002F: // SOLIDUS
      case 0x003E: // GREATER-THAN SIGN
      case -1:
        // EOF
        reconsume(c, after_attribute_name_state);
        break;
      case 0x003D:
        // EQUALS SIGN
        tokenizer = before_attribute_value_state;
        break;
      case 0x0041: // [A-Z]
      case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
      case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
      case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
      case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
      case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
        attrnamebuf += String.fromCharCode(c + 0x0020);
        break;
      case 0x0000:
        // NULL
        attrnamebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
        break;
      case 0x0022: // QUOTATION MARK
      case 0x0027: // APOSTROPHE
      case 0x003C: // LESS-THAN SIGN
      /* falls through */
      default:
        attrnamebuf += getMatchingChars(ATTRNAME);
        break;
    }
  }

  // There is an active attribute in attrnamebuf, but not yet in attrvaluebuf.
  function after_attribute_name_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        /* Ignore the character. */
        break;
      case 0x002F:
        // SOLIDUS
        // Keep in sync with before_attribute_name_state.
        addAttribute(attrnamebuf);
        tokenizer = self_closing_start_tag_state;
        break;
      case 0x003D:
        // EQUALS SIGN
        tokenizer = before_attribute_value_state;
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        // Keep in sync with before_attribute_name_state.
        tokenizer = data_state;
        addAttribute(attrnamebuf);
        emitTag();
        break;
      case -1:
        // EOF
        // Keep in sync with before_attribute_name_state.
        addAttribute(attrnamebuf);
        emitEOF();
        break;
      default:
        addAttribute(attrnamebuf);
        beginAttrName();
        reconsume(c, attribute_name_state);
        break;
    }
  }

  function before_attribute_value_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        /* Ignore the character. */
        break;
      case 0x0022:
        // QUOTATION MARK
        beginAttrValue();
        tokenizer = attribute_value_double_quoted_state;
        break;
      case 0x0027:
        // APOSTROPHE
        beginAttrValue();
        tokenizer = attribute_value_single_quoted_state;
        break;
      case 0x003E: // GREATER-THAN SIGN
      /* falls through */
      default:
        beginAttrValue();
        reconsume(c, attribute_value_unquoted_state);
        break;
    }
  }

  function attribute_value_double_quoted_state(c) {
    switch (c) {
      case 0x0022:
        // QUOTATION MARK
        addAttribute(attrnamebuf, attrvaluebuf);
        tokenizer = after_attribute_value_quoted_state;
        break;
      case 0x0026:
        // AMPERSAND
        return_state = attribute_value_double_quoted_state;
        tokenizer = character_reference_state;
        break;
      case 0x0000:
        // NULL
        attrvaluebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
        break;
      case -1:
        // EOF
        emitEOF();
        break;
      case 0x000A:
        // LF
        // this could be a converted \r, so don't use getMatchingChars
        attrvaluebuf += String.fromCharCode(c);
        break;
      default:
        attrvaluebuf += getMatchingChars(DBLQUOTEATTRVAL);
        break;
    }
  }

  function attribute_value_single_quoted_state(c) {
    switch (c) {
      case 0x0027:
        // APOSTROPHE
        addAttribute(attrnamebuf, attrvaluebuf);
        tokenizer = after_attribute_value_quoted_state;
        break;
      case 0x0026:
        // AMPERSAND
        return_state = attribute_value_single_quoted_state;
        tokenizer = character_reference_state;
        break;
      case 0x0000:
        // NULL
        attrvaluebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
        break;
      case -1:
        // EOF
        emitEOF();
        break;
      case 0x000A:
        // LF
        // this could be a converted \r, so don't use getMatchingChars
        attrvaluebuf += String.fromCharCode(c);
        break;
      default:
        attrvaluebuf += getMatchingChars(SINGLEQUOTEATTRVAL);
        break;
    }
  }

  function attribute_value_unquoted_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        addAttribute(attrnamebuf, attrvaluebuf);
        tokenizer = before_attribute_name_state;
        break;
      case 0x0026:
        // AMPERSAND
        return_state = attribute_value_unquoted_state;
        tokenizer = character_reference_state;
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        addAttribute(attrnamebuf, attrvaluebuf);
        tokenizer = data_state;
        emitTag();
        break;
      case 0x0000:
        // NULL
        attrvaluebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
        break;
      case -1:
        // EOF
        nextchar--; // pushback
        tokenizer = data_state;
        break;
      case 0x0022: // QUOTATION MARK
      case 0x0027: // APOSTROPHE
      case 0x003C: // LESS-THAN SIGN
      case 0x003D: // EQUALS SIGN
      case 0x0060: // GRAVE ACCENT
      /* falls through */
      default:
        attrvaluebuf += getMatchingChars(UNQUOTEDATTRVAL);
        break;
    }
  }

  function after_attribute_value_quoted_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        tokenizer = before_attribute_name_state;
        break;
      case 0x002F:
        // SOLIDUS
        tokenizer = self_closing_start_tag_state;
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        tokenizer = data_state;
        emitTag();
        break;
      case -1:
        // EOF
        emitEOF();
        break;
      default:
        reconsume(c, before_attribute_name_state);
        break;
    }
  }

  function self_closing_start_tag_state(c) {
    switch (c) {
      case 0x003E:
        // GREATER-THAN SIGN
        // Set the <i>self-closing flag</i> of the current tag token.
        tokenizer = data_state;
        emitSelfClosingTag(true);
        break;
      case -1:
        // EOF
        emitEOF();
        break;
      default:
        reconsume(c, before_attribute_name_state);
        break;
    }
  }

  function bogus_comment_state(c, lookahead, eof) {
    var len = lookahead.length;

    if (eof) {
      nextchar += len - 1; // don't consume the eof
    } else {
      nextchar += len;
    }

    var comment = lookahead.substring(0, len - 1);

    comment = comment.replace(/\u0000/g, '\uFFFD');
    comment = comment.replace(/\u000D\u000A/g, '\n');
    comment = comment.replace(/\u000D/g, '\n');

    insertToken(COMMENT, comment);
    tokenizer = data_state;
  }
  bogus_comment_state.lookahead = ">";

  function markup_declaration_open_state(c, lookahead, eof) {
    if (lookahead[0] === "-" && lookahead[1] === "-") {
      nextchar += 2;
      beginComment();
      tokenizer = comment_start_state;
      return;
    }

    if (lookahead.toUpperCase() === "DOCTYPE") {
      nextchar += 7;
      tokenizer = doctype_state;
    } else if (lookahead === "[CDATA[" && cdataAllowed()) {
      nextchar += 7;
      tokenizer = cdata_section_state;
    } else {
      tokenizer = bogus_comment_state;
    }
  }
  markup_declaration_open_state.lookahead = 7;

  function comment_start_state(c) {
    beginComment();
    switch (c) {
      case 0x002D:
        // HYPHEN-MINUS
        tokenizer = comment_start_dash_state;
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        tokenizer = data_state;
        insertToken(COMMENT, buf2str(commentbuf));
        break; /* see comment in comment end state */
      default:
        reconsume(c, comment_state);
        break;
    }
  }

  function comment_start_dash_state(c) {
    switch (c) {
      case 0x002D:
        // HYPHEN-MINUS
        tokenizer = comment_end_state;
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        tokenizer = data_state;
        insertToken(COMMENT, buf2str(commentbuf));
        break;
      case -1:
        // EOF
        insertToken(COMMENT, buf2str(commentbuf));
        emitEOF();
        break; /* see comment in comment end state */
      default:
        commentbuf.push(0x002D /* HYPHEN-MINUS */);
        reconsume(c, comment_state);
        break;
    }
  }

  function comment_state(c) {
    switch (c) {
      case 0x003C:
        // LESS-THAN SIGN
        commentbuf.push(c);
        tokenizer = comment_less_than_sign_state;
        break;
      case 0x002D:
        // HYPHEN-MINUS
        tokenizer = comment_end_dash_state;
        break;
      case 0x0000:
        // NULL
        commentbuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
        break;
      case -1:
        // EOF
        insertToken(COMMENT, buf2str(commentbuf));
        emitEOF();
        break; /* see comment in comment end state */
      default:
        commentbuf.push(c);
        break;
    }
  }

  function comment_less_than_sign_state(c) {
    switch (c) {
      case 0x0021:
        // EXCLAMATION MARK
        commentbuf.push(c);
        tokenizer = comment_less_than_sign_bang_state;
        break;
      case 0x003C:
        // LESS-THAN SIGN
        commentbuf.push(c);
        break;
      default:
        reconsume(c, comment_state);
        break;
    }
  }

  function comment_less_than_sign_bang_state(c) {
    switch (c) {
      case 0x002D:
        // HYPHEN-MINUS
        tokenizer = comment_less_than_sign_bang_dash_state;
        break;
      default:
        reconsume(c, comment_state);
        break;
    }
  }

  function comment_less_than_sign_bang_dash_state(c) {
    switch (c) {
      case 0x002D:
        // HYPHEN-MINUS
        tokenizer = comment_less_than_sign_bang_dash_dash_state;
        break;
      default:
        reconsume(c, comment_end_dash_state);
        break;
    }
  }

  function comment_less_than_sign_bang_dash_dash_state(c) {
    switch (c) {
      case 0x003E: // GREATER-THAN SIGN
      case -1:
        // EOF
        reconsume(c, comment_end_state);
        break;
      default:
        // parse error
        reconsume(c, comment_end_state);
        break;
    }
  }

  function comment_end_dash_state(c) {
    switch (c) {
      case 0x002D:
        // HYPHEN-MINUS
        tokenizer = comment_end_state;
        break;
      case -1:
        // EOF
        insertToken(COMMENT, buf2str(commentbuf));
        emitEOF();
        break; /* see comment in comment end state */
      default:
        commentbuf.push(0x002D /* HYPHEN-MINUS */);
        reconsume(c, comment_state);
        break;
    }
  }

  function comment_end_state(c) {
    switch (c) {
      case 0x003E:
        // GREATER-THAN SIGN
        tokenizer = data_state;
        insertToken(COMMENT, buf2str(commentbuf));
        break;
      case 0x0021:
        // EXCLAMATION MARK
        tokenizer = comment_end_bang_state;
        break;
      case 0x002D:
        // HYPHEN-MINUS
        commentbuf.push(0x002D);
        break;
      case -1:
        // EOF
        insertToken(COMMENT, buf2str(commentbuf));
        emitEOF();
        break; /* For security reasons: otherwise, hostile user could put a script in a comment e.g. in a blog comment and then DOS the server so that the end tag isn't read, and then the commented script tag would be treated as live code */
      default:
        commentbuf.push(0x002D);
        commentbuf.push(0x002D);
        reconsume(c, comment_state);
        break;
    }
  }

  function comment_end_bang_state(c) {
    switch (c) {
      case 0x002D:
        // HYPHEN-MINUS
        commentbuf.push(0x002D);
        commentbuf.push(0x002D);
        commentbuf.push(0x0021);
        tokenizer = comment_end_dash_state;
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        tokenizer = data_state;
        insertToken(COMMENT, buf2str(commentbuf));
        break;
      case -1:
        // EOF
        insertToken(COMMENT, buf2str(commentbuf));
        emitEOF();
        break; /* see comment in comment end state */
      default:
        commentbuf.push(0x002D);
        commentbuf.push(0x002D);
        commentbuf.push(0x0021);
        reconsume(c, comment_state);
        break;
    }
  }

  function doctype_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        tokenizer = before_doctype_name_state;
        break;
      case -1:
        // EOF
        beginDoctype();
        forcequirks();
        emitDoctype();
        emitEOF();
        break;
      default:
        reconsume(c, before_doctype_name_state);
        break;
    }
  }

  function before_doctype_name_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        /* Ignore the character. */
        break;
      case 0x0041: // [A-Z]
      case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
      case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
      case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
      case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
      case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
        beginDoctype();
        doctypenamebuf.push(c + 0x0020);
        tokenizer = doctype_name_state;
        break;
      case 0x0000:
        // NULL
        beginDoctype();
        doctypenamebuf.push(0xFFFD);
        tokenizer = doctype_name_state;
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        beginDoctype();
        forcequirks();
        tokenizer = data_state;
        emitDoctype();
        break;
      case -1:
        // EOF
        beginDoctype();
        forcequirks();
        emitDoctype();
        emitEOF();
        break;
      default:
        beginDoctype();
        doctypenamebuf.push(c);
        tokenizer = doctype_name_state;
        break;
    }
  }

  function doctype_name_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        tokenizer = after_doctype_name_state;
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        tokenizer = data_state;
        emitDoctype();
        break;
      case 0x0041: // [A-Z]
      case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
      case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
      case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
      case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
      case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
        doctypenamebuf.push(c + 0x0020);
        break;
      case 0x0000:
        // NULL
        doctypenamebuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
        break;
      case -1:
        // EOF
        forcequirks();
        emitDoctype();
        emitEOF();
        break;
      default:
        doctypenamebuf.push(c);
        break;
    }
  }

  function after_doctype_name_state(c, lookahead, eof) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        /* Ignore the character. */
        nextchar += 1;
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        tokenizer = data_state;
        nextchar += 1;
        emitDoctype();
        break;
      case -1:
        // EOF
        forcequirks();
        emitDoctype();
        emitEOF();
        break;
      default:
        lookahead = lookahead.toUpperCase();
        if (lookahead === "PUBLIC") {
          nextchar += 6;
          tokenizer = after_doctype_public_keyword_state;
        } else if (lookahead === "SYSTEM") {
          nextchar += 6;
          tokenizer = after_doctype_system_keyword_state;
        } else {
          forcequirks();
          tokenizer = bogus_doctype_state;
        }
        break;
    }
  }
  after_doctype_name_state.lookahead = 6;

  function after_doctype_public_keyword_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        tokenizer = before_doctype_public_identifier_state;
        break;
      case 0x0022:
        // QUOTATION MARK
        beginDoctypePublicId();
        tokenizer = doctype_public_identifier_double_quoted_state;
        break;
      case 0x0027:
        // APOSTROPHE
        beginDoctypePublicId();
        tokenizer = doctype_public_identifier_single_quoted_state;
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        forcequirks();
        tokenizer = data_state;
        emitDoctype();
        break;
      case -1:
        // EOF
        forcequirks();
        emitDoctype();
        emitEOF();
        break;
      default:
        forcequirks();
        tokenizer = bogus_doctype_state;
        break;
    }
  }

  function before_doctype_public_identifier_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        /* Ignore the character. */
        break;
      case 0x0022:
        // QUOTATION MARK
        beginDoctypePublicId();
        tokenizer = doctype_public_identifier_double_quoted_state;
        break;
      case 0x0027:
        // APOSTROPHE
        beginDoctypePublicId();
        tokenizer = doctype_public_identifier_single_quoted_state;
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        forcequirks();
        tokenizer = data_state;
        emitDoctype();
        break;
      case -1:
        // EOF
        forcequirks();
        emitDoctype();
        emitEOF();
        break;
      default:
        forcequirks();
        tokenizer = bogus_doctype_state;
        break;
    }
  }

  function doctype_public_identifier_double_quoted_state(c) {
    switch (c) {
      case 0x0022:
        // QUOTATION MARK
        tokenizer = after_doctype_public_identifier_state;
        break;
      case 0x0000:
        // NULL
        doctypepublicbuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        forcequirks();
        tokenizer = data_state;
        emitDoctype();
        break;
      case -1:
        // EOF
        forcequirks();
        emitDoctype();
        emitEOF();
        break;
      default:
        doctypepublicbuf.push(c);
        break;
    }
  }

  function doctype_public_identifier_single_quoted_state(c) {
    switch (c) {
      case 0x0027:
        // APOSTROPHE
        tokenizer = after_doctype_public_identifier_state;
        break;
      case 0x0000:
        // NULL
        doctypepublicbuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        forcequirks();
        tokenizer = data_state;
        emitDoctype();
        break;
      case -1:
        // EOF
        forcequirks();
        emitDoctype();
        emitEOF();
        break;
      default:
        doctypepublicbuf.push(c);
        break;
    }
  }

  function after_doctype_public_identifier_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        tokenizer = between_doctype_public_and_system_identifiers_state;
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        tokenizer = data_state;
        emitDoctype();
        break;
      case 0x0022:
        // QUOTATION MARK
        beginDoctypeSystemId();
        tokenizer = doctype_system_identifier_double_quoted_state;
        break;
      case 0x0027:
        // APOSTROPHE
        beginDoctypeSystemId();
        tokenizer = doctype_system_identifier_single_quoted_state;
        break;
      case -1:
        // EOF
        forcequirks();
        emitDoctype();
        emitEOF();
        break;
      default:
        forcequirks();
        tokenizer = bogus_doctype_state;
        break;
    }
  }

  function between_doctype_public_and_system_identifiers_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE Ignore the character.
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        tokenizer = data_state;
        emitDoctype();
        break;
      case 0x0022:
        // QUOTATION MARK
        beginDoctypeSystemId();
        tokenizer = doctype_system_identifier_double_quoted_state;
        break;
      case 0x0027:
        // APOSTROPHE
        beginDoctypeSystemId();
        tokenizer = doctype_system_identifier_single_quoted_state;
        break;
      case -1:
        // EOF
        forcequirks();
        emitDoctype();
        emitEOF();
        break;
      default:
        forcequirks();
        tokenizer = bogus_doctype_state;
        break;
    }
  }

  function after_doctype_system_keyword_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        tokenizer = before_doctype_system_identifier_state;
        break;
      case 0x0022:
        // QUOTATION MARK
        beginDoctypeSystemId();
        tokenizer = doctype_system_identifier_double_quoted_state;
        break;
      case 0x0027:
        // APOSTROPHE
        beginDoctypeSystemId();
        tokenizer = doctype_system_identifier_single_quoted_state;
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        forcequirks();
        tokenizer = data_state;
        emitDoctype();
        break;
      case -1:
        // EOF
        forcequirks();
        emitDoctype();
        emitEOF();
        break;
      default:
        forcequirks();
        tokenizer = bogus_doctype_state;
        break;
    }
  }

  function before_doctype_system_identifier_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE Ignore the character.
        break;
      case 0x0022:
        // QUOTATION MARK
        beginDoctypeSystemId();
        tokenizer = doctype_system_identifier_double_quoted_state;
        break;
      case 0x0027:
        // APOSTROPHE
        beginDoctypeSystemId();
        tokenizer = doctype_system_identifier_single_quoted_state;
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        forcequirks();
        tokenizer = data_state;
        emitDoctype();
        break;
      case -1:
        // EOF
        forcequirks();
        emitDoctype();
        emitEOF();
        break;
      default:
        forcequirks();
        tokenizer = bogus_doctype_state;
        break;
    }
  }

  function doctype_system_identifier_double_quoted_state(c) {
    switch (c) {
      case 0x0022:
        // QUOTATION MARK
        tokenizer = after_doctype_system_identifier_state;
        break;
      case 0x0000:
        // NULL
        doctypesystembuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        forcequirks();
        tokenizer = data_state;
        emitDoctype();
        break;
      case -1:
        // EOF
        forcequirks();
        emitDoctype();
        emitEOF();
        break;
      default:
        doctypesystembuf.push(c);
        break;
    }
  }

  function doctype_system_identifier_single_quoted_state(c) {
    switch (c) {
      case 0x0027:
        // APOSTROPHE
        tokenizer = after_doctype_system_identifier_state;
        break;
      case 0x0000:
        // NULL
        doctypesystembuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        forcequirks();
        tokenizer = data_state;
        emitDoctype();
        break;
      case -1:
        // EOF
        forcequirks();
        emitDoctype();
        emitEOF();
        break;
      default:
        doctypesystembuf.push(c);
        break;
    }
  }

  function after_doctype_system_identifier_state(c) {
    switch (c) {
      case 0x0009: // CHARACTER TABULATION (tab)
      case 0x000A: // LINE FEED (LF)
      case 0x000C: // FORM FEED (FF)
      case 0x0020:
        // SPACE
        /* Ignore the character. */
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        tokenizer = data_state;
        emitDoctype();
        break;
      case -1:
        // EOF
        forcequirks();
        emitDoctype();
        emitEOF();
        break;
      default:
        tokenizer = bogus_doctype_state;
        /* This does *not* set the DOCTYPE token's force-quirks flag. */
        break;
    }
  }

  function bogus_doctype_state(c) {
    switch (c) {
      case 0x003E:
        // GREATER-THAN SIGN
        tokenizer = data_state;
        emitDoctype();
        break;
      case -1:
        // EOF
        emitDoctype();
        emitEOF();
        break;
      default:
        /* Ignore the character. */
        break;
    }
  }

  function cdata_section_state(c) {
    switch (c) {
      case 0x005D:
        // RIGHT SQUARE BRACKET
        tokenizer = cdata_section_bracket_state;
        break;
      case -1:
        // EOF
        emitEOF();
        break;
      case 0x0000:
        // NULL
        textIncludesNUL = true;
      /* fall through */
      default:
        // Instead of just pushing a single character and then
        // coming back to the very same place, lookahead and
        // emit everything we can at once.
        /*jshint -W030 */
        emitCharsWhile(CDATATEXT) || textrun.push(c);
        break;
    }
  }

  function cdata_section_bracket_state(c) {
    switch (c) {
      case 0x005D:
        // RIGHT SQUARE BRACKET
        tokenizer = cdata_section_end_state;
        break;
      default:
        textrun.push(0x005D);
        reconsume(c, cdata_section_state);
        break;
    }
  }

  function cdata_section_end_state(c) {
    switch (c) {
      case 0x005D:
        // RIGHT SQUARE BRACKET
        textrun.push(0x005D);
        break;
      case 0x003E:
        // GREATER-THAN SIGN
        flushText();
        tokenizer = data_state;
        break;
      default:
        textrun.push(0x005D);
        textrun.push(0x005D);
        reconsume(c, cdata_section_state);
        break;
    }
  }

  function character_reference_state(c) {
    beginTempBuf();
    tempbuf.push(0x0026);
    switch (c) {
      case 0x0009: // TAB
      case 0x000A: // LINE FEED
      case 0x000C: // FORM FEED
      case 0x0020: // SPACE
      case 0x003C: // LESS-THAN SIGN
      case 0x0026: // AMPERSAND
      case -1:
        // EOF
        reconsume(c, character_reference_end_state);
        break;
      case 0x0023:
        // NUMBER SIGN
        tempbuf.push(c);
        tokenizer = numeric_character_reference_state;
        break;
      default:
        reconsume(c, named_character_reference_state);
        break;
    }
  }

  function named_character_reference_state(c) {
    NAMEDCHARREF.lastIndex = nextchar; // w/ lookahead no char has been consumed
    var matched = NAMEDCHARREF.exec(chars);
    if (!matched) throw new Error("should never happen");
    var name = matched[1];
    if (!name) {
      // If no match can be made, switch to the character reference end state
      tokenizer = character_reference_end_state;
      return;
    }

    // Consume the matched characters and append them to temporary buffer
    nextchar += name.length;
    pushAll(tempbuf, str2buf(name));

    switch (return_state) {
      case attribute_value_double_quoted_state:
      case attribute_value_single_quoted_state:
      case attribute_value_unquoted_state:
        // If the character reference was consumed as part of an attribute...
        if (name[name.length - 1] !== ';') {
          // ...and the last char is not ;
          if (/[=A-Za-z0-9]/.test(chars[nextchar])) {
            tokenizer = character_reference_end_state;
            return;
          }
        }
        break;
      default:
        break;
    }

    beginTempBuf();
    var rv = namedCharRefs[name];
    if (typeof rv === 'number') {
      tempbuf.push(rv);
    } else {
      pushAll(tempbuf, rv);
    }
    tokenizer = character_reference_end_state;
  }
  // We might need to pause tokenization until we have enough characters
  // in the buffer for longest possible character reference.
  named_character_reference_state.lookahead = -NAMEDCHARREF_MAXLEN;

  function numeric_character_reference_state(c) {
    character_reference_code = 0;
    switch (c) {
      case 0x0078: // x
      case 0x0058:
        // X
        tempbuf.push(c);
        tokenizer = hexadecimal_character_reference_start_state;
        break;
      default:
        reconsume(c, decimal_character_reference_start_state);
        break;
    }
  }

  function hexadecimal_character_reference_start_state(c) {
    switch (c) {
      case 0x0030:case 0x0031:case 0x0032:case 0x0033:case 0x0034:
      case 0x0035:case 0x0036:case 0x0037:case 0x0038:case 0x0039: // [0-9]
      case 0x0041:case 0x0042:case 0x0043:case 0x0044:case 0x0045:
      case 0x0046: // [A-F]
      case 0x0061:case 0x0062:case 0x0063:case 0x0064:case 0x0065:
      case 0x0066:
        // [a-f]
        reconsume(c, hexadecimal_character_reference_state);
        break;
      default:
        reconsume(c, character_reference_end_state);
        break;
    }
  }

  function decimal_character_reference_start_state(c) {
    switch (c) {
      case 0x0030:case 0x0031:case 0x0032:case 0x0033:case 0x0034:
      case 0x0035:case 0x0036:case 0x0037:case 0x0038:case 0x0039:
        // [0-9]
        reconsume(c, decimal_character_reference_state);
        break;
      default:
        reconsume(c, character_reference_end_state);
        break;
    }
  }

  function hexadecimal_character_reference_state(c) {
    switch (c) {
      case 0x0041:case 0x0042:case 0x0043:case 0x0044:case 0x0045:
      case 0x0046:
        // [A-F]
        character_reference_code *= 16;
        character_reference_code += c - 0x0037;
        break;
      case 0x0061:case 0x0062:case 0x0063:case 0x0064:case 0x0065:
      case 0x0066:
        // [a-f]
        character_reference_code *= 16;
        character_reference_code += c - 0x0057;
        break;
      case 0x0030:case 0x0031:case 0x0032:case 0x0033:case 0x0034:
      case 0x0035:case 0x0036:case 0x0037:case 0x0038:case 0x0039:
        // [0-9]
        character_reference_code *= 16;
        character_reference_code += c - 0x0030;
        break;
      case 0x003B:
        // SEMICOLON
        tokenizer = numeric_character_reference_end_state;
        break;
      default:
        reconsume(c, numeric_character_reference_end_state);
        break;
    }
  }

  function decimal_character_reference_state(c) {
    switch (c) {
      case 0x0030:case 0x0031:case 0x0032:case 0x0033:case 0x0034:
      case 0x0035:case 0x0036:case 0x0037:case 0x0038:case 0x0039:
        // [0-9]
        character_reference_code *= 10;
        character_reference_code += c - 0x0030;
        break;
      case 0x003B:
        // SEMICOLON
        tokenizer = numeric_character_reference_end_state;
        break;
      default:
        reconsume(c, numeric_character_reference_end_state);
        break;
    }
  }

  function numeric_character_reference_end_state(c) {
    if (character_reference_code in numericCharRefReplacements) {
      character_reference_code = numericCharRefReplacements[character_reference_code];
    } else if (character_reference_code > 0x10FFFF || character_reference_code >= 0xD800 && character_reference_code < 0xE000) {
      character_reference_code = 0xFFFD;
    }

    beginTempBuf();
    if (character_reference_code <= 0xFFFF) {
      tempbuf.push(character_reference_code);
    } else {
      character_reference_code = character_reference_code - 0x10000;
      /* jshint bitwise: false */
      tempbuf.push(0xD800 + (character_reference_code >> 10));
      tempbuf.push(0xDC00 + (character_reference_code & 0x03FF));
    }
    reconsume(c, character_reference_end_state);
  }

  function character_reference_end_state(c) {
    switch (return_state) {
      case attribute_value_double_quoted_state:
      case attribute_value_single_quoted_state:
      case attribute_value_unquoted_state:
        // append each character to the current attribute's value
        attrvaluebuf += buf2str(tempbuf);
        break;
      default:
        pushAll(textrun, tempbuf);
        break;
    }
    reconsume(c, return_state);
  }

  /***
   * The tree builder insertion modes
   */

  // 11.2.5.4.1 The "initial" insertion mode
  function initial_mode(t, value, arg3, arg4) {
    switch (t) {
      case 1:
        // TEXT
        value = value.replace(LEADINGWS, ""); // Ignore spaces
        if (value.length === 0) return; // Are we done?
        break; // Handle anything non-space text below
      case 4:
        // COMMENT
        doc._appendChild(doc.createComment(value));
        return;
      case 5:
        // DOCTYPE
        var name = value;
        var publicid = arg3;
        var systemid = arg4;
        // Use the constructor directly instead of
        // implementation.createDocumentType because the create
        // function throws errors on invalid characters, and
        // we don't want the parser to throw them.
        doc.appendChild(new DocumentType(doc, name, publicid, systemid));

        // Note that there is no public API for setting quirks mode We can
        // do this here because we have access to implementation details
        if (force_quirks || name.toLowerCase() !== "html" || quirkyPublicIds.test(publicid) || systemid && systemid.toLowerCase() === quirkySystemId || systemid === undefined && conditionallyQuirkyPublicIds.test(publicid)) doc._quirks = true;else if (limitedQuirkyPublicIds.test(publicid) || systemid !== undefined && conditionallyQuirkyPublicIds.test(publicid)) doc._limitedQuirks = true;
        parser = before_html_mode;
        return;
    }

    // tags or non-whitespace text
    doc._quirks = true;
    parser = before_html_mode;
    parser(t, value, arg3, arg4);
  }

  // 11.2.5.4.2 The "before html" insertion mode
  function before_html_mode(t, value, arg3, arg4) {
    var elt;
    switch (t) {
      case 1:
        // TEXT
        value = value.replace(LEADINGWS, ""); // Ignore spaces
        if (value.length === 0) return; // Are we done?
        break; // Handle anything non-space text below
      case 5:
        // DOCTYPE
        /* ignore the token */
        return;
      case 4:
        // COMMENT
        doc._appendChild(doc.createComment(value));
        return;
      case 2:
        // TAG
        if (value === "html") {
          elt = createHTMLElt(doc, value, arg3);
          stack.push(elt);
          doc.appendChild(elt);
          // XXX: handle application cache here
          parser = before_head_mode;
          return;
        }
        break;
      case 3:
        // ENDTAG
        switch (value) {
          case "html":
          case "head":
          case "body":
          case "br":
            break; // fall through on these
          default:
            return; // ignore most end tags
        }
    }

    // Anything that didn't get handled above is handled like this:
    elt = createHTMLElt(doc, "html", null);
    stack.push(elt);
    doc.appendChild(elt);
    // XXX: handle application cache here
    parser = before_head_mode;
    parser(t, value, arg3, arg4);
  }

  // 11.2.5.4.3 The "before head" insertion mode
  function before_head_mode(t, value, arg3, arg4) {
    switch (t) {
      case 1:
        // TEXT
        value = value.replace(LEADINGWS, ""); // Ignore spaces
        if (value.length === 0) return; // Are we done?
        break; // Handle anything non-space text below
      case 5:
        // DOCTYPE
        /* ignore the token */
        return;
      case 4:
        // COMMENT
        insertComment(value);
        return;
      case 2:
        // TAG
        switch (value) {
          case "html":
            in_body_mode(t, value, arg3, arg4);
            return;
          case "head":
            var elt = insertHTMLElement(value, arg3);
            head_element_pointer = elt;
            parser = in_head_mode;
            return;
        }
        break;
      case 3:
        // ENDTAG
        switch (value) {
          case "html":
          case "head":
          case "body":
          case "br":
            break;
          default:
            return; // ignore most end tags
        }
    }

    // If not handled explicitly above
    before_head_mode(TAG, "head", null); // create a head tag
    parser(t, value, arg3, arg4); // then try again with this token
  }

  function in_head_mode(t, value, arg3, arg4) {
    switch (t) {
      case 1:
        // TEXT
        var ws = value.match(LEADINGWS);
        if (ws) {
          insertText(ws[0]);
          value = value.substring(ws[0].length);
        }
        if (value.length === 0) return;
        break; // Handle non-whitespace below
      case 4:
        // COMMENT
        insertComment(value);
        return;
      case 5:
        // DOCTYPE
        return;
      case 2:
        // TAG
        switch (value) {
          case "html":
            in_body_mode(t, value, arg3, arg4);
            return;
          case "meta":
          // XXX:
          // May need to change the encoding based on this tag
          /* falls through */
          case "base":
          case "basefont":
          case "bgsound":
          case "link":
            insertHTMLElement(value, arg3);
            stack.pop();
            return;
          case "title":
            parseRCDATA(value, arg3);
            return;
          case "noscript":
            if (!scripting_enabled) {
              insertHTMLElement(value, arg3);
              parser = in_head_noscript_mode;
              return;
            }
          // Otherwise, if scripting is enabled...
          /* falls through */
          case "noframes":
          case "style":
            parseRawText(value, arg3);
            return;
          case "script":
            insertElement(function (doc) {
              var elt = createHTMLElt(doc, value, arg3);
              elt._parser_inserted = true;
              elt._force_async = false;
              if (fragment) elt._already_started = true;
              flushText();
              return elt;
            });
            tokenizer = script_data_state;
            originalInsertionMode = parser;
            parser = text_mode;
            return;
          case "template":
            insertHTMLElement(value, arg3);
            afe.insertMarker();
            frameset_ok = false;
            parser = in_template_mode;
            templateInsertionModes.push(parser);
            return;
          case "head":
            return; // ignore it
        }
        break;
      case 3:
        // ENDTAG
        switch (value) {
          case "head":
            stack.pop();
            parser = after_head_mode;
            return;
          case "body":
          case "html":
          case "br":
            break; // handle these at the bottom of the function
          case "template":
            if (!stack.contains("template")) {
              return;
            }
            stack.generateImpliedEndTags(null, "thorough");
            stack.popTag("template");
            afe.clearToMarker();
            templateInsertionModes.pop();
            resetInsertionMode();
            return;
          default:
            // ignore any other end tag
            return;
        }
        break;
    }

    // If not handled above
    in_head_mode(ENDTAG, "head", null); // synthetic </head>
    parser(t, value, arg3, arg4); // Then redo this one
  }

  // 13.2.5.4.5 The "in head noscript" insertion mode
  function in_head_noscript_mode(t, value, arg3, arg4) {
    switch (t) {
      case 5:
        // DOCTYPE
        return;
      case 4:
        // COMMENT
        in_head_mode(t, value);
        return;
      case 1:
        // TEXT
        var ws = value.match(LEADINGWS);
        if (ws) {
          in_head_mode(t, ws[0]);
          value = value.substring(ws[0].length);
        }
        if (value.length === 0) return; // no more text
        break; // Handle non-whitespace below
      case 2:
        // TAG
        switch (value) {
          case "html":
            in_body_mode(t, value, arg3, arg4);
            return;
          case "basefont":
          case "bgsound":
          case "link":
          case "meta":
          case "noframes":
          case "style":
            in_head_mode(t, value, arg3);
            return;
          case "head":
          case "noscript":
            return;
        }
        break;
      case 3:
        // ENDTAG
        switch (value) {
          case "noscript":
            stack.pop();
            parser = in_head_mode;
            return;
          case "br":
            break; // goes to the outer default
          default:
            return; // ignore other end tags
        }
        break;
    }

    // If not handled above
    in_head_noscript_mode(ENDTAG, "noscript", null);
    parser(t, value, arg3, arg4);
  }

  function after_head_mode(t, value, arg3, arg4) {
    switch (t) {
      case 1:
        // TEXT
        var ws = value.match(LEADINGWS);
        if (ws) {
          insertText(ws[0]);
          value = value.substring(ws[0].length);
        }
        if (value.length === 0) return;
        break; // Handle non-whitespace below
      case 4:
        // COMMENT
        insertComment(value);
        return;
      case 5:
        // DOCTYPE
        return;
      case 2:
        // TAG
        switch (value) {
          case "html":
            in_body_mode(t, value, arg3, arg4);
            return;
          case "body":
            insertHTMLElement(value, arg3);
            frameset_ok = false;
            parser = in_body_mode;
            return;
          case "frameset":
            insertHTMLElement(value, arg3);
            parser = in_frameset_mode;
            return;
          case "base":
          case "basefont":
          case "bgsound":
          case "link":
          case "meta":
          case "noframes":
          case "script":
          case "style":
          case "template":
          case "title":
            stack.push(head_element_pointer);
            in_head_mode(TAG, value, arg3);
            stack.removeElement(head_element_pointer);
            return;
          case "head":
            return;
        }
        break;
      case 3:
        // ENDTAG
        switch (value) {
          case "template":
            return in_head_mode(t, value, arg3, arg4);
          case "body":
          case "html":
          case "br":
            break;
          default:
            return; // ignore any other end tag
        }
        break;
    }

    after_head_mode(TAG, "body", null);
    frameset_ok = true;
    parser(t, value, arg3, arg4);
  }

  // 13.2.5.4.7 The "in body" insertion mode
  function in_body_mode(t, value, arg3, arg4) {
    var body, i, node, elt;
    switch (t) {
      case 1:
        // TEXT
        if (textIncludesNUL) {
          value = value.replace(NULCHARS, "");
          if (value.length === 0) return;
        }
        // If any non-space characters
        if (frameset_ok && NONWS.test(value)) frameset_ok = false;
        afereconstruct();
        insertText(value);
        return;
      case 5:
        // DOCTYPE
        return;
      case 4:
        // COMMENT
        insertComment(value);
        return;
      case -1:
        // EOF
        if (templateInsertionModes.length) {
          return in_template_mode(t);
        }
        stopParsing();
        return;
      case 2:
        // TAG
        switch (value) {
          case "html":
            if (stack.contains("template")) {
              return;
            }
            transferAttributes(arg3, stack.elements[0]);
            return;
          case "base":
          case "basefont":
          case "bgsound":
          case "link":
          case "meta":
          case "noframes":
          case "script":
          case "style":
          case "template":
          case "title":
            in_head_mode(TAG, value, arg3);
            return;
          case "body":
            body = stack.elements[1];
            if (!body || !(body instanceof impl.HTMLBodyElement) || stack.contains("template")) return;
            frameset_ok = false;
            transferAttributes(arg3, body);
            return;
          case "frameset":
            if (!frameset_ok) return;
            body = stack.elements[1];
            if (!body || !(body instanceof impl.HTMLBodyElement)) return;
            if (body.parentNode) body.parentNode.removeChild(body);
            while (!(stack.top instanceof impl.HTMLHtmlElement)) {
              stack.pop();
            }insertHTMLElement(value, arg3);
            parser = in_frameset_mode;
            return;

          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
            if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
            insertHTMLElement(value, arg3);
            return;

          case "menu":
            if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
            if (isA(stack.top, 'menuitem')) {
              stack.pop();
            }
            insertHTMLElement(value, arg3);
            return;

          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
            if (stack.top instanceof impl.HTMLHeadingElement) stack.pop();
            insertHTMLElement(value, arg3);
            return;

          case "pre":
          case "listing":
            if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
            insertHTMLElement(value, arg3);
            ignore_linefeed = true;
            frameset_ok = false;
            return;

          case "form":
            if (form_element_pointer && !stack.contains("template")) return;
            if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
            elt = insertHTMLElement(value, arg3);
            if (!stack.contains("template")) form_element_pointer = elt;
            return;

          case "li":
            frameset_ok = false;
            for (i = stack.elements.length - 1; i >= 0; i--) {
              node = stack.elements[i];
              if (node instanceof impl.HTMLLIElement) {
                in_body_mode(ENDTAG, "li");
                break;
              }
              if (isA(node, specialSet) && !isA(node, addressdivpSet)) break;
            }
            if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
            insertHTMLElement(value, arg3);
            return;

          case "dd":
          case "dt":
            frameset_ok = false;
            for (i = stack.elements.length - 1; i >= 0; i--) {
              node = stack.elements[i];
              if (isA(node, dddtSet)) {
                in_body_mode(ENDTAG, node.localName);
                break;
              }
              if (isA(node, specialSet) && !isA(node, addressdivpSet)) break;
            }
            if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
            insertHTMLElement(value, arg3);
            return;

          case "plaintext":
            if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
            insertHTMLElement(value, arg3);
            tokenizer = plaintext_state;
            return;

          case "button":
            if (stack.inScope("button")) {
              in_body_mode(ENDTAG, "button");
              parser(t, value, arg3, arg4);
            } else {
              afereconstruct();
              insertHTMLElement(value, arg3);
              frameset_ok = false;
            }
            return;

          case "a":
            var activeElement = afe.findElementByTag("a");
            if (activeElement) {
              in_body_mode(ENDTAG, value);
              afe.remove(activeElement);
              stack.removeElement(activeElement);
            }
          /* falls through */
          case "b":
          case "big":
          case "code":
          case "em":
          case "font":
          case "i":
          case "s":
          case "small":
          case "strike":
          case "strong":
          case "tt":
          case "u":
            afereconstruct();
            afe.push(insertHTMLElement(value, arg3), arg3);
            return;

          case "nobr":
            afereconstruct();

            if (stack.inScope(value)) {
              in_body_mode(ENDTAG, value);
              afereconstruct();
            }
            afe.push(insertHTMLElement(value, arg3), arg3);
            return;

          case "applet":
          case "marquee":
          case "object":
            afereconstruct();
            insertHTMLElement(value, arg3);
            afe.insertMarker();
            frameset_ok = false;
            return;

          case "table":
            if (!doc._quirks && stack.inButtonScope("p")) {
              in_body_mode(ENDTAG, "p");
            }
            insertHTMLElement(value, arg3);
            frameset_ok = false;
            parser = in_table_mode;
            return;

          case "area":
          case "br":
          case "embed":
          case "img":
          case "keygen":
          case "wbr":
            afereconstruct();
            insertHTMLElement(value, arg3);
            stack.pop();
            frameset_ok = false;
            return;

          case "input":
            afereconstruct();
            elt = insertHTMLElement(value, arg3);
            stack.pop();
            var type = elt.getAttribute("type");
            if (!type || type.toLowerCase() !== "hidden") frameset_ok = false;
            return;

          case "param":
          case "source":
          case "track":
            insertHTMLElement(value, arg3);
            stack.pop();
            return;

          case "hr":
            if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
            if (isA(stack.top, 'menuitem')) {
              stack.pop();
            }
            insertHTMLElement(value, arg3);
            stack.pop();
            frameset_ok = false;
            return;

          case "image":
            in_body_mode(TAG, "img", arg3, arg4);
            return;

          case "textarea":
            insertHTMLElement(value, arg3);
            ignore_linefeed = true;
            frameset_ok = false;
            tokenizer = rcdata_state;
            originalInsertionMode = parser;
            parser = text_mode;
            return;

          case "xmp":
            if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
            afereconstruct();
            frameset_ok = false;
            parseRawText(value, arg3);
            return;

          case "iframe":
            frameset_ok = false;
            parseRawText(value, arg3);
            return;

          case "noembed":
            parseRawText(value, arg3);
            return;

          case "noscript":
            if (scripting_enabled) {
              parseRawText(value, arg3);
              return;
            }
            break; // XXX Otherwise treat it as any other open tag?

          case "select":
            afereconstruct();
            insertHTMLElement(value, arg3);
            frameset_ok = false;
            if (parser === in_table_mode || parser === in_caption_mode || parser === in_table_body_mode || parser === in_row_mode || parser === in_cell_mode) parser = in_select_in_table_mode;else parser = in_select_mode;
            return;

          case "optgroup":
          case "option":
            if (stack.top instanceof impl.HTMLOptionElement) {
              in_body_mode(ENDTAG, "option");
            }
            afereconstruct();
            insertHTMLElement(value, arg3);
            return;

          case "menuitem":
            if (isA(stack.top, 'menuitem')) {
              stack.pop();
            }
            afereconstruct();
            insertHTMLElement(value, arg3);
            return;

          case "rb":
          case "rtc":
            if (stack.inScope("ruby")) {
              stack.generateImpliedEndTags();
            }
            insertHTMLElement(value, arg3);
            return;

          case "rp":
          case "rt":
            if (stack.inScope("ruby")) {
              stack.generateImpliedEndTags("rtc");
            }
            insertHTMLElement(value, arg3);
            return;

          case "math":
            afereconstruct();
            adjustMathMLAttributes(arg3);
            adjustForeignAttributes(arg3);
            insertForeignElement(value, arg3, NAMESPACE.MATHML);
            if (arg4) // self-closing flag
              stack.pop();
            return;

          case "svg":
            afereconstruct();
            adjustSVGAttributes(arg3);
            adjustForeignAttributes(arg3);
            insertForeignElement(value, arg3, NAMESPACE.SVG);
            if (arg4) // self-closing flag
              stack.pop();
            return;

          case "caption":
          case "col":
          case "colgroup":
          case "frame":
          case "head":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            // Ignore table tags if we're not in_table mode
            return;
        }

        // Handle any other start tag here
        // (and also noscript tags when scripting is disabled)
        afereconstruct();
        insertHTMLElement(value, arg3);
        return;

      case 3:
        // ENDTAG
        switch (value) {
          case "template":
            in_head_mode(ENDTAG, value, arg3);
            return;
          case "body":
            if (!stack.inScope("body")) return;
            parser = after_body_mode;
            return;
          case "html":
            if (!stack.inScope("body")) return;
            parser = after_body_mode;
            parser(t, value, arg3);
            return;

          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "button":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "listing":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "pre":
          case "section":
          case "summary":
          case "ul":
            // Ignore if there is not a matching open tag
            if (!stack.inScope(value)) return;
            stack.generateImpliedEndTags();
            stack.popTag(value);
            return;

          case "form":
            if (!stack.contains("template")) {
              var openform = form_element_pointer;
              form_element_pointer = null;
              if (!openform || !stack.elementInScope(openform)) return;
              stack.generateImpliedEndTags();
              stack.removeElement(openform);
            } else {
              if (!stack.inScope("form")) return;
              stack.generateImpliedEndTags();
              stack.popTag("form");
            }
            return;

          case "p":
            if (!stack.inButtonScope(value)) {
              in_body_mode(TAG, value, null);
              parser(t, value, arg3, arg4);
            } else {
              stack.generateImpliedEndTags(value);
              stack.popTag(value);
            }
            return;

          case "li":
            if (!stack.inListItemScope(value)) return;
            stack.generateImpliedEndTags(value);
            stack.popTag(value);
            return;

          case "dd":
          case "dt":
            if (!stack.inScope(value)) return;
            stack.generateImpliedEndTags(value);
            stack.popTag(value);
            return;

          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            if (!stack.elementTypeInScope(impl.HTMLHeadingElement)) return;
            stack.generateImpliedEndTags();
            stack.popElementType(impl.HTMLHeadingElement);
            return;

          case "sarcasm":
            // Take a deep breath, and then:
            break;

          case "a":
          case "b":
          case "big":
          case "code":
          case "em":
          case "font":
          case "i":
          case "nobr":
          case "s":
          case "small":
          case "strike":
          case "strong":
          case "tt":
          case "u":
            var result = adoptionAgency(value);
            if (result) return; // If we did something we're done
            break; // Go to the "any other end tag" case

          case "applet":
          case "marquee":
          case "object":
            if (!stack.inScope(value)) return;
            stack.generateImpliedEndTags();
            stack.popTag(value);
            afe.clearToMarker();
            return;

          case "br":
            in_body_mode(TAG, value, null); // Turn </br> into <br>
            return;
        }

        // Any other end tag goes here
        for (i = stack.elements.length - 1; i >= 0; i--) {
          node = stack.elements[i];
          if (isA(node, value)) {
            stack.generateImpliedEndTags(value);
            stack.popElement(node);
            break;
          } else if (isA(node, specialSet)) {
            return;
          }
        }

        return;
    }
  }

  function text_mode(t, value, arg3, arg4) {
    switch (t) {
      case 1:
        // TEXT
        insertText(value);
        return;
      case -1:
        // EOF
        if (stack.top instanceof impl.HTMLScriptElement) stack.top._already_started = true;
        stack.pop();
        parser = originalInsertionMode;
        parser(t);
        return;
      case 3:
        // ENDTAG
        if (value === "script") {
          handleScriptEnd();
        } else {
          stack.pop();
          parser = originalInsertionMode;
        }
        return;
      default:
        // We should never get any other token types
        return;
    }
  }

  function in_table_mode(t, value, arg3, arg4) {
    function getTypeAttr(attrs) {
      for (var i = 0, n = attrs.length; i < n; i++) {
        if (attrs[i][0] === "type") return attrs[i][1].toLowerCase();
      }
      return null;
    }

    switch (t) {
      case 1:
        // TEXT
        // XXX the text_integration_mode stuff is
        // just a hack I made up
        if (text_integration_mode) {
          in_body_mode(t, value, arg3, arg4);
          return;
        } else if (isA(stack.top, tablesectionrowSet)) {
          pending_table_text = [];
          originalInsertionMode = parser;
          parser = in_table_text_mode;
          parser(t, value, arg3, arg4);
          return;
        }
        break;
      case 4:
        // COMMENT
        insertComment(value);
        return;
      case 5:
        // DOCTYPE
        return;
      case 2:
        // TAG
        switch (value) {
          case "caption":
            stack.clearToContext(tableContextSet);
            afe.insertMarker();
            insertHTMLElement(value, arg3);
            parser = in_caption_mode;
            return;
          case "colgroup":
            stack.clearToContext(tableContextSet);
            insertHTMLElement(value, arg3);
            parser = in_column_group_mode;
            return;
          case "col":
            in_table_mode(TAG, "colgroup", null);
            parser(t, value, arg3, arg4);
            return;
          case "tbody":
          case "tfoot":
          case "thead":
            stack.clearToContext(tableContextSet);
            insertHTMLElement(value, arg3);
            parser = in_table_body_mode;
            return;
          case "td":
          case "th":
          case "tr":
            in_table_mode(TAG, "tbody", null);
            parser(t, value, arg3, arg4);
            return;

          case "table":
            if (!stack.inTableScope(value)) {
              return; // Ignore the token
            }
            in_table_mode(ENDTAG, value);
            parser(t, value, arg3, arg4);
            return;

          case "style":
          case "script":
          case "template":
            in_head_mode(t, value, arg3, arg4);
            return;

          case "input":
            var type = getTypeAttr(arg3);
            if (type !== "hidden") break; // to the anything else case
            insertHTMLElement(value, arg3);
            stack.pop();
            return;

          case "form":
            if (form_element_pointer || stack.contains("template")) return;
            form_element_pointer = insertHTMLElement(value, arg3);
            stack.popElement(form_element_pointer);
            return;
        }
        break;
      case 3:
        // ENDTAG
        switch (value) {
          case "table":
            if (!stack.inTableScope(value)) return;
            stack.popTag(value);
            resetInsertionMode();
            return;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return;
          case "template":
            in_head_mode(t, value, arg3, arg4);
            return;
        }

        break;
      case -1:
        // EOF
        in_body_mode(t, value, arg3, arg4);
        return;
    }

    // This is the anything else case
    foster_parent_mode = true;
    in_body_mode(t, value, arg3, arg4);
    foster_parent_mode = false;
  }

  function in_table_text_mode(t, value, arg3, arg4) {
    if (t === TEXT) {
      if (textIncludesNUL) {
        value = value.replace(NULCHARS, "");
        if (value.length === 0) return;
      }
      pending_table_text.push(value);
    } else {
      var s = pending_table_text.join("");
      pending_table_text.length = 0;
      if (NONWS.test(s)) {
        // If any non-whitespace characters
        // This must be the same code as the "anything else"
        // case of the in_table mode above.
        foster_parent_mode = true;
        in_body_mode(TEXT, s);
        foster_parent_mode = false;
      } else {
        insertText(s);
      }
      parser = originalInsertionMode;
      parser(t, value, arg3, arg4);
    }
  }

  function in_caption_mode(t, value, arg3, arg4) {
    function end_caption() {
      if (!stack.inTableScope("caption")) return false;
      stack.generateImpliedEndTags();
      stack.popTag("caption");
      afe.clearToMarker();
      parser = in_table_mode;
      return true;
    }

    switch (t) {
      case 2:
        // TAG
        switch (value) {
          case "caption":
          case "col":
          case "colgroup":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            if (end_caption()) parser(t, value, arg3, arg4);
            return;
        }
        break;
      case 3:
        // ENDTAG
        switch (value) {
          case "caption":
            end_caption();
            return;
          case "table":
            if (end_caption()) parser(t, value, arg3, arg4);
            return;
          case "body":
          case "col":
          case "colgroup":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return;
        }
        break;
    }

    // The Anything Else case
    in_body_mode(t, value, arg3, arg4);
  }

  function in_column_group_mode(t, value, arg3, arg4) {
    switch (t) {
      case 1:
        // TEXT
        var ws = value.match(LEADINGWS);
        if (ws) {
          insertText(ws[0]);
          value = value.substring(ws[0].length);
        }
        if (value.length === 0) return;
        break; // Handle non-whitespace below

      case 4:
        // COMMENT
        insertComment(value);
        return;
      case 5:
        // DOCTYPE
        return;
      case 2:
        // TAG
        switch (value) {
          case "html":
            in_body_mode(t, value, arg3, arg4);
            return;
          case "col":
            insertHTMLElement(value, arg3);
            stack.pop();
            return;
          case "template":
            in_head_mode(t, value, arg3, arg4);
            return;
        }
        break;
      case 3:
        // ENDTAG
        switch (value) {
          case "colgroup":
            if (!isA(stack.top, 'colgroup')) {
              return; // Ignore the token.
            }
            stack.pop();
            parser = in_table_mode;
            return;
          case "col":
            return;
          case "template":
            in_head_mode(t, value, arg3, arg4);
            return;
        }
        break;
      case -1:
        // EOF
        in_body_mode(t, value, arg3, arg4);
        return;
    }

    // Anything else
    if (!isA(stack.top, 'colgroup')) {
      return; // Ignore the token.
    }
    in_column_group_mode(ENDTAG, "colgroup");
    parser(t, value, arg3, arg4);
  }

  function in_table_body_mode(t, value, arg3, arg4) {
    function endsect() {
      if (!stack.inTableScope("tbody") && !stack.inTableScope("thead") && !stack.inTableScope("tfoot")) return;
      stack.clearToContext(tableBodyContextSet);
      in_table_body_mode(ENDTAG, stack.top.localName, null);
      parser(t, value, arg3, arg4);
    }

    switch (t) {
      case 2:
        // TAG
        switch (value) {
          case "tr":
            stack.clearToContext(tableBodyContextSet);
            insertHTMLElement(value, arg3);
            parser = in_row_mode;
            return;
          case "th":
          case "td":
            in_table_body_mode(TAG, "tr", null);
            parser(t, value, arg3, arg4);
            return;
          case "caption":
          case "col":
          case "colgroup":
          case "tbody":
          case "tfoot":
          case "thead":
            endsect();
            return;
        }
        break;
      case 3:
        // ENDTAG
        switch (value) {
          case "table":
            endsect();
            return;
          case "tbody":
          case "tfoot":
          case "thead":
            if (stack.inTableScope(value)) {
              stack.clearToContext(tableBodyContextSet);
              stack.pop();
              parser = in_table_mode;
            }
            return;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "html":
          case "td":
          case "th":
          case "tr":
            return;
        }
        break;
    }

    // Anything else:
    in_table_mode(t, value, arg3, arg4);
  }

  function in_row_mode(t, value, arg3, arg4) {
    function endrow() {
      if (!stack.inTableScope("tr")) return false;
      stack.clearToContext(tableRowContextSet);
      stack.pop();
      parser = in_table_body_mode;
      return true;
    }

    switch (t) {
      case 2:
        // TAG
        switch (value) {
          case "th":
          case "td":
            stack.clearToContext(tableRowContextSet);
            insertHTMLElement(value, arg3);
            parser = in_cell_mode;
            afe.insertMarker();
            return;
          case "caption":
          case "col":
          case "colgroup":
          case "tbody":
          case "tfoot":
          case "thead":
          case "tr":
            if (endrow()) parser(t, value, arg3, arg4);
            return;
        }
        break;
      case 3:
        // ENDTAG
        switch (value) {
          case "tr":
            endrow();
            return;
          case "table":
            if (endrow()) parser(t, value, arg3, arg4);
            return;
          case "tbody":
          case "tfoot":
          case "thead":
            if (stack.inTableScope(value)) {
              if (endrow()) parser(t, value, arg3, arg4);
            }
            return;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "html":
          case "td":
          case "th":
            return;
        }
        break;
    }

    // anything else
    in_table_mode(t, value, arg3, arg4);
  }

  function in_cell_mode(t, value, arg3, arg4) {
    switch (t) {
      case 2:
        // TAG
        switch (value) {
          case "caption":
          case "col":
          case "colgroup":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            if (stack.inTableScope("td")) {
              in_cell_mode(ENDTAG, "td");
              parser(t, value, arg3, arg4);
            } else if (stack.inTableScope("th")) {
              in_cell_mode(ENDTAG, "th");
              parser(t, value, arg3, arg4);
            }
            return;
        }
        break;
      case 3:
        // ENDTAG
        switch (value) {
          case "td":
          case "th":
            if (!stack.inTableScope(value)) return;
            stack.generateImpliedEndTags();
            stack.popTag(value);
            afe.clearToMarker();
            parser = in_row_mode;
            return;

          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "html":
            return;

          case "table":
          case "tbody":
          case "tfoot":
          case "thead":
          case "tr":
            if (!stack.inTableScope(value)) return;
            in_cell_mode(ENDTAG, stack.inTableScope("td") ? "td" : "th");
            parser(t, value, arg3, arg4);
            return;
        }
        break;
    }

    // anything else
    in_body_mode(t, value, arg3, arg4);
  }

  function in_select_mode(t, value, arg3, arg4) {
    switch (t) {
      case 1:
        // TEXT
        if (textIncludesNUL) {
          value = value.replace(NULCHARS, "");
          if (value.length === 0) return;
        }
        insertText(value);
        return;
      case 4:
        // COMMENT
        insertComment(value);
        return;
      case 5:
        // DOCTYPE
        return;
      case -1:
        // EOF
        in_body_mode(t, value, arg3, arg4);
        return;
      case 2:
        // TAG
        switch (value) {
          case "html":
            in_body_mode(t, value, arg3, arg4);
            return;
          case "option":
            if (stack.top instanceof impl.HTMLOptionElement) in_select_mode(ENDTAG, value);
            insertHTMLElement(value, arg3);
            return;
          case "optgroup":
            if (stack.top instanceof impl.HTMLOptionElement) in_select_mode(ENDTAG, "option");
            if (stack.top instanceof impl.HTMLOptGroupElement) in_select_mode(ENDTAG, value);
            insertHTMLElement(value, arg3);
            return;
          case "select":
            in_select_mode(ENDTAG, value); // treat it as a close tag
            return;

          case "input":
          case "keygen":
          case "textarea":
            if (!stack.inSelectScope("select")) return;
            in_select_mode(ENDTAG, "select");
            parser(t, value, arg3, arg4);
            return;

          case "script":
          case "template":
            in_head_mode(t, value, arg3, arg4);
            return;
        }
        break;
      case 3:
        // ENDTAG
        switch (value) {
          case "optgroup":
            if (stack.top instanceof impl.HTMLOptionElement && stack.elements[stack.elements.length - 2] instanceof impl.HTMLOptGroupElement) {
              in_select_mode(ENDTAG, "option");
            }
            if (stack.top instanceof impl.HTMLOptGroupElement) stack.pop();

            return;

          case "option":
            if (stack.top instanceof impl.HTMLOptionElement) stack.pop();
            return;

          case "select":
            if (!stack.inSelectScope(value)) return;
            stack.popTag(value);
            resetInsertionMode();
            return;

          case "template":
            in_head_mode(t, value, arg3, arg4);
            return;
        }

        break;
    }

    // anything else: just ignore the token
  }

  function in_select_in_table_mode(t, value, arg3, arg4) {
    switch (value) {
      case "caption":
      case "table":
      case "tbody":
      case "tfoot":
      case "thead":
      case "tr":
      case "td":
      case "th":
        switch (t) {
          case 2:
            // TAG
            in_select_in_table_mode(ENDTAG, "select");
            parser(t, value, arg3, arg4);
            return;
          case 3:
            // ENDTAG
            if (stack.inTableScope(value)) {
              in_select_in_table_mode(ENDTAG, "select");
              parser(t, value, arg3, arg4);
            }
            return;
        }
    }

    // anything else
    in_select_mode(t, value, arg3, arg4);
  }

  function in_template_mode(t, value, arg3, arg4) {
    function switchModeAndReprocess(mode) {
      parser = mode;
      templateInsertionModes[templateInsertionModes.length - 1] = parser;
      parser(t, value, arg3, arg4);
    }
    switch (t) {
      case 1: // TEXT
      case 4: // COMMENT
      case 5:
        // DOCTYPE
        in_body_mode(t, value, arg3, arg4);
        return;
      case -1:
        // EOF
        if (!stack.contains("template")) {
          stopParsing();
        } else {
          stack.popTag("template");
          afe.clearToMarker();
          templateInsertionModes.pop();
          resetInsertionMode();
          parser(t, value, arg3, arg4);
        }
        return;
      case 2:
        // TAG
        switch (value) {
          case "base":
          case "basefont":
          case "bgsound":
          case "link":
          case "meta":
          case "noframes":
          case "script":
          case "style":
          case "template":
          case "title":
            in_head_mode(t, value, arg3, arg4);
            return;
          case "caption":
          case "colgroup":
          case "tbody":
          case "tfoot":
          case "thead":
            switchModeAndReprocess(in_table_mode);
            return;
          case "col":
            switchModeAndReprocess(in_column_group_mode);
            return;
          case "tr":
            switchModeAndReprocess(in_table_body_mode);
            return;
          case "td":
          case "th":
            switchModeAndReprocess(in_row_mode);
            return;
        }
        switchModeAndReprocess(in_body_mode);
        return;
      case 3:
        // ENDTAG
        switch (value) {
          case "template":
            in_head_mode(t, value, arg3, arg4);
            return;
          default:
            return;
        }
    }
  }

  function after_body_mode(t, value, arg3, arg4) {
    switch (t) {
      case 1:
        // TEXT
        // If any non-space chars, handle below
        if (NONWS.test(value)) break;
        in_body_mode(t, value);
        return;
      case 4:
        // COMMENT
        // Append it to the <html> element
        stack.elements[0]._appendChild(doc.createComment(value));
        return;
      case 5:
        // DOCTYPE
        return;
      case -1:
        // EOF
        stopParsing();
        return;
      case 2:
        // TAG
        if (value === "html") {
          in_body_mode(t, value, arg3, arg4);
          return;
        }
        break; // for any other tags
      case 3:
        // ENDTAG
        if (value === "html") {
          if (fragment) return;
          parser = after_after_body_mode;
          return;
        }
        break; // for any other tags
    }

    // anything else
    parser = in_body_mode;
    parser(t, value, arg3, arg4);
  }

  function in_frameset_mode(t, value, arg3, arg4) {
    switch (t) {
      case 1:
        // TEXT
        // Ignore any non-space characters
        value = value.replace(ALLNONWS, "");
        if (value.length > 0) insertText(value);
        return;
      case 4:
        // COMMENT
        insertComment(value);
        return;
      case 5:
        // DOCTYPE
        return;
      case -1:
        // EOF
        stopParsing();
        return;
      case 2:
        // TAG
        switch (value) {
          case "html":
            in_body_mode(t, value, arg3, arg4);
            return;
          case "frameset":
            insertHTMLElement(value, arg3);
            return;
          case "frame":
            insertHTMLElement(value, arg3);
            stack.pop();
            return;
          case "noframes":
            in_head_mode(t, value, arg3, arg4);
            return;
        }
        break;
      case 3:
        // ENDTAG
        if (value === "frameset") {
          if (fragment && stack.top instanceof impl.HTMLHtmlElement) return;
          stack.pop();
          if (!fragment && !(stack.top instanceof impl.HTMLFrameSetElement)) parser = after_frameset_mode;
          return;
        }
        break;
    }

    // ignore anything else
  }

  function after_frameset_mode(t, value, arg3, arg4) {
    switch (t) {
      case 1:
        // TEXT
        // Ignore any non-space characters
        value = value.replace(ALLNONWS, "");
        if (value.length > 0) insertText(value);
        return;
      case 4:
        // COMMENT
        insertComment(value);
        return;
      case 5:
        // DOCTYPE
        return;
      case -1:
        // EOF
        stopParsing();
        return;
      case 2:
        // TAG
        switch (value) {
          case "html":
            in_body_mode(t, value, arg3, arg4);
            return;
          case "noframes":
            in_head_mode(t, value, arg3, arg4);
            return;
        }
        break;
      case 3:
        // ENDTAG
        if (value === "html") {
          parser = after_after_frameset_mode;
          return;
        }
        break;
    }

    // ignore anything else
  }

  function after_after_body_mode(t, value, arg3, arg4) {
    switch (t) {
      case 1:
        // TEXT
        // If any non-space chars, handle below
        if (NONWS.test(value)) break;
        in_body_mode(t, value, arg3, arg4);
        return;
      case 4:
        // COMMENT
        doc._appendChild(doc.createComment(value));
        return;
      case 5:
        // DOCTYPE
        in_body_mode(t, value, arg3, arg4);
        return;
      case -1:
        // EOF
        stopParsing();
        return;
      case 2:
        // TAG
        if (value === "html") {
          in_body_mode(t, value, arg3, arg4);
          return;
        }
        break;
    }

    // anything else
    parser = in_body_mode;
    parser(t, value, arg3, arg4);
  }

  function after_after_frameset_mode(t, value, arg3, arg4) {
    switch (t) {
      case 1:
        // TEXT
        // Ignore any non-space characters
        value = value.replace(ALLNONWS, "");
        if (value.length > 0) in_body_mode(t, value, arg3, arg4);
        return;
      case 4:
        // COMMENT
        doc._appendChild(doc.createComment(value));
        return;
      case 5:
        // DOCTYPE
        in_body_mode(t, value, arg3, arg4);
        return;
      case -1:
        // EOF
        stopParsing();
        return;
      case 2:
        // TAG
        switch (value) {
          case "html":
            in_body_mode(t, value, arg3, arg4);
            return;
          case "noframes":
            in_head_mode(t, value, arg3, arg4);
            return;
        }
        break;
    }

    // ignore anything else
  }

  // 13.2.5.5 The rules for parsing tokens in foreign content
  //
  // This is like one of the insertion modes above, but is
  // invoked somewhat differently when the current token is not HTML.
  // See the insertToken() function.
  function insertForeignToken(t, value, arg3, arg4) {
    // A <font> tag is an HTML font tag if it has a color, font, or size
    // attribute.  Otherwise we assume it is foreign content
    function isHTMLFont(attrs) {
      for (var i = 0, n = attrs.length; i < n; i++) {
        switch (attrs[i][0]) {
          case "color":
          case "face":
          case "size":
            return true;
        }
      }
      return false;
    }

    var current;

    switch (t) {
      case 1:
        // TEXT
        // If any non-space, non-nul characters
        if (frameset_ok && NONWSNONNUL.test(value)) frameset_ok = false;
        if (textIncludesNUL) {
          value = value.replace(NULCHARS, '\uFFFD');
        }
        insertText(value);
        return;
      case 4:
        // COMMENT
        insertComment(value);
        return;
      case 5:
        // DOCTYPE
        // ignore it
        return;
      case 2:
        // TAG
        switch (value) {
          case "font":
            if (!isHTMLFont(arg3)) break;
          /* falls through */
          case "b":
          case "big":
          case "blockquote":
          case "body":
          case "br":
          case "center":
          case "code":
          case "dd":
          case "div":
          case "dl":
          case "dt":
          case "em":
          case "embed":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
          case "head":
          case "hr":
          case "i":
          case "img":
          case "li":
          case "listing":
          case "menu":
          case "meta":
          case "nobr":
          case "ol":
          case "p":
          case "pre":
          case "ruby":
          case "s":
          case "small":
          case "span":
          case "strong":
          case "strike":
          case "sub":
          case "sup":
          case "table":
          case "tt":
          case "u":
          case "ul":
          case "var":
            if (fragment) {
              break;
            }
            do {
              stack.pop();
              current = stack.top;
            } while (current.namespaceURI !== NAMESPACE.HTML && !isMathmlTextIntegrationPoint(current) && !isHTMLIntegrationPoint(current));

            insertToken(t, value, arg3, arg4); // reprocess
            return;
        }

        // Any other start tag case goes here
        current = stack.elements.length === 1 && fragment ? fragmentContext : stack.top;
        if (current.namespaceURI === NAMESPACE.MATHML) {
          adjustMathMLAttributes(arg3);
        } else if (current.namespaceURI === NAMESPACE.SVG) {
          value = adjustSVGTagName(value);
          adjustSVGAttributes(arg3);
        }
        adjustForeignAttributes(arg3);

        insertForeignElement(value, arg3, current.namespaceURI);
        if (arg4) {
          // the self-closing flag
          if (value === 'script' && current.namespaceURI === NAMESPACE.SVG) {
            // XXX deal with SVG scripts here
          }
          stack.pop();
        }
        return;

      case 3:
        // ENDTAG
        current = stack.top;
        if (value === "script" && current.namespaceURI === NAMESPACE.SVG && current.localName === "script") {

          stack.pop();

          // XXX
          // Deal with SVG scripts here
        } else {
          // The any other end tag case
          var i = stack.elements.length - 1;
          var node = stack.elements[i];
          for (;;) {
            if (node.localName.toLowerCase() === value) {
              stack.popElement(node);
              break;
            }
            node = stack.elements[--i];
            // If non-html, keep looping
            if (node.namespaceURI !== NAMESPACE.HTML) continue;
            // Otherwise process the end tag as html
            parser(t, value, arg3, arg4);
            break;
          }
        }
        return;
    }
  }

  /***
   * Finally, this is the end of the HTMLParser() factory function.
   * It returns the htmlparser object with the append() and end() methods.
   */

  // Sneak another method into the htmlparser object to allow us to run
  // tokenizer tests.  This can be commented out in production code.
  // This is a hook for testing the tokenizer. It has to be here
  // because the tokenizer details are all hidden away within the closure.
  // It should return an array of tokens generated while parsing the
  // input string.
  htmlparser.testTokenizer = function (input, initialState, lastStartTag, charbychar) {
    var tokens = [];

    switch (initialState) {
      case "PCDATA state":
        tokenizer = data_state;
        break;
      case "RCDATA state":
        tokenizer = rcdata_state;
        break;
      case "RAWTEXT state":
        tokenizer = rawtext_state;
        break;
      case "PLAINTEXT state":
        tokenizer = plaintext_state;
        break;
    }

    if (lastStartTag) {
      lasttagname = lastStartTag;
    }

    insertToken = function insertToken(t, value, arg3, arg4) {
      flushText();
      switch (t) {
        case 1:
          // TEXT
          if (tokens.length > 0 && tokens[tokens.length - 1][0] === "Character") {
            tokens[tokens.length - 1][1] += value;
          } else tokens.push(["Character", value]);
          break;
        case 4:
          // COMMENT
          tokens.push(["Comment", value]);
          break;
        case 5:
          // DOCTYPE
          tokens.push(["DOCTYPE", value, arg3 === undefined ? null : arg3, arg4 === undefined ? null : arg4, !force_quirks]);
          break;
        case 2:
          // TAG
          var attrs = Object.create(null);
          for (var i = 0; i < arg3.length; i++) {
            // XXX: does attribute order matter?
            var a = arg3[i];
            if (a.length === 1) {
              attrs[a[0]] = "";
            } else {
              attrs[a[0]] = a[1];
            }
          }
          var token = ["StartTag", value, attrs];
          if (arg4) token.push(true);
          tokens.push(token);
          break;
        case 3:
          // ENDTAG
          tokens.push(["EndTag", value]);
          break;
        case -1:
          // EOF
          break;
      }
    };

    if (!charbychar) {
      this.parse(input, true);
    } else {
      for (var i = 0; i < input.length; i++) {
        this.parse(input[i]);
      }
      this.parse("", true);
    }
    return tokens;
  };

  // Return the parser object from the HTMLParser() factory function
  return htmlparser;
}

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(98);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(261)
)

/* script */
__vue_exports__ = __webpack_require__(262)

/* template */
var __vue_template__ = __webpack_require__(263)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-rich-text\\wxc-rich-text-text.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-7cb75ac2"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(347)
)

/* script */
__vue_exports__ = __webpack_require__(348)

/* template */
var __vue_template__ = __webpack_require__(355)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\src\\reposList.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-37f3bd69"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Event = __webpack_require__(8);
var MouseEvent = __webpack_require__(33);
var utils = __webpack_require__(1);

module.exports = EventTarget;

function EventTarget() {}

EventTarget.prototype = {
  // XXX
  // See WebIDL §4.8 for details on object event handlers
  // and how they should behave.  We actually have to accept
  // any object to addEventListener... Can't type check it.
  // on registration.

  // XXX:
  // Capturing event listeners are sort of rare.  I think I can optimize
  // them so that dispatchEvent can skip the capturing phase (or much of
  // it).  Each time a capturing listener is added, increment a flag on
  // the target node and each of its ancestors.  Decrement when removed.
  // And update the counter when nodes are added and removed from the
  // tree as well.  Then, in dispatch event, the capturing phase can
  // abort if it sees any node with a zero count.
  addEventListener: function addEventListener(type, listener, capture) {
    if (!listener) return;
    if (capture === undefined) capture = false;
    if (!this._listeners) this._listeners = Object.create(null);
    if (!this._listeners[type]) this._listeners[type] = [];
    var list = this._listeners[type];

    // If this listener has already been registered, just return
    for (var i = 0, n = list.length; i < n; i++) {
      var l = list[i];
      if (l.listener === listener && l.capture === capture) return;
    }

    // Add an object to the list of listeners
    var obj = { listener: listener, capture: capture };
    if (typeof listener === 'function') obj.f = listener;
    list.push(obj);
  },

  removeEventListener: function removeEventListener(type, listener, capture) {
    if (capture === undefined) capture = false;
    if (this._listeners) {
      var list = this._listeners[type];
      if (list) {
        // Find the listener in the list and remove it
        for (var i = 0, n = list.length; i < n; i++) {
          var l = list[i];
          if (l.listener === listener && l.capture === capture) {
            if (list.length === 1) {
              this._listeners[type] = undefined;
            } else {
              list.splice(i, 1);
            }
            return;
          }
        }
      }
    }
  },

  // This is the public API for dispatching untrusted public events.
  // See _dispatchEvent for the implementation
  dispatchEvent: function dispatchEvent(event) {
    // Dispatch an untrusted event
    return this._dispatchEvent(event, false);
  },

  //
  // See DOMCore §4.4
  // XXX: I'll probably need another version of this method for
  // internal use, one that does not set isTrusted to false.
  // XXX: see Document._dispatchEvent: perhaps that and this could
  // call a common internal function with different settings of
  // a trusted boolean argument
  //
  // XXX:
  // The spec has changed in how to deal with handlers registered
  // on idl or content attributes rather than with addEventListener.
  // Used to say that they always ran first.  That's how webkit does it
  // Spec now says that they run in a position determined by
  // when they were first set.  FF does it that way.  See:
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#event-handlers
  //
  _dispatchEvent: function _dispatchEvent(event, trusted) {
    if (typeof trusted !== 'boolean') trusted = false;
    function invoke(target, event) {
      var type = event.type,
          phase = event.eventPhase;
      event.currentTarget = target;

      // If there was an individual handler defined, invoke it first
      // XXX: see comment above: this shouldn't always be first.
      if (phase !== Event.CAPTURING_PHASE && target._handlers && target._handlers[type]) {
        var handler = target._handlers[type];
        var rv;
        if (typeof handler === 'function') {
          rv = handler.call(event.currentTarget, event);
        } else {
          var f = handler.handleEvent;
          if (typeof f !== 'function') throw new TypeError('handleEvent property of ' + 'event handler object is' + 'not a function.');
          rv = f.call(handler, event);
        }

        switch (event.type) {
          case 'mouseover':
            if (rv === true) // Historical baggage
              event.preventDefault();
            break;
          case 'beforeunload':
          // XXX: eventually we need a special case here
          /* falls through */
          default:
            if (rv === false) event.preventDefault();
            break;
        }
      }

      // Now invoke list list of listeners for this target and type
      var list = target._listeners && target._listeners[type];
      if (!list) return;
      list = list.slice();
      for (var i = 0, n = list.length; i < n; i++) {
        if (event._immediatePropagationStopped) return;
        var l = list[i];
        if (phase === Event.CAPTURING_PHASE && !l.capture || phase === Event.BUBBLING_PHASE && l.capture) continue;
        if (l.f) {
          l.f.call(event.currentTarget, event);
        } else {
          var fn = l.listener.handleEvent;
          if (typeof fn !== 'function') throw new TypeError('handleEvent property of event listener object is not a function.');
          fn.call(l.listener, event);
        }
      }
    }

    if (!event._initialized || event._dispatching) utils.InvalidStateError();
    event.isTrusted = trusted;

    // Begin dispatching the event now
    event._dispatching = true;
    event.target = this;

    // Build the list of targets for the capturing and bubbling phases
    // XXX: we'll eventually have to add Window to this list.
    var ancestors = [];
    for (var n = this.parentNode; n; n = n.parentNode) {
      ancestors.push(n);
    } // Capturing phase
    event.eventPhase = Event.CAPTURING_PHASE;
    for (var i = ancestors.length - 1; i >= 0; i--) {
      invoke(ancestors[i], event);
      if (event._propagationStopped) break;
    }

    // At target phase
    if (!event._propagationStopped) {
      event.eventPhase = Event.AT_TARGET;
      invoke(this, event);
    }

    // Bubbling phase
    if (event.bubbles && !event._propagationStopped) {
      event.eventPhase = Event.BUBBLING_PHASE;
      for (var ii = 0, nn = ancestors.length; ii < nn; ii++) {
        invoke(ancestors[ii], event);
        if (event._propagationStopped) break;
      }
    }

    event._dispatching = false;
    event.eventPhase = Event.AT_TARGET;
    event.currentTarget = null;

    // Deal with mouse events and figure out when
    // a click has happened
    if (trusted && !event.defaultPrevented && event instanceof MouseEvent) {
      switch (event.type) {
        case 'mousedown':
          this._armed = {
            x: event.clientX,
            y: event.clientY,
            t: event.timeStamp
          };
          break;
        case 'mouseout':
        case 'mouseover':
          this._armed = null;
          break;
        case 'mouseup':
          if (this._isClick(event)) this._doClick(event);
          this._armed = null;
          break;
      }
    }

    return !event.defaultPrevented;
  },

  // Determine whether a click occurred
  // XXX We don't support double clicks for now
  _isClick: function _isClick(event) {
    return this._armed !== null && event.type === 'mouseup' && event.isTrusted && event.button === 0 && event.timeStamp - this._armed.t < 1000 && Math.abs(event.clientX - this._armed.x) < 10 && Math.abs(event.clientY - this._armed.Y) < 10;
  },

  // Clicks are handled like this:
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#interactive-content-0
  //
  // Note that this method is similar to the HTMLElement.click() method
  // The event argument must be the trusted mouseup event
  _doClick: function _doClick(event) {
    if (this._click_in_progress) return;
    this._click_in_progress = true;

    // Find the nearest enclosing element that is activatable
    // An element is activatable if it has a
    // _post_click_activation_steps hook
    var activated = this;
    while (activated && !activated._post_click_activation_steps) {
      activated = activated.parentNode;
    }if (activated && activated._pre_click_activation_steps) {
      activated._pre_click_activation_steps();
    }

    var click = this.ownerDocument.createEvent('MouseEvent');
    click.initMouseEvent('click', true, true, this.ownerDocument.defaultView, 1, event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button, null);

    var result = this._dispatchEvent(click, true);

    if (activated) {
      if (result) {
        // This is where hyperlinks get followed, for example.
        if (activated._post_click_activation_steps) activated._post_click_activation_steps(click);
      } else {
        if (activated._cancelled_activation_steps) activated._cancelled_activation_steps();
      }
    }
  },

  //
  // An event handler is like an event listener, but it registered
  // by setting an IDL or content attribute like onload or onclick.
  // There can only be one of these at a time for any event type.
  // This is an internal method for the attribute accessors and
  // content attribute handlers that need to register events handlers.
  // The type argument is the same as in addEventListener().
  // The handler argument is the same as listeners in addEventListener:
  // it can be a function or an object. Pass null to remove any existing
  // handler.  Handlers are always invoked before any listeners of
  // the same type.  They are not invoked during the capturing phase
  // of event dispatch.
  //
  _setEventHandler: function _setEventHandler(type, handler) {
    if (!this._handlers) this._handlers = Object.create(null);
    this._handlers[type] = handler;
  },

  _getEventHandler: function _getEventHandler(type) {
    return this._handlers && this._handlers[type] || null;
  }

};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var UIEvent = __webpack_require__(34);

module.exports = MouseEvent;

function MouseEvent() {
  // Just use the superclass constructor to initialize
  UIEvent.call(this);

  this.screenX = this.screenY = this.clientX = this.clientY = 0;
  this.ctrlKey = this.altKey = this.shiftKey = this.metaKey = false;
  this.button = 0;
  this.buttons = 1;
  this.relatedTarget = null;
}
MouseEvent.prototype = Object.create(UIEvent.prototype, {
  constructor: { value: MouseEvent },
  initMouseEvent: { value: function value(type, bubbles, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) {

      this.initEvent(type, bubbles, cancelable, view, detail);
      this.screenX = screenX;
      this.screenY = screenY;
      this.clientX = clientX;
      this.clientY = clientY;
      this.ctrlKey = ctrlKey;
      this.altKey = altKey;
      this.shiftKey = shiftKey;
      this.metaKey = metaKey;
      this.button = button;
      switch (button) {
        case 0:
          this.buttons = 1;break;
        case 1:
          this.buttons = 4;break;
        case 2:
          this.buttons = 2;break;
        default:
          this.buttons = 0;break;
      }
      this.relatedTarget = relatedTarget;
    } },

  getModifierState: { value: function value(key) {
      switch (key) {
        case "Alt":
          return this.altKey;
        case "Control":
          return this.ctrlKey;
        case "Shift":
          return this.shiftKey;
        case "Meta":
          return this.metaKey;
        default:
          return false;
      }
    } }
});

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Event = __webpack_require__(8);

module.exports = UIEvent;

function UIEvent() {
  // Just use the superclass constructor to initialize
  Event.call(this);
  this.view = null; // FF uses the current window
  this.detail = 0;
}
UIEvent.prototype = Object.create(Event.prototype, {
  constructor: { value: UIEvent },
  initUIEvent: { value: function value(type, bubbles, cancelable, view, detail) {
      this.initEvent(type, bubbles, cancelable);
      this.view = view;
      this.detail = detail;
    } }
});

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(1);

var LinkedList = module.exports = {
    // basic validity tests on a circular linked list a
    valid: function valid(a) {
        utils.assert(a, "list falsy");
        utils.assert(a._previousSibling, "previous falsy");
        utils.assert(a._nextSibling, "next falsy");
        // xxx check that list is actually circular
        return true;
    },
    // insert a before b
    insertBefore: function insertBefore(a, b) {
        utils.assert(LinkedList.valid(a) && LinkedList.valid(b));
        var a_first = a,
            a_last = a._previousSibling;
        var b_first = b,
            b_last = b._previousSibling;
        a_first._previousSibling = b_last;
        a_last._nextSibling = b_first;
        b_last._nextSibling = a_first;
        b_first._previousSibling = a_last;
        utils.assert(LinkedList.valid(a) && LinkedList.valid(b));
    },
    // replace a single node a with a list b (which could be null)
    replace: function replace(a, b) {
        utils.assert(LinkedList.valid(a) && (b === null || LinkedList.valid(b)));
        if (b !== null) {
            LinkedList.insertBefore(b, a);
        }
        LinkedList.remove(a);
        utils.assert(LinkedList.valid(a) && (b === null || LinkedList.valid(b)));
    },
    // remove single node a from its list
    remove: function remove(a) {
        utils.assert(LinkedList.valid(a));
        var prev = a._previousSibling;
        if (prev === a) {
            return;
        }
        var next = a._nextSibling;
        prev._nextSibling = next;
        next._previousSibling = prev;
        a._previousSibling = a._nextSibling = a;
        utils.assert(LinkedList.valid(a));
    }
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  // NOTE: The `serializeOne()` function used to live on the `Node.prototype`
  // as a private method `Node#_serializeOne(child)`, however that requires
  // a megamorphic property access `this._serializeOne` just to get to the
  // method, and this is being done on lots of different `Node` subclasses,
  // which puts a lot of pressure on V8's megamorphic stub cache. So by
  // moving the helper off of the `Node.prototype` and into a separate
  // function in this helper module, we get a monomorphic property access
  // `NodeUtils.serializeOne` to get to the function and reduce pressure
  // on the megamorphic stub cache.
  // See https://github.com/fgnass/domino/pull/142 for more information.
  serializeOne: serializeOne
};

var utils = __webpack_require__(1);
var NAMESPACE = utils.NAMESPACE;

var hasRawContent = {
  STYLE: true,
  SCRIPT: true,
  XMP: true,
  IFRAME: true,
  NOEMBED: true,
  NOFRAMES: true,
  PLAINTEXT: true
};

var emptyElements = {
  area: true,
  base: true,
  basefont: true,
  bgsound: true,
  br: true,
  col: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

var extraNewLine = {
  /* Removed in https://github.com/whatwg/html/issues/944
  pre: true,
  textarea: true,
  listing: true
  */
};

function escape(s) {
  return s.replace(/[&<>\u00A0]/g, function (c) {
    switch (c) {
      case '&':
        return '&amp;';
      case '<':
        return '&lt;';
      case '>':
        return '&gt;';
      case '\xA0':
        return '&nbsp;';
    }
  });
}

function escapeAttr(s) {
  var toEscape = /[&"\u00A0]/g;
  if (!toEscape.test(s)) {
    // nothing to do, fast path
    return s;
  } else {
    return s.replace(toEscape, function (c) {
      switch (c) {
        case '&':
          return '&amp;';
        case '"':
          return '&quot;';
        case '\xA0':
          return '&nbsp;';
      }
    });
  }
}

function attrname(a) {
  var ns = a.namespaceURI;
  if (!ns) return a.localName;
  if (ns === NAMESPACE.XML) return 'xml:' + a.localName;
  if (ns === NAMESPACE.XLINK) return 'xlink:' + a.localName;

  if (ns === NAMESPACE.XMLNS) {
    if (a.localName === 'xmlns') return 'xmlns';else return 'xmlns:' + a.localName;
  }
  return a.name;
}

function serializeOne(kid, parent) {
  var s = '';
  switch (kid.nodeType) {
    case 1:
      //ELEMENT_NODE
      var ns = kid.namespaceURI;
      var html = ns === NAMESPACE.HTML;
      var tagname = html || ns === NAMESPACE.SVG || ns === NAMESPACE.MATHML ? kid.localName : kid.tagName;

      s += '<' + tagname;

      for (var j = 0, k = kid._numattrs; j < k; j++) {
        var a = kid._attr(j);
        s += ' ' + attrname(a);
        if (a.value !== undefined) s += '="' + escapeAttr(a.value) + '"';
      }
      s += '>';

      if (!(html && emptyElements[tagname])) {
        var ss = kid.serialize();
        if (html && extraNewLine[tagname] && ss.charAt(0) === '\n') s += '\n';
        // Serialize children and add end tag for all others
        s += ss;
        s += '</' + tagname + '>';
      }
      break;
    case 3: //TEXT_NODE
    case 4:
      //CDATA_SECTION_NODE
      var parenttag;
      if (parent.nodeType === 1 /*ELEMENT_NODE*/ && parent.namespaceURI === NAMESPACE.HTML) parenttag = parent.tagName;else parenttag = '';

      if (hasRawContent[parenttag] || parenttag === 'NOSCRIPT' && parent.ownerDocument._scripting_enabled) {
        s += kid.data;
      } else {
        s += escape(kid.data);
      }
      break;
    case 8:
      //COMMENT_NODE
      s += '<!--' + kid.data + '-->';
      break;
    case 7:
      //PROCESSING_INSTRUCTION_NODE
      s += '<?' + kid.target + ' ' + kid.data + '?>';
      break;
    case 10:
      //DOCUMENT_TYPE_NODE
      s += '<!DOCTYPE ' + kid.name;

      if (false) {
        // Latest HTML serialization spec omits the public/system ID
        if (kid.publicID) {
          s += ' PUBLIC "' + kid.publicId + '"';
        }

        if (kid.systemId) {
          s += ' "' + kid.systemId + '"';
        }
      }

      s += '>';
      break;
    default:
      utils.InvalidStateError();
  }
  return s;
}

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var utils = __webpack_require__(1);

exports.property = function (attr) {
  if (Array.isArray(attr.type)) {
    var valid = Object.create(null);
    attr.type.forEach(function (val) {
      valid[val.value || val] = val.alias || val;
    });
    var missingValueDefault = attr.missing;
    if (missingValueDefault === undefined) {
      missingValueDefault = null;
    }
    var invalidValueDefault = attr.invalid;
    if (invalidValueDefault === undefined) {
      invalidValueDefault = missingValueDefault;
    }
    return {
      get: function get() {
        var v = this._getattr(attr.name);
        if (v === null) return missingValueDefault;

        v = valid[v.toLowerCase()];
        if (v !== undefined) return v;
        if (invalidValueDefault !== null) return invalidValueDefault;
        return v;
      },
      set: function set(v) {
        this._setattr(attr.name, v);
      }
    };
  } else if (attr.type === Boolean) {
    return {
      get: function get() {
        return this.hasAttribute(attr.name);
      },
      set: function set(v) {
        if (v) {
          this._setattr(attr.name, '');
        } else {
          this.removeAttribute(attr.name);
        }
      }
    };
  } else if (attr.type === Number || attr.type === "long" || attr.type === "unsigned long" || attr.type === "limited unsigned long with fallback") {
    return numberPropDesc(attr);
  } else if (!attr.type || attr.type === String) {
    return {
      get: function get() {
        return this._getattr(attr.name) || '';
      },
      set: function set(v) {
        if (attr.treatNullAsEmptyString && v === null) {
          v = '';
        }
        this._setattr(attr.name, v);
      }
    };
  } else if (typeof attr.type === 'function') {
    return attr.type(attr.name, attr);
  }
  throw new Error('Invalid attribute definition');
};

// See http://www.whatwg.org/specs/web-apps/current-work/#reflect
//
// defval is the default value. If it is a function, then that function
// will be invoked as a method of the element to obtain the default.
// If no default is specified for a given attribute, then the default
// depends on the type of the attribute, but since this function handles
// 4 integer cases, you must specify the default value in each call
//
// min and max define a valid range for getting the attribute.
//
// setmin defines a minimum value when setting.  If the value is less
// than that, then throw INDEX_SIZE_ERR.
//
// Conveniently, JavaScript's parseInt function appears to be
// compatible with HTML's 'rules for parsing integers'
function numberPropDesc(a) {
  var def;
  if (typeof a.default === 'function') {
    def = a.default;
  } else if (typeof a.default === 'number') {
    def = function def() {
      return a.default;
    };
  } else {
    def = function def() {
      utils.assert(false, _typeof(a.default));
    };
  }
  var unsigned_long = a.type === 'unsigned long';
  var signed_long = a.type === 'long';
  var unsigned_fallback = a.type === 'limited unsigned long with fallback';
  var min = a.min,
      max = a.max,
      setmin = a.setmin;
  if (min === undefined) {
    if (unsigned_long) min = 0;
    if (signed_long) min = -0x80000000;
    if (unsigned_fallback) min = 1;
  }
  if (max === undefined) {
    if (unsigned_long || signed_long || unsigned_fallback) max = 0x7FFFFFFF;
  }

  return {
    get: function get() {
      var v = this._getattr(a.name);
      var n = a.float ? parseFloat(v) : parseInt(v, 10);
      if (v === null || !isFinite(n) || min !== undefined && n < min || max !== undefined && n > max) {
        return def.call(this);
      }
      if (unsigned_long || signed_long || unsigned_fallback) {
        if (!/^[ \t\n\f\r]*[-+]?[0-9]/.test(v)) {
          return def.call(this);
        }
        n = n | 0; // jshint ignore:line
      }
      return n;
    },
    set: function set(v) {
      if (!a.float) {
        v = Math.floor(v);
      }
      if (setmin !== undefined && v < setmin) {
        utils.IndexSizeError(a.name + ' set to ' + v);
      }
      if (unsigned_long) {
        v = v < 0 || v > 0x7FFFFFFF ? def.call(this) : v | 0; // jshint ignore:line
      } else if (unsigned_fallback) {
        v = v < 1 || v > 0x7FFFFFFF ? def.call(this) : v | 0; // jshint ignore:line
      } else if (signed_long) {
        v = v < -0x80000000 || v > 0x7FFFFFFF ? def.call(this) : v | 0; // jshint ignore:line
      }
      this._setattr(a.name, String(v));
    }
  };
}

// This is a utility function for setting up change handler functions
// for attributes like 'id' that require special handling when they change.
exports.registerChangeHandler = function (c, name, handler) {
  var p = c.prototype;

  // If p does not already have its own _attributeChangeHandlers
  // then create one for it, inheriting from the inherited
  // _attributeChangeHandlers. At the top (for the Element class) the
  // _attributeChangeHandlers object will be created with a null prototype.
  if (!Object.prototype.hasOwnProperty.call(p, '_attributeChangeHandlers')) {
    p._attributeChangeHandlers = Object.create(p._attributeChangeHandlers || null);
  }

  p._attributeChangeHandlers[name] = handler;
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// DOMTokenList implementation based on https://github.com/Raynos/DOM-shim
// XXX: should cache the getList(this) value more aggressively!

var utils = __webpack_require__(1);

module.exports = DOMTokenList;

function DOMTokenList(getter, setter) {
  this._getString = getter;
  this._setString = setter;
  this._length = 0;
  this._update();
}

Object.defineProperties(DOMTokenList.prototype, {
  length: { get: function get() {
      return this._length;
    } },
  item: { value: function value(index) {
      var list = getList(this);
      if (index < 0 || index >= list.length) {
        return null;
      }
      return list[index];
    } },

  contains: { value: function value(token) {
      token = String(token); // no error checking for contains()
      var list = getList(this);
      return list.indexOf(token) > -1;
    } },

  add: { value: function value() {
      var list = getList(this);
      for (var i = 0, len = arguments.length; i < len; i++) {
        var token = handleErrors(arguments[i]);
        if (list.indexOf(token) < 0) {
          list.push(token);
        }
      }
      // Note: as per spec, if handleErrors() throws any errors, we never
      // make it here and none of the changes take effect.
      // Also per spec: we run the "update steps" even if no change was
      // made (ie, if the token already existed)
      this._update(list);
    } },

  remove: { value: function value() {
      var list = getList(this);
      for (var i = 0, len = arguments.length; i < len; i++) {
        var token = handleErrors(arguments[i]);
        var index = list.indexOf(token);
        if (index > -1) {
          list.splice(index, 1);
        }
      }
      // Note: as per spec, if handleErrors() throws any errors, we never
      // make it here and none of the changes take effect.
      // Also per spec: we run the "update steps" even if no change was
      // made (ie, if the token wasn't previously present)
      this._update(list);
    } },

  toggle: { value: function toggle(token, force) {
      token = handleErrors(token);
      if (this.contains(token)) {
        if (force === undefined || force === false) {
          this.remove(token);
          return false;
        }
        return true;
      } else {
        if (force === undefined || force === true) {
          this.add(token);
          return true;
        }
        return false;
      }
    } },

  replace: { value: function replace(token, newToken) {
      // weird corner case of spec: if `token` contains whitespace, but
      // `newToken` is the empty string, we must throw SyntaxError not
      // InvalidCharacterError (sigh)
      if (String(newToken) === '') {
        utils.SyntaxError();
      }
      token = handleErrors(token);
      newToken = handleErrors(newToken);
      var list = getList(this);
      var idx = list.indexOf(token);
      if (idx < 0) {
        // Note that, per spec, we do not run the update steps on this path.
        return false;
      }
      var idx2 = list.indexOf(newToken);
      if (idx2 < 0) {
        list[idx] = newToken;
      } else {
        // "replace the first instance of either `token` or `newToken` with
        // `newToken` and remove all other instances"
        if (idx < idx2) {
          list[idx] = newToken;
          list.splice(idx2, 1);
        } else {
          // idx2 is already `newToken`
          list.splice(idx, 1);
        }
      }
      this._update(list);
      return true;
    } },

  toString: { value: function value() {
      return this._getString();
    } },

  value: {
    get: function get() {
      return this._getString();
    },
    set: function set(v) {
      this._setString(v);
      this._update();
    }
  },

  // Called when the setter is called from outside this interface.
  _update: { value: function value(list) {
      if (list) {
        fixIndex(this, list);
        this._setString(list.join(" ").trim());
      } else {
        fixIndex(this, getList(this));
      }
    } }
});

function fixIndex(clist, list) {
  var oldLength = clist._length;
  var i;
  clist._length = list.length;
  for (i = 0; i < list.length; i++) {
    clist[i] = list[i];
  }
  // Clear/free old entries.
  for (; i < oldLength; i++) {
    clist[i] = undefined;
  }
}

function handleErrors(token) {
  token = String(token);
  if (token === "") {
    utils.SyntaxError();
  }
  if (/[ \t\r\n\f]/.test(token)) {
    utils.InvalidCharacterError();
  }
  return token;
}

function getList(clist) {
  var str = clist._getString().replace(/(^[ \t\r\n\f]+)|([ \t\r\n\f]+$)/g, '');
  if (str === "") {
    return [];
  } else {
    var seen = Object.create(null);
    return str.split(/[ \t\r\n\f]+/g).filter(function (n) {
      var key = '$' + n;
      if (seen[key]) {
        return false;
      }
      seen[key] = true;
      return true;
    });
  }
}

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Node = __webpack_require__(2);

var NonDocumentTypeChildNode = {

  nextElementSibling: { get: function get() {
      if (this.parentNode) {
        for (var kid = this.nextSibling; kid !== null; kid = kid.nextSibling) {
          if (kid.nodeType === Node.ELEMENT_NODE) return kid;
        }
      }
      return null;
    } },

  previousElementSibling: { get: function get() {
      if (this.parentNode) {
        for (var kid = this.previousSibling; kid !== null; kid = kid.previousSibling) {
          if (kid.nodeType === Node.ELEMENT_NODE) return kid;
        }
      }
      return null;
    } }

};

module.exports = NonDocumentTypeChildNode;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = NamedNodeMap;

var utils = __webpack_require__(1);

/* This is a hacky implementation of NamedNodeMap, intended primarily to
 * satisfy clients (like dompurify and the web-platform-tests) which check
 * to ensure that Node#attributes instanceof NamedNodeMap. */

function NamedNodeMap(element) {
  this.element = element;
}
Object.defineProperties(NamedNodeMap.prototype, {
  length: { get: utils.shouldOverride },
  item: { value: utils.shouldOverride },

  getNamedItem: { value: function getNamedItem(qualifiedName) {
      return this.element.getAttributeNode(qualifiedName);
    } },
  getNamedItemNS: { value: function getNamedItemNS(namespace, localName) {
      return this.element.getAttributeNodeNS(namespace, localName);
    } },
  setNamedItem: { value: utils.nyi },
  setNamedItemNS: { value: utils.nyi },
  removeNamedItem: { value: function removeNamedItem(qualifiedName) {
      var attr = this.element.getAttributeNode(qualifiedName);
      if (attr) {
        this.element.removeAttribute(qualifiedName);
        return attr;
      }
      utils.NotFoundError();
    } },
  removeNamedItemNS: { value: function removeNamedItemNS(ns, lname) {
      var attr = this.element.getAttributeNodeNS(ns, lname);
      if (attr) {
        this.element.removeAttributeNS(ns, lname);
        return attr;
      }
      utils.NotFoundError();
    } }
});

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Text;

var utils = __webpack_require__(1);
var Node = __webpack_require__(2);
var CharacterData = __webpack_require__(12);

function Text(doc, data) {
  CharacterData.call(this);
  this.nodeType = Node.TEXT_NODE;
  this.ownerDocument = doc;
  this._data = data;
  this._index = undefined;
}

var nodeValue = {
  get: function get() {
    return this._data;
  },
  set: function set(v) {
    if (v === null || v === undefined) {
      v = '';
    } else {
      v = String(v);
    }
    if (v === this._data) return;
    this._data = v;
    if (this.rooted) this.ownerDocument.mutateValue(this);
    if (this.parentNode && this.parentNode._textchangehook) this.parentNode._textchangehook(this);
  }
};

Text.prototype = Object.create(CharacterData.prototype, {
  nodeName: { value: "#text" },
  // These three attributes are all the same.
  // The data attribute has a [TreatNullAs=EmptyString] but we'll
  // implement that at the interface level
  nodeValue: nodeValue,
  textContent: nodeValue,
  data: {
    get: nodeValue.get,
    set: function set(v) {
      nodeValue.set.call(this, v === null ? '' : String(v));
    }
  },

  splitText: { value: function splitText(offset) {
      if (offset > this._data.length || offset < 0) utils.IndexSizeError();

      var newdata = this._data.substring(offset),
          newnode = this.ownerDocument.createTextNode(newdata);
      this.data = this.data.substring(0, offset);

      var parent = this.parentNode;
      if (parent !== null) parent.insertBefore(newnode, this.nextSibling);

      return newnode;
    } },

  wholeText: { get: function wholeText() {
      var result = this.textContent;
      for (var next = this.nextSibling; next; next = next.nextSibling) {
        if (next.nodeType !== Node.TEXT_NODE) {
          break;
        }
        result += next.textContent;
      }
      return result;
    } },
  // Obsolete, removed from spec.
  replaceWholeText: { value: utils.nyi },

  // Utility methods
  clone: { value: function clone() {
      return new Text(this.ownerDocument, this._data);
    } }

});

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Leaf;

var Node = __webpack_require__(2);
var NodeList = __webpack_require__(6);
var utils = __webpack_require__(1);
var HierarchyRequestError = utils.HierarchyRequestError;
var NotFoundError = utils.NotFoundError;

// This class defines common functionality for node subtypes that
// can never have children
function Leaf() {
  Node.call(this);
}

Leaf.prototype = Object.create(Node.prototype, {
  hasChildNodes: { value: function value() {
      return false;
    } },
  firstChild: { value: null },
  lastChild: { value: null },
  insertBefore: { value: function value(node, child) {
      if (!node.nodeType) throw new TypeError('not a node');
      HierarchyRequestError();
    } },
  replaceChild: { value: function value(node, child) {
      if (!node.nodeType) throw new TypeError('not a node');
      HierarchyRequestError();
    } },
  removeChild: { value: function value(node) {
      if (!node.nodeType) throw new TypeError('not a node');
      NotFoundError();
    } },
  removeChildren: { value: function value() {/* no op */} },
  childNodes: { get: function get() {
      if (!this._childNodes) this._childNodes = new NodeList();
      return this._childNodes;
    } }
});

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Comment;

var Node = __webpack_require__(2);
var CharacterData = __webpack_require__(12);

function Comment(doc, data) {
  CharacterData.call(this);
  this.nodeType = Node.COMMENT_NODE;
  this.ownerDocument = doc;
  this._data = data;
}

var nodeValue = {
  get: function get() {
    return this._data;
  },
  set: function set(v) {
    if (v === null || v === undefined) {
      v = '';
    } else {
      v = String(v);
    }
    this._data = v;
    if (this.rooted) this.ownerDocument.mutateValue(this);
  }
};

Comment.prototype = Object.create(CharacterData.prototype, {
  nodeName: { value: '#comment' },
  nodeValue: nodeValue,
  textContent: nodeValue,
  data: {
    get: nodeValue.get,
    set: function set(v) {
      nodeValue.set.call(this, v === null ? '' : String(v));
    }
  },

  // Utility methods
  clone: { value: function clone() {
      return new Comment(this.ownerDocument, this._data);
    } }
});

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = DocumentFragment;

var Node = __webpack_require__(2);
var NodeList = __webpack_require__(6);
var ContainerNode = __webpack_require__(19);
var Element = __webpack_require__(9);
var select = __webpack_require__(21);
var utils = __webpack_require__(1);

function DocumentFragment(doc) {
  ContainerNode.call(this);
  this.nodeType = Node.DOCUMENT_FRAGMENT_NODE;
  this.ownerDocument = doc;
}

DocumentFragment.prototype = Object.create(ContainerNode.prototype, {
  nodeName: { value: '#document-fragment' },
  nodeValue: {
    get: function get() {
      return null;
    },
    set: function set() {}
  },
  // Copy the text content getter/setter from Element
  textContent: Object.getOwnPropertyDescriptor(Element.prototype, 'textContent'),

  querySelector: { value: function value(selector) {
      // implement in terms of querySelectorAll
      var nodes = this.querySelectorAll(selector);
      return nodes.length ? nodes[0] : null;
    } },
  querySelectorAll: { value: function value(selector) {
      // create a context
      var context = Object.create(this);
      // add some methods to the context for zest implementation, without
      // adding them to the public DocumentFragment API
      context.isHTML = true; // in HTML namespace (case-insensitive match)
      context.getElementsByTagName = Element.prototype.getElementsByTagName;
      context.nextElement = Object.getOwnPropertyDescriptor(Element.prototype, 'firstElementChild').get;
      // invoke zest
      var nodes = select(selector, context);
      return nodes.item ? nodes : new NodeList(nodes);
    } },

  // Utility methods
  clone: { value: function clone() {
      return new DocumentFragment(this.ownerDocument);
    } },
  isEqual: { value: function isEqual(n) {
      // Any two document fragments are shallowly equal.
      // Node.isEqualNode() will test their children for equality
      return true;
    } },

  // Non-standard, but useful (github issue #73)
  innerHTML: {
    get: function get() {
      return this.serialize();
    },
    set: utils.nyi
  },
  outerHTML: {
    get: function get() {
      return this.serialize();
    },
    set: utils.nyi
  }

});

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ProcessingInstruction;

var Node = __webpack_require__(2);
var CharacterData = __webpack_require__(12);

function ProcessingInstruction(doc, target, data) {
  CharacterData.call(this);
  this.nodeType = Node.PROCESSING_INSTRUCTION_NODE;
  this.ownerDocument = doc;
  this.target = target;
  this._data = data;
}

var nodeValue = {
  get: function get() {
    return this._data;
  },
  set: function set(v) {
    if (v === null || v === undefined) {
      v = '';
    } else {
      v = String(v);
    }
    this._data = v;
    if (this.rooted) this.ownerDocument.mutateValue(this);
  }
};

ProcessingInstruction.prototype = Object.create(CharacterData.prototype, {
  nodeName: { get: function get() {
      return this.target;
    } },
  nodeValue: nodeValue,
  textContent: nodeValue,
  data: {
    get: nodeValue.get,
    set: function set(v) {
      nodeValue.set.call(this, v === null ? '' : String(v));
    }
  },

  // Utility methods
  clone: { value: function clone() {
      return new ProcessingInstruction(this.ownerDocument, this.target, this._data);
    } },
  isEqual: { value: function isEqual(n) {
      return this.target === n.target && this._data === n._data;
    } }

});

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* exported NodeTraversal */

var NodeTraversal = module.exports = {
  nextSkippingChildren: nextSkippingChildren,
  nextAncestorSibling: nextAncestorSibling,
  next: next,
  previous: previous,
  deepLastChild: deepLastChild
};

/**
 * @based on WebKit's NodeTraversal::nextSkippingChildren
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.h?rev=179143#L109
 */
function nextSkippingChildren(node, stayWithin) {
  if (node === stayWithin) {
    return null;
  }
  if (node.nextSibling !== null) {
    return node.nextSibling;
  }
  return nextAncestorSibling(node, stayWithin);
}

/**
 * @based on WebKit's NodeTraversal::nextAncestorSibling
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.cpp?rev=179143#L93
 */
function nextAncestorSibling(node, stayWithin) {
  for (node = node.parentNode; node !== null; node = node.parentNode) {
    if (node === stayWithin) {
      return null;
    }
    if (node.nextSibling !== null) {
      return node.nextSibling;
    }
  }
  return null;
}

/**
 * @based on WebKit's NodeTraversal::next
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.h?rev=179143#L99
 */
function next(node, stayWithin) {
  var n;
  n = node.firstChild;
  if (n !== null) {
    return n;
  }
  if (node === stayWithin) {
    return null;
  }
  n = node.nextSibling;
  if (n !== null) {
    return n;
  }
  return nextAncestorSibling(node, stayWithin);
}

/**
 * @based on WebKit's NodeTraversal::deepLastChild
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.cpp?rev=179143#L116
 */
function deepLastChild(node) {
  while (node.lastChild) {
    node = node.lastChild;
  }
  return node;
}

/**
 * @based on WebKit's NodeTraversal::previous
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.h?rev=179143#L121
 */
function previous(node, stayWithin) {
  var p;
  p = node.previousSibling;
  if (p !== null) {
    return deepLastChild(p);
  }
  p = node.parentNode;
  if (p === stayWithin) {
    return null;
  }
  return p;
}

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  Event: __webpack_require__(8),
  UIEvent: __webpack_require__(34),
  MouseEvent: __webpack_require__(33),
  CustomEvent: __webpack_require__(77)
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var URL = __webpack_require__(23);

module.exports = URLUtils;

// Allow the `x == null` pattern.  This is eslint's "null: 'ignore'" option,
// but jshint doesn't support this.
/* jshint eqeqeq: false */

// This is an abstract superclass for Location, HTMLAnchorElement and
// other types that have the standard complement of "URL decomposition
// IDL attributes".  This is now standardized as URLUtils, see:
// https://url.spec.whatwg.org/#urlutils
// Subclasses must define a getter/setter on href.
// The getter and setter methods parse and rebuild the URL on each
// invocation; there is no attempt to cache the value and be more efficient
function URLUtils() {}
URLUtils.prototype = Object.create(Object.prototype, {

  _url: { get: function get() {
      // XXX: this should do the "Reinitialize url" steps, and "null" should
      // be a valid return value.
      return new URL(this.href);
    } },

  protocol: {
    get: function get() {
      var url = this._url;
      if (url && url.scheme) return url.scheme + ":";else return ":";
    },
    set: function set(v) {
      var output = this.href;
      var url = new URL(output);
      if (url.isAbsolute()) {
        v = v.replace(/:+$/, "");
        v = v.replace(/[^-+\.a-zA-Z0-9]/g, URL.percentEncode);
        if (v.length > 0) {
          url.scheme = v;
          output = url.toString();
        }
      }
      this.href = output;
    }
  },

  host: {
    get: function get() {
      var url = this._url;
      if (url.isAbsolute() && url.isAuthorityBased()) return url.host + (url.port ? ":" + url.port : "");else return "";
    },
    set: function set(v) {
      var output = this.href;
      var url = new URL(output);
      if (url.isAbsolute() && url.isAuthorityBased()) {
        v = v.replace(/[^-+\._~!$&'()*,;:=a-zA-Z0-9]/g, URL.percentEncode);
        if (v.length > 0) {
          url.host = v;
          delete url.port;
          output = url.toString();
        }
      }
      this.href = output;
    }
  },

  hostname: {
    get: function get() {
      var url = this._url;
      if (url.isAbsolute() && url.isAuthorityBased()) return url.host;else return "";
    },
    set: function set(v) {
      var output = this.href;
      var url = new URL(output);
      if (url.isAbsolute() && url.isAuthorityBased()) {
        v = v.replace(/^\/+/, "");
        v = v.replace(/[^-+\._~!$&'()*,;:=a-zA-Z0-9]/g, URL.percentEncode);
        if (v.length > 0) {
          url.host = v;
          output = url.toString();
        }
      }
      this.href = output;
    }
  },

  port: {
    get: function get() {
      var url = this._url;
      if (url.isAbsolute() && url.isAuthorityBased() && url.port !== undefined) return url.port;else return "";
    },
    set: function set(v) {
      var output = this.href;
      var url = new URL(output);
      if (url.isAbsolute() && url.isAuthorityBased()) {
        v = '' + v;
        v = v.replace(/[^0-9].*$/, "");
        v = v.replace(/^0+/, "");
        if (v.length === 0) v = "0";
        if (parseInt(v, 10) <= 65535) {
          url.port = v;
          output = url.toString();
        }
      }
      this.href = output;
    }
  },

  pathname: {
    get: function get() {
      var url = this._url;
      if (url.isAbsolute() && url.isHierarchical()) return url.path;else return "";
    },
    set: function set(v) {
      var output = this.href;
      var url = new URL(output);
      if (url.isAbsolute() && url.isHierarchical()) {
        if (v.charAt(0) !== "/") v = "/" + v;
        v = v.replace(/[^-+\._~!$&'()*,;:=@\/a-zA-Z0-9]/g, URL.percentEncode);
        url.path = v;
        output = url.toString();
      }
      this.href = output;
    }
  },

  search: {
    get: function get() {
      var url = this._url;
      if (url.isAbsolute() && url.isHierarchical() && url.query !== undefined) return "?" + url.query;else return "";
    },
    set: function set(v) {
      var output = this.href;
      var url = new URL(output);
      if (url.isAbsolute() && url.isHierarchical()) {
        if (v.charAt(0) === "?") v = v.substring(1);
        v = v.replace(/[^-+\._~!$&'()*,;:=@\/?a-zA-Z0-9]/g, URL.percentEncode);
        url.query = v;
        output = url.toString();
      }
      this.href = output;
    }
  },

  hash: {
    get: function get() {
      var url = this._url;
      if (url == null || url.fragment == null || url.fragment === '') {
        return "";
      } else {
        return "#" + url.fragment;
      }
    },
    set: function set(v) {
      var output = this.href;
      var url = new URL(output);

      if (v.charAt(0) === "#") v = v.substring(1);
      v = v.replace(/[^-+\._~!$&'()*,;:=@\/?a-zA-Z0-9]/g, URL.percentEncode);
      url.fragment = v;
      output = url.toString();

      this.href = output;
    }
  },

  username: {
    get: function get() {
      var url = this._url;
      return url.username || '';
    },
    set: function set(v) {
      var output = this.href;
      var url = new URL(output);
      if (url.isAbsolute()) {
        v = v.replace(/[\x00-\x1F\x7F-\uFFFF "#<>?`\/@\\:]/g, URL.percentEncode);
        url.username = v;
        output = url.toString();
      }
      this.href = output;
    }
  },

  password: {
    get: function get() {
      var url = this._url;
      return url.password || '';
    },
    set: function set(v) {
      var output = this.href;
      var url = new URL(output);
      if (url.isAbsolute()) {
        if (v === '') {
          url.password = null;
        } else {
          v = v.replace(/[\x00-\x1F\x7F-\uFFFF "#<>?`\/@\\]/g, URL.percentEncode);
          url.password = v;
        }
        output = url.toString();
      }
      this.href = output;
    }
  },

  origin: { get: function get() {
      var url = this._url;
      if (url == null) {
        return '';
      }
      var originForPort = function originForPort(defaultPort) {
        var origin = [url.scheme, url.host, +url.port || defaultPort];
        // XXX should be "unicode serialization"
        return origin[0] + '://' + origin[1] + (origin[2] === defaultPort ? '' : ':' + origin[2]);
      };
      switch (url.scheme) {
        case 'ftp':
          return originForPort(21);
        case 'gopher':
          return originForPort(70);
        case 'http':
        case 'ws':
          return originForPort(80);
        case 'https':
        case 'wss':
          return originForPort(443);
        default:
          // this is what chrome does
          return url.scheme + '://';
      }
    } }

  /*
  searchParams: {
    get: function() {
      var url = this._url;
      // XXX
    },
    set: function(v) {
      var output = this.href;
      var url = new URL(output);
      // XXX
      this.href = output;
    },
  },
  */
});

URLUtils._inherit = function (proto) {
  // copy getters/setters from URLUtils to o.
  Object.getOwnPropertyNames(URLUtils.prototype).forEach(function (p) {
    if (p === 'constructor' || p === 'href') {
      return;
    }
    var desc = Object.getOwnPropertyDescriptor(URLUtils.prototype, p);
    Object.defineProperty(proto, p, desc);
  });
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var attributes = __webpack_require__(37);
var sloppy = __webpack_require__(50);
var isApiWritable = __webpack_require__(18).isApiWritable;

module.exports = function (spec, defaultConstructor, tagList, tagNameToImpl) {
  var c = spec.ctor;
  if (c) {
    var props = spec.props || {};

    if (spec.attributes) {
      for (var n in spec.attributes) {
        var attr = spec.attributes[n];
        if ((typeof attr === 'undefined' ? 'undefined' : _typeof(attr)) !== 'object' || Array.isArray(attr)) attr = { type: attr };
        if (!attr.name) attr.name = n.toLowerCase();
        props[n] = attributes.property(attr);
      }
    }

    props.constructor = { value: c, writable: isApiWritable };
    c.prototype = Object.create((spec.superclass || defaultConstructor).prototype, props);
    if (spec.events) {
      addEventHandlers(c, spec.events);
    }
    tagList[c.name] = c;
  } else {
    c = defaultConstructor;
  }

  (spec.tags || spec.tag && [spec.tag] || []).forEach(function (tag) {
    tagNameToImpl[tag] = c;
  });

  return c;
};

function EventHandlerBuilder(body, document, form, element) {
  this.body = body;
  this.document = document;
  this.form = form;
  this.element = element;
}

EventHandlerBuilder.prototype.build = sloppy.EventHandlerBuilder_build;

function EventHandlerChangeHandler(elt, name, oldval, newval) {
  var doc = elt.ownerDocument || Object.create(null);
  var form = elt.form || Object.create(null);
  elt[name] = new EventHandlerBuilder(newval, doc, form, elt).build();
}

function addEventHandlers(c, eventHandlerTypes) {
  var p = c.prototype;
  eventHandlerTypes.forEach(function (type) {
    // Define the event handler registration IDL attribute for this type
    Object.defineProperty(p, "on" + type, {
      get: function get() {
        return this._getEventHandler(type);
      },
      set: function set(v) {
        this._setEventHandler(type, v);
      }
    });

    // Define special behavior for the content attribute as well
    attributes.registerChangeHandler(c, "on" + type, EventHandlerChangeHandler);
  });
}

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* Domino uses sloppy-mode features (in particular, `with`) for a few
 * minor things.  This file encapsulates all the sloppiness; every
 * other module should be strict. */
/* jshint strict: false */
/* jshint evil: true */
/* jshint -W085 */
module.exports = {
  Window_run: function _run(code, file) {
    if (file) code += '\n//@ sourceURL=' + file;
    eval(code);
  },
  EventHandlerBuilder_build: function build() {
    try {
      return eval("(function(event){" + this.body + "})");
    } catch (err) {
      return function () {
        throw err;
      };
    }
  }
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(1);

module.exports = {
  CSSStyleDeclaration: __webpack_require__(25),
  CharacterData: __webpack_require__(12),
  Comment: __webpack_require__(43),
  DOMException: __webpack_require__(17),
  DOMImplementation: __webpack_require__(11),
  DOMTokenList: __webpack_require__(38),
  Document: __webpack_require__(16),
  DocumentFragment: __webpack_require__(44),
  DocumentType: __webpack_require__(27),
  Element: __webpack_require__(9),
  HTMLParser: __webpack_require__(28),
  NamedNodeMap: __webpack_require__(40),
  Node: __webpack_require__(2),
  NodeList: __webpack_require__(6),
  NodeFilter: __webpack_require__(13),
  ProcessingInstruction: __webpack_require__(45),
  Text: __webpack_require__(41),
  Window: __webpack_require__(26)
};

utils.merge(exports, __webpack_require__(47));
utils.merge(exports, __webpack_require__(24).elements);
utils.merge(exports, __webpack_require__(52).elements);

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Element = __webpack_require__(9);
var defineElement = __webpack_require__(49);
var utils = __webpack_require__(1);
var CSSStyleDeclaration = __webpack_require__(25);

var svgElements = exports.elements = {};
var svgNameToImpl = Object.create(null);

exports.createElement = function (doc, localName, prefix) {
  var impl = svgNameToImpl[localName] || SVGElement;
  return new impl(doc, localName, prefix);
};

function define(spec) {
  return defineElement(spec, SVGElement, svgElements, svgNameToImpl);
}

var SVGElement = define({
  superclass: Element,
  ctor: function SVGElement(doc, localName, prefix) {
    Element.call(this, doc, localName, utils.NAMESPACE.SVG, prefix);
  },
  props: {
    style: { get: function get() {
        if (!this._style) this._style = new CSSStyleDeclaration(this);
        return this._style;
      } }
  }
});

define({
  ctor: function SVGSVGElement(doc, localName, prefix) {
    SVGElement.call(this, doc, localName, prefix);
  },
  tag: 'svg',
  props: {
    createSVGRect: { value: function value() {
        return exports.createElement(this.ownerDocument, 'rect', null);
      } }
  }
});

define({
  tags: ['a', 'altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor', 'animateMotion', 'animateTransform', 'circle', 'clipPath', 'color-profile', 'cursor', 'defs', 'desc', 'ellipse', 'feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'filter', 'font', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignObject', 'g', 'glyph', 'glyphRef', 'hkern', 'image', 'line', 'linearGradient', 'marker', 'mask', 'metadata', 'missing-glyph', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'script', 'set', 'stop', 'style', 'switch', 'symbol', 'text', 'textPath', 'title', 'tref', 'tspan', 'use', 'view', 'vkern']
});

/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(103)
)

/* script */
__vue_exports__ = __webpack_require__(104)

/* template */
var __vue_template__ = __webpack_require__(106)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-checkbox\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-30c69e5a"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(121);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(126);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(131);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(181);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Created by Tw93 on 2016/10/29.
 */

var GIF = exports.GIF = 'https://img.alicdn.com/tfs/TB1aks3PpXXXXcXXFXXXXXXXXXX-150-150.gif';
var BLACK_GIF = exports.BLACK_GIF = 'https://img.alicdn.com/tfs/TB1Ep_9NVXXXXb8XVXXXXXXXXXX-74-74.gif';
var PART = exports.PART = 'https://gtms02.alicdn.com/tfs/TB1y4QbSXXXXXbgapXXXXXXXXXX-50-50.gif';

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(203);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(271)
)

/* script */
__vue_exports__ = __webpack_require__(272)

/* template */
var __vue_template__ = __webpack_require__(273)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-rich-text\\wxc-rich-text-tag.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-2fe9c898"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*global Vue*/

/* weex initialized here, please do not move this line */
var _require = __webpack_require__(64),
    router = _require.router;

var App = __webpack_require__(391);
/* eslint-disable no-new */
new Vue(Vue.util.extend({ el: '#root', router: router }, App));
router.push('/boot');

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.router = undefined;

var _vueRouter = __webpack_require__(65);

var _vueRouter2 = _interopRequireDefault(_vueRouter);

var _boot = __webpack_require__(66);

var _boot2 = _interopRequireDefault(_boot);

var _login = __webpack_require__(85);

var _login2 = _interopRequireDefault(_login);

var _home = __webpack_require__(322);

var _home2 = _interopRequireDefault(_home);

var _setting = __webpack_require__(382);

var _setting2 = _interopRequireDefault(_setting);

var _about = __webpack_require__(386);

var _about2 = _interopRequireDefault(_about);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*global Vue*/
Vue.use(_vueRouter2.default);

var router = exports.router = new _vueRouter2.default({
    routes: [{
        path: "/home",
        name: "主页面",
        component: _home2.default
    }, {
        path: "/boot",
        name: "启动页面",
        component: _boot2.default
    }, {
        path: "/login",
        name: "登录页面",
        component: _login2.default
    }, {
        path: "/setting",
        name: "设置页面",
        component: _setting2.default
    }, {
        path: "/about",
        name: "关于页面",
        component: _about2.default
    }]
});

/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/*!
  * vue-router v3.3.2
  * (c) 2020 Evan You
  * @license MIT
  */
/*  */

function assert (condition, message) {
  if (!condition) {
    throw new Error(("[vue-router] " + message))
  }
}

function warn (condition, message) {
  if ("development" !== 'production' && !condition) {
    typeof console !== 'undefined' && console.warn(("[vue-router] " + message));
  }
}

function isError (err) {
  return Object.prototype.toString.call(err).indexOf('Error') > -1
}

function isRouterError (err, errorType) {
  return isError(err) && err._isRouter && (errorType == null || err.type === errorType)
}

function extend (a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a
}

var View = {
  name: 'RouterView',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render (_, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    // used by devtools to display a router-view badge
    data.routerView = true;

    // directly use parent context's createElement() function
    // so that components rendered by router-view can resolve named slots
    var h = parent.$createElement;
    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent && parent._routerRoot !== parent) {
      var vnodeData = parent.$vnode ? parent.$vnode.data : {};
      if (vnodeData.routerView) {
        depth++;
      }
      if (vnodeData.keepAlive && parent._directInactive && parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      var cachedData = cache[name];
      var cachedComponent = cachedData && cachedData.component;
      if (cachedComponent) {
        // #2301
        // pass props
        if (cachedData.configProps) {
          fillPropsinData(cachedComponent, data, cachedData.route, cachedData.configProps);
        }
        return h(cachedComponent, data, children)
      } else {
        // render previous empty view
        return h()
      }
    }

    var matched = route.matched[depth];
    var component = matched && matched.components[name];

    // render empty node if no matched route or no config component
    if (!matched || !component) {
      cache[name] = null;
      return h()
    }

    // cache component
    cache[name] = { component: component };

    // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks
    data.registerRouteInstance = function (vm, val) {
      // val could be undefined for unregistration
      var current = matched.instances[name];
      if (
        (val && current !== vm) ||
        (!val && current === vm)
      ) {
        matched.instances[name] = val;
      }
    }

    // also register instance in prepatch hook
    // in case the same component instance is reused across different routes
    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {
      matched.instances[name] = vnode.componentInstance;
    };

    // register instance in init hook
    // in case kept-alive component be actived when routes changed
    data.hook.init = function (vnode) {
      if (vnode.data.keepAlive &&
        vnode.componentInstance &&
        vnode.componentInstance !== matched.instances[name]
      ) {
        matched.instances[name] = vnode.componentInstance;
      }
    };

    var configProps = matched.props && matched.props[name];
    // save route and configProps in cachce
    if (configProps) {
      extend(cache[name], {
        route: route,
        configProps: configProps
      });
      fillPropsinData(component, data, route, configProps);
    }

    return h(component, data, children)
  }
};

function fillPropsinData (component, data, route, configProps) {
  // resolve props
  var propsToPass = data.props = resolveProps(route, configProps);
  if (propsToPass) {
    // clone to prevent mutation
    propsToPass = data.props = extend({}, propsToPass);
    // pass non-declared props as attrs
    var attrs = data.attrs = data.attrs || {};
    for (var key in propsToPass) {
      if (!component.props || !(key in component.props)) {
        attrs[key] = propsToPass[key];
        delete propsToPass[key];
      }
    }
  }
}

function resolveProps (route, config) {
  switch (typeof config) {
    case 'undefined':
      return
    case 'object':
      return config
    case 'function':
      return config(route)
    case 'boolean':
      return config ? route.params : undefined
    default:
      if (true) {
        warn(
          false,
          "props in \"" + (route.path) + "\" is a " + (typeof config) + ", " +
          "expecting an object, function or boolean."
        );
      }
  }
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function (str) { return encodeURIComponent(str)
  .replace(encodeReserveRE, encodeReserveReplacer)
  .replace(commaRE, ','); };

var decode = decodeURIComponent;

function resolveQuery (
  query,
  extraQuery,
  _parseQuery
) {
  if ( extraQuery === void 0 ) extraQuery = {};

  var parse = _parseQuery || parseQuery;
  var parsedQuery;
  try {
    parsedQuery = parse(query || '');
  } catch (e) {
    "development" !== 'production' && warn(false, e.message);
    parsedQuery = {};
  }
  for (var key in extraQuery) {
    parsedQuery[key] = extraQuery[key];
  }
  return parsedQuery
}

function parseQuery (query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0
      ? decode(parts.join('='))
      : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res
}

function stringifyQuery (obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return ''
    }

    if (val === null) {
      return encode(key)
    }

    if (Array.isArray(val)) {
      var result = [];
      val.forEach(function (val2) {
        if (val2 === undefined) {
          return
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&')
    }

    return encode(key) + '=' + encode(val)
  }).filter(function (x) { return x.length > 0; }).join('&') : null;
  return res ? ("?" + res) : ''
}

/*  */

var trailingSlashRE = /\/?$/;

function createRoute (
  record,
  location,
  redirectedFrom,
  router
) {
  var stringifyQuery = router && router.options.stringifyQuery;

  var query = location.query || {};
  try {
    query = clone(query);
  } catch (e) {}

  var route = {
    name: location.name || (record && record.name),
    meta: (record && record.meta) || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: query,
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery);
  }
  return Object.freeze(route)
}

function clone (value) {
  if (Array.isArray(value)) {
    return value.map(clone)
  } else if (value && typeof value === 'object') {
    var res = {};
    for (var key in value) {
      res[key] = clone(value[key]);
    }
    return res
  } else {
    return value
  }
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch (record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res
}

function getFullPath (
  ref,
  _stringifyQuery
) {
  var path = ref.path;
  var query = ref.query; if ( query === void 0 ) query = {};
  var hash = ref.hash; if ( hash === void 0 ) hash = '';

  var stringify = _stringifyQuery || stringifyQuery;
  return (path || '/') + stringify(query) + hash
}

function isSameRoute (a, b) {
  if (b === START) {
    return a === b
  } else if (!b) {
    return false
  } else if (a.path && b.path) {
    return (
      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&
      a.hash === b.hash &&
      isObjectEqual(a.query, b.query)
    )
  } else if (a.name && b.name) {
    return (
      a.name === b.name &&
      a.hash === b.hash &&
      isObjectEqual(a.query, b.query) &&
      isObjectEqual(a.params, b.params)
    )
  } else {
    return false
  }
}

function isObjectEqual (a, b) {
  if ( a === void 0 ) a = {};
  if ( b === void 0 ) b = {};

  // handle null value #1566
  if (!a || !b) { return a === b }
  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false
  }
  return aKeys.every(function (key) {
    var aVal = a[key];
    var bVal = b[key];
    // check nested equality
    if (typeof aVal === 'object' && typeof bVal === 'object') {
      return isObjectEqual(aVal, bVal)
    }
    return String(aVal) === String(bVal)
  })
}

function isIncludedRoute (current, target) {
  return (
    current.path.replace(trailingSlashRE, '/').indexOf(
      target.path.replace(trailingSlashRE, '/')
    ) === 0 &&
    (!target.hash || current.hash === target.hash) &&
    queryIncludes(current.query, target.query)
  )
}

function queryIncludes (current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false
    }
  }
  return true
}

/*  */

function resolvePath (
  relative,
  base,
  append
) {
  var firstChar = relative.charAt(0);
  if (firstChar === '/') {
    return relative
  }

  if (firstChar === '?' || firstChar === '#') {
    return base + relative
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '..') {
      stack.pop();
    } else if (segment !== '.') {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/')
}

function parsePath (path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  }
}

function cleanPath (path) {
  return path.replace(/\/\//g, '/')
}

var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options), options)
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens, options) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment;
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options && options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}
pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

/*  */

// $flow-disable-line
var regexpCompileCache = Object.create(null);

function fillParams (
  path,
  params,
  routeMsg
) {
  params = params || {};
  try {
    var filler =
      regexpCompileCache[path] ||
      (regexpCompileCache[path] = pathToRegexp_1.compile(path));

    // Fix #2505 resolving asterisk routes { name: 'not-found', params: { pathMatch: '/not-found' }}
    // and fix #3106 so that you can work with location descriptor object having params.pathMatch equal to empty string
    if (typeof params.pathMatch === 'string') { params[0] = params.pathMatch; }

    return filler(params, { pretty: true })
  } catch (e) {
    if (true) {
      // Fix #3072 no warn if `pathMatch` is string
      warn(typeof params.pathMatch === 'string', ("missing param for " + routeMsg + ": " + (e.message)));
    }
    return ''
  } finally {
    // delete the 0 if it was added
    delete params[0];
  }
}

/*  */

function normalizeLocation (
  raw,
  current,
  append,
  router
) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next._normalized) {
    return next
  } else if (next.name) {
    next = extend({}, raw);
    var params = next.params;
    if (params && typeof params === 'object') {
      next.params = extend({}, params);
    }
    return next
  }

  // relative params
  if (!next.path && next.params && current) {
    next = extend({}, next);
    next._normalized = true;
    var params$1 = extend(extend({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params$1;
    } else if (current.matched.length) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params$1, ("path " + (current.path)));
    } else if (true) {
      warn(false, "relative params navigation requires a current route.");
    }
    return next
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = (current && current.path) || '/';
  var path = parsedPath.path
    ? resolvePath(parsedPath.path, basePath, append || next.append)
    : basePath;

  var query = resolveQuery(
    parsedPath.query,
    next.query,
    router && router.options.parseQuery
  );

  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  }
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var noop = function () {};

var Link = {
  name: 'RouterLink',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    ariaCurrentValue: {
      type: String,
      default: 'page'
    },
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render (h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(
      this.to,
      current,
      this.append
    );
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;

    var classes = {};
    var globalActiveClass = router.options.linkActiveClass;
    var globalExactActiveClass = router.options.linkExactActiveClass;
    // Support global empty active class
    var activeClassFallback =
      globalActiveClass == null ? 'router-link-active' : globalActiveClass;
    var exactActiveClassFallback =
      globalExactActiveClass == null
        ? 'router-link-exact-active'
        : globalExactActiveClass;
    var activeClass =
      this.activeClass == null ? activeClassFallback : this.activeClass;
    var exactActiveClass =
      this.exactActiveClass == null
        ? exactActiveClassFallback
        : this.exactActiveClass;

    var compareTarget = route.redirectedFrom
      ? createRoute(null, normalizeLocation(route.redirectedFrom), null, router)
      : route;

    classes[exactActiveClass] = isSameRoute(current, compareTarget);
    classes[activeClass] = this.exact
      ? classes[exactActiveClass]
      : isIncludedRoute(current, compareTarget);

    var ariaCurrentValue = classes[exactActiveClass] ? this.ariaCurrentValue : null;

    var handler = function (e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location, noop);
        } else {
          router.push(location, noop);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = { class: classes };

    var scopedSlot =
      !this.$scopedSlots.$hasNormal &&
      this.$scopedSlots.default &&
      this.$scopedSlots.default({
        href: href,
        route: route,
        navigate: handler,
        isActive: classes[activeClass],
        isExactActive: classes[exactActiveClass]
      });

    if (scopedSlot) {
      if (scopedSlot.length === 1) {
        return scopedSlot[0]
      } else if (scopedSlot.length > 1 || !scopedSlot.length) {
        if (true) {
          warn(
            false,
            ("RouterLink with to=\"" + (this.to) + "\" is trying to use a scoped slot but it didn't provide exactly one child. Wrapping the content with a span element.")
          );
        }
        return scopedSlot.length === 0 ? h() : h('span', {}, scopedSlot)
      }
    }

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href, 'aria-current': ariaCurrentValue };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var aData = (a.data = extend({}, a.data));
        aData.on = aData.on || {};
        // transform existing events in both objects into arrays so we can push later
        for (var event in aData.on) {
          var handler$1 = aData.on[event];
          if (event in on) {
            aData.on[event] = Array.isArray(handler$1) ? handler$1 : [handler$1];
          }
        }
        // append new listeners for router-link
        for (var event$1 in on) {
          if (event$1 in aData.on) {
            // on[event] is always a function
            aData.on[event$1].push(on[event$1]);
          } else {
            aData.on[event$1] = handler;
          }
        }

        var aAttrs = (a.data.attrs = extend({}, a.data.attrs));
        aAttrs.href = href;
        aAttrs['aria-current'] = ariaCurrentValue;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default)
  }
};

function guardEvent (e) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) { return }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) { return }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) { return }
  // don't redirect if `target="_blank"`
  if (e.currentTarget && e.currentTarget.getAttribute) {
    var target = e.currentTarget.getAttribute('target');
    if (/\b_blank\b/i.test(target)) { return }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true
}

function findAnchor (children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child
      }
    }
  }
}

var _Vue;

function install (Vue) {
  if (install.installed && _Vue === Vue) { return }
  install.installed = true;

  _Vue = Vue;

  var isDef = function (v) { return v !== undefined; };

  var registerInstance = function (vm, callVal) {
    var i = vm.$options._parentVnode;
    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal);
    }
  };

  Vue.mixin({
    beforeCreate: function beforeCreate () {
      if (isDef(this.$options.router)) {
        this._routerRoot = this;
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      } else {
        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;
      }
      registerInstance(this, this);
    },
    destroyed: function destroyed () {
      registerInstance(this);
    }
  });

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get () { return this._routerRoot._router }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get () { return this._routerRoot._route }
  });

  Vue.component('RouterView', View);
  Vue.component('RouterLink', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function createRouteMap (
  routes,
  oldPathList,
  oldPathMap,
  oldNameMap
) {
  // the path list is used to control path matching priority
  var pathList = oldPathList || [];
  // $flow-disable-line
  var pathMap = oldPathMap || Object.create(null);
  // $flow-disable-line
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathList, pathMap, nameMap, route);
  });

  // ensure wildcard routes are always at the end
  for (var i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0]);
      l--;
      i--;
    }
  }

  if (true) {
    // warn if routes do not include leading slashes
    var found = pathList
    // check for missing leading slash
      .filter(function (path) { return path && path.charAt(0) !== '*' && path.charAt(0) !== '/'; });

    if (found.length > 0) {
      var pathNames = found.map(function (path) { return ("- " + path); }).join('\n');
      warn(false, ("Non-nested routes must include a leading slash character. Fix the following routes: \n" + pathNames));
    }
  }

  return {
    pathList: pathList,
    pathMap: pathMap,
    nameMap: nameMap
  }
}

function addRouteRecord (
  pathList,
  pathMap,
  nameMap,
  route,
  parent,
  matchAs
) {
  var path = route.path;
  var name = route.name;
  if (true) {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(
      typeof route.component !== 'string',
      "route config \"component\" for path: " + (String(
        path || name
      )) + " cannot be a " + "string id. Use an actual component instead."
    );
  }

  var pathToRegexpOptions =
    route.pathToRegexpOptions || {};
  var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);

  if (typeof route.caseSensitive === 'boolean') {
    pathToRegexpOptions.sensitive = route.caseSensitive;
  }

  var record = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props:
      route.props == null
        ? {}
        : route.components
          ? route.props
          : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named, does not redirect and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (true) {
      if (
        route.name &&
        !route.redirect &&
        route.children.some(function (child) { return /^\/?$/.test(child.path); })
      ) {
        warn(
          false,
          "Named Route '" + (route.name) + "' has a default child route. " +
            "When navigating to this named route (:to=\"{name: '" + (route.name) + "'\"), " +
            "the default child route will not be rendered. Remove the name from " +
            "this route and use the name of the default child route for named " +
            "links instead."
        );
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs
        ? cleanPath((matchAs + "/" + (child.path)))
        : undefined;
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (!pathMap[record.path]) {
    pathList.push(record.path);
    pathMap[record.path] = record;
  }

  if (route.alias !== undefined) {
    var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];
    for (var i = 0; i < aliases.length; ++i) {
      var alias = aliases[i];
      if ("development" !== 'production' && alias === path) {
        warn(
          false,
          ("Found an alias with the same value as the path: \"" + path + "\". You have to remove that alias. It will be ignored in development.")
        );
        // skip in dev to make it work
        continue
      }

      var aliasRoute = {
        path: alias,
        children: route.children
      };
      addRouteRecord(
        pathList,
        pathMap,
        nameMap,
        aliasRoute,
        parent,
        record.path || '/' // matchAs
      );
    }
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if ("development" !== 'production' && !matchAs) {
      warn(
        false,
        "Duplicate named routes definition: " +
          "{ name: \"" + name + "\", path: \"" + (record.path) + "\" }"
      );
    }
  }
}

function compileRouteRegex (
  path,
  pathToRegexpOptions
) {
  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);
  if (true) {
    var keys = Object.create(null);
    regex.keys.forEach(function (key) {
      warn(
        !keys[key.name],
        ("Duplicate param keys in route with path: \"" + path + "\"")
      );
      keys[key.name] = true;
    });
  }
  return regex
}

function normalizePath (
  path,
  parent,
  strict
) {
  if (!strict) { path = path.replace(/\/$/, ''); }
  if (path[0] === '/') { return path }
  if (parent == null) { return path }
  return cleanPath(((parent.path) + "/" + path))
}

/*  */



function createMatcher (
  routes,
  router
) {
  var ref = createRouteMap(routes);
  var pathList = ref.pathList;
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes (routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function match (
    raw,
    currentRoute,
    redirectedFrom
  ) {
    var location = normalizeLocation(raw, currentRoute, false, router);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (true) {
        warn(record, ("Route with name '" + name + "' does not exist"));
      }
      if (!record) { return _createRoute(null, location) }
      var paramNames = record.regex.keys
        .filter(function (key) { return !key.optional; })
        .map(function (key) { return key.name; });

      if (typeof location.params !== 'object') {
        location.params = {};
      }

      if (currentRoute && typeof currentRoute.params === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      location.path = fillParams(record.path, location.params, ("named route \"" + name + "\""));
      return _createRoute(record, location, redirectedFrom)
    } else if (location.path) {
      location.params = {};
      for (var i = 0; i < pathList.length; i++) {
        var path = pathList[i];
        var record$1 = pathMap[path];
        if (matchRoute(record$1.regex, location.path, location.params)) {
          return _createRoute(record$1, location, redirectedFrom)
        }
      }
    }
    // no match
    return _createRoute(null, location)
  }

  function redirect (
    record,
    location
  ) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function'
      ? originalRedirect(createRoute(record, location, null, router))
      : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || typeof redirect !== 'object') {
      if (true) {
        warn(
          false, ("invalid redirect option: " + (JSON.stringify(redirect)))
        );
      }
      return _createRoute(null, location)
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (true) {
        assert(targetRecord, ("redirect failed: named route \"" + name + "\" not found."));
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location)
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, ("redirect route with path \"" + rawPath + "\""));
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location)
    } else {
      if (true) {
        warn(false, ("invalid redirect option: " + (JSON.stringify(redirect))));
      }
      return _createRoute(null, location)
    }
  }

  function alias (
    record,
    location,
    matchAs
  ) {
    var aliasedPath = fillParams(matchAs, location.params, ("aliased route with path \"" + matchAs + "\""));
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location)
    }
    return _createRoute(null, location)
  }

  function _createRoute (
    record,
    location,
    redirectedFrom
  ) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location)
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs)
    }
    return createRoute(record, location, redirectedFrom, router)
  }

  return {
    match: match,
    addRoutes: addRoutes
  }
}

function matchRoute (
  regex,
  path,
  params
) {
  var m = path.match(regex);

  if (!m) {
    return false
  } else if (!params) {
    return true
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = regex.keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
    if (key) {
      // Fix #1994: using * with props: true generates a param named 0
      params[key.name || 'pathMatch'] = val;
    }
  }

  return true
}

function resolveRecordPath (path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true)
}

/*  */

// use User Timing api (if present) for more accurate key precision
var Time =
  inBrowser && window.performance && window.performance.now
    ? window.performance
    : Date;

function genStateKey () {
  return Time.now().toFixed(3)
}

var _key = genStateKey();

function getStateKey () {
  return _key
}

function setStateKey (key) {
  return (_key = key)
}

/*  */

var positionStore = Object.create(null);

function setupScroll () {
  // Prevent browser scroll behavior on History popstate
  if ('scrollRestoration' in window.history) {
    window.history.scrollRestoration = 'manual';
  }
  // Fix for #1585 for Firefox
  // Fix for #2195 Add optional third attribute to workaround a bug in safari https://bugs.webkit.org/show_bug.cgi?id=182678
  // Fix for #2774 Support for apps loaded from Windows file shares not mapped to network drives: replaced location.origin with
  // window.location.protocol + '//' + window.location.host
  // location.host contains the port and location.hostname doesn't
  var protocolAndPath = window.location.protocol + '//' + window.location.host;
  var absolutePath = window.location.href.replace(protocolAndPath, '');
  // preserve existing history state as it could be overriden by the user
  var stateCopy = extend({}, window.history.state);
  stateCopy.key = getStateKey();
  window.history.replaceState(stateCopy, '', absolutePath);
  window.addEventListener('popstate', handlePopState);
  return function () {
    window.removeEventListener('popstate', handlePopState);
  }
}

function handleScroll (
  router,
  to,
  from,
  isPop
) {
  if (!router.app) {
    return
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return
  }

  if (true) {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior.call(
      router,
      to,
      from,
      isPop ? position : null
    );

    if (!shouldScroll) {
      return
    }

    if (typeof shouldScroll.then === 'function') {
      shouldScroll
        .then(function (shouldScroll) {
          scrollToPosition((shouldScroll), position);
        })
        .catch(function (err) {
          if (true) {
            assert(false, err.toString());
          }
        });
    } else {
      scrollToPosition(shouldScroll, position);
    }
  });
}

function saveScrollPosition () {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function handlePopState (e) {
  saveScrollPosition();
  if (e.state && e.state.key) {
    setStateKey(e.state.key);
  }
}

function getScrollPosition () {
  var key = getStateKey();
  if (key) {
    return positionStore[key]
  }
}

function getElementPosition (el, offset) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  }
}

function isValidPosition (obj) {
  return isNumber(obj.x) || isNumber(obj.y)
}

function normalizePosition (obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  }
}

function normalizeOffset (obj) {
  return {
    x: isNumber(obj.x) ? obj.x : 0,
    y: isNumber(obj.y) ? obj.y : 0
  }
}

function isNumber (v) {
  return typeof v === 'number'
}

var hashStartsWithNumberRE = /^#\d/;

function scrollToPosition (shouldScroll, position) {
  var isObject = typeof shouldScroll === 'object';
  if (isObject && typeof shouldScroll.selector === 'string') {
    // getElementById would still fail if the selector contains a more complicated query like #main[data-attr]
    // but at the same time, it doesn't make much sense to select an element with an id and an extra selector
    var el = hashStartsWithNumberRE.test(shouldScroll.selector) // $flow-disable-line
      ? document.getElementById(shouldScroll.selector.slice(1)) // $flow-disable-line
      : document.querySelector(shouldScroll.selector);

    if (el) {
      var offset =
        shouldScroll.offset && typeof shouldScroll.offset === 'object'
          ? shouldScroll.offset
          : {};
      offset = normalizeOffset(offset);
      position = getElementPosition(el, offset);
    } else if (isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }
  } else if (isObject && isValidPosition(shouldScroll)) {
    position = normalizePosition(shouldScroll);
  }

  if (position) {
    window.scrollTo(position.x, position.y);
  }
}

/*  */

var supportsPushState =
  inBrowser &&
  (function () {
    var ua = window.navigator.userAgent;

    if (
      (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&
      ua.indexOf('Mobile Safari') !== -1 &&
      ua.indexOf('Chrome') === -1 &&
      ua.indexOf('Windows Phone') === -1
    ) {
      return false
    }

    return window.history && typeof window.history.pushState === 'function'
  })();

function pushState (url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      // preserve existing history state as it could be overriden by the user
      var stateCopy = extend({}, history.state);
      stateCopy.key = getStateKey();
      history.replaceState(stateCopy, '', url);
    } else {
      history.pushState({ key: setStateKey(genStateKey()) }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState (url) {
  pushState(url, true);
}

/*  */

function runQueue (queue, fn, cb) {
  var step = function (index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

function resolveAsyncComponents (matched) {
  return function (to, from, next) {
    var hasAsync = false;
    var pending = 0;
    var error = null;

    flatMapComponents(matched, function (def, _, match, key) {
      // if it's a function and doesn't have cid attached,
      // assume it's an async component resolve function.
      // we are not using Vue's default async resolving mechanism because
      // we want to halt the navigation until the incoming component has been
      // resolved.
      if (typeof def === 'function' && def.cid === undefined) {
        hasAsync = true;
        pending++;

        var resolve = once(function (resolvedDef) {
          if (isESModule(resolvedDef)) {
            resolvedDef = resolvedDef.default;
          }
          // save resolved on async factory in case it's used elsewhere
          def.resolved = typeof resolvedDef === 'function'
            ? resolvedDef
            : _Vue.extend(resolvedDef);
          match.components[key] = resolvedDef;
          pending--;
          if (pending <= 0) {
            next();
          }
        });

        var reject = once(function (reason) {
          var msg = "Failed to resolve async component " + key + ": " + reason;
          "development" !== 'production' && warn(false, msg);
          if (!error) {
            error = isError(reason)
              ? reason
              : new Error(msg);
            next(error);
          }
        });

        var res;
        try {
          res = def(resolve, reject);
        } catch (e) {
          reject(e);
        }
        if (res) {
          if (typeof res.then === 'function') {
            res.then(resolve, reject);
          } else {
            // new syntax in Vue 2.3
            var comp = res.component;
            if (comp && typeof comp.then === 'function') {
              comp.then(resolve, reject);
            }
          }
        }
      }
    });

    if (!hasAsync) { next(); }
  }
}

function flatMapComponents (
  matched,
  fn
) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) { return fn(
      m.components[key],
      m.instances[key],
      m, key
    ); })
  }))
}

function flatten (arr) {
  return Array.prototype.concat.apply([], arr)
}

var hasSymbol =
  typeof Symbol === 'function' &&
  typeof Symbol.toStringTag === 'symbol';

function isESModule (obj) {
  return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module')
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once (fn) {
  var called = false;
  return function () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    if (called) { return }
    called = true;
    return fn.apply(this, args)
  }
}

var NavigationFailureType = {
  redirected: 1,
  aborted: 2,
  cancelled: 3,
  duplicated: 4
};

function createNavigationRedirectedError (from, to) {
  return createRouterError(
    from,
    to,
    NavigationFailureType.redirected,
    ("Redirected from \"" + (from.fullPath) + "\" to \"" + (stringifyRoute(to)) + "\" via a navigation guard.")
  )
}

function createNavigationDuplicatedError (from, to) {
  return createRouterError(
    from,
    to,
    NavigationFailureType.duplicated,
    ("Avoided redundant navigation to current location: \"" + (from.fullPath) + "\".")
  )
}

function createNavigationCancelledError (from, to) {
  return createRouterError(
    from,
    to,
    NavigationFailureType.cancelled,
    ("Navigation cancelled from \"" + (from.fullPath) + "\" to \"" + (to.fullPath) + "\" with a new navigation.")
  )
}

function createNavigationAbortedError (from, to) {
  return createRouterError(
    from,
    to,
    NavigationFailureType.aborted,
    ("Navigation aborted from \"" + (from.fullPath) + "\" to \"" + (to.fullPath) + "\" via a navigation guard.")
  )
}

function createRouterError (from, to, type, message) {
  var error = new Error(message);
  error._isRouter = true;
  error.from = from;
  error.to = to;
  error.type = type;

  return error
}

var propertiesToLog = ['params', 'query', 'hash'];

function stringifyRoute (to) {
  if (typeof to === 'string') { return to }
  if ('path' in to) { return to.path }
  var location = {};
  propertiesToLog.forEach(function (key) {
    if (key in to) { location[key] = to[key]; }
  });
  return JSON.stringify(location, null, 2)
}

/*  */

var History = function History (router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
  this.readyErrorCbs = [];
  this.errorCbs = [];
  this.listeners = [];
};

History.prototype.listen = function listen (cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady (cb, errorCb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
    if (errorCb) {
      this.readyErrorCbs.push(errorCb);
    }
  }
};

History.prototype.onError = function onError (errorCb) {
  this.errorCbs.push(errorCb);
};

History.prototype.transitionTo = function transitionTo (
  location,
  onComplete,
  onAbort
) {
    var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(
    route,
    function () {
      var prev = this$1.current;
      this$1.updateRoute(route);
      onComplete && onComplete(route);
      this$1.ensureURL();
      this$1.router.afterHooks.forEach(function (hook) {
        hook && hook(route, prev);
      });

      // fire ready cbs once
      if (!this$1.ready) {
        this$1.ready = true;
        this$1.readyCbs.forEach(function (cb) {
          cb(route);
        });
      }
    },
    function (err) {
      if (onAbort) {
        onAbort(err);
      }
      if (err && !this$1.ready) {
        this$1.ready = true;
        this$1.readyErrorCbs.forEach(function (cb) {
          cb(err);
        });
      }
    }
  );
};

History.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {
    var this$1 = this;

  var current = this.current;
  var abort = function (err) {
    // changed after adding errors with
    // https://github.com/vuejs/vue-router/pull/3047 before that change,
    // redirect and aborted navigation would produce an err == null
    if (!isRouterError(err) && isError(err)) {
      if (this$1.errorCbs.length) {
        this$1.errorCbs.forEach(function (cb) {
          cb(err);
        });
      } else {
        warn(false, 'uncaught error during route navigation:');
        console.error(err);
      }
    }
    onAbort && onAbort(err);
  };
  if (
    isSameRoute(route, current) &&
    // in the case the route map has been dynamically appended to
    route.matched.length === current.matched.length
  ) {
    this.ensureURL();
    return abort(createNavigationDuplicatedError(current, route))
  }

  var ref = resolveQueue(
    this.current.matched,
    route.matched
  );
    var updated = ref.updated;
    var deactivated = ref.deactivated;
    var activated = ref.activated;

  var queue = [].concat(
    // in-component leave guards
    extractLeaveGuards(deactivated),
    // global before hooks
    this.router.beforeHooks,
    // in-component update hooks
    extractUpdateHooks(updated),
    // in-config enter guards
    activated.map(function (m) { return m.beforeEnter; }),
    // async components
    resolveAsyncComponents(activated)
  );

  this.pending = route;
  var iterator = function (hook, next) {
    if (this$1.pending !== route) {
      return abort(createNavigationCancelledError(current, route))
    }
    try {
      hook(route, current, function (to) {
        if (to === false) {
          // next(false) -> abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(createNavigationAbortedError(current, route));
        } else if (isError(to)) {
          this$1.ensureURL(true);
          abort(to);
        } else if (
          typeof to === 'string' ||
          (typeof to === 'object' &&
            (typeof to.path === 'string' || typeof to.name === 'string'))
        ) {
          // next('/') or next({ path: '/' }) -> redirect
          abort(createNavigationRedirectedError(current, route));
          if (typeof to === 'object' && to.replace) {
            this$1.replace(to);
          } else {
            this$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function () { return this$1.current === route; };
    // wait until async components are resolved before
    // extracting in-component enter guards
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    var queue = enterGuards.concat(this$1.router.resolveHooks);
    runQueue(queue, iterator, function () {
      if (this$1.pending !== route) {
        return abort(createNavigationCancelledError(current, route))
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) {
            cb();
          });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute (route) {
  this.current = route;
  this.cb && this.cb(route);
};

History.prototype.setupListeners = function setupListeners () {
  // Default implementation is empty
};

History.prototype.teardownListeners = function teardownListeners () {
  this.listeners.forEach(function (cleanupListener) {
    cleanupListener();
  });
  this.listeners = [];
};

function normalizeBase (base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = (baseEl && baseEl.getAttribute('href')) || '/';
      // strip full URL origin
      base = base.replace(/^https?:\/\/[^\/]+/, '');
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '')
}

function resolveQueue (
  current,
  next
) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  }
}

function extractGuards (
  records,
  name,
  bind,
  reverse
) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard)
        ? guard.map(function (guard) { return bind(guard, instance, match, key); })
        : bind(guard, instance, match, key)
    }
  });
  return flatten(reverse ? guards.reverse() : guards)
}

function extractGuard (
  def,
  key
) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key]
}

function extractLeaveGuards (deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)
}

function extractUpdateHooks (updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)
}

function bindGuard (guard, instance) {
  if (instance) {
    return function boundRouteGuard () {
      return guard.apply(instance, arguments)
    }
  }
}

function extractEnterGuards (
  activated,
  cbs,
  isValid
) {
  return extractGuards(
    activated,
    'beforeRouteEnter',
    function (guard, _, match, key) {
      return bindEnterGuard(guard, match, key, cbs, isValid)
    }
  )
}

function bindEnterGuard (
  guard,
  match,
  key,
  cbs,
  isValid
) {
  return function routeEnterGuard (to, from, next) {
    return guard(to, from, function (cb) {
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
      next(cb);
    })
  }
}

function poll (
  cb, // somehow flow cannot infer this is a function
  instances,
  key,
  isValid
) {
  if (
    instances[key] &&
    !instances[key]._isBeingDestroyed // do not reuse being destroyed instance
  ) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

/*  */

var HTML5History = /*@__PURE__*/(function (History) {
  function HTML5History (router, base) {
    History.call(this, router, base);

    this._startLocation = getLocation(this.base);
  }

  if ( History ) HTML5History.__proto__ = History;
  HTML5History.prototype = Object.create( History && History.prototype );
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.setupListeners = function setupListeners () {
    var this$1 = this;

    if (this.listeners.length > 0) {
      return
    }

    var router = this.router;
    var expectScroll = router.options.scrollBehavior;
    var supportsScroll = supportsPushState && expectScroll;

    if (supportsScroll) {
      this.listeners.push(setupScroll());
    }

    var handleRoutingEvent = function () {
      var current = this$1.current;

      // Avoiding first `popstate` event dispatched in some browsers but first
      // history route not updated since async guard at the same time.
      var location = getLocation(this$1.base);
      if (this$1.current === START && location === this$1._startLocation) {
        return
      }

      this$1.transitionTo(location, function (route) {
        if (supportsScroll) {
          handleScroll(router, route, current, true);
        }
      });
    };
    window.addEventListener('popstate', handleRoutingEvent);
    this.listeners.push(function () {
      window.removeEventListener('popstate', handleRoutingEvent);
    });
  };

  HTML5History.prototype.go = function go (n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL (push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {
    return getLocation(this.base)
  };

  return HTML5History;
}(History));

function getLocation (base) {
  var path = decodeURI(window.location.pathname);
  if (base && path.toLowerCase().indexOf(base.toLowerCase()) === 0) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash
}

/*  */

var HashHistory = /*@__PURE__*/(function (History) {
  function HashHistory (router, base, fallback) {
    History.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return
    }
    ensureSlash();
  }

  if ( History ) HashHistory.__proto__ = History;
  HashHistory.prototype = Object.create( History && History.prototype );
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners () {
    var this$1 = this;

    if (this.listeners.length > 0) {
      return
    }

    var router = this.router;
    var expectScroll = router.options.scrollBehavior;
    var supportsScroll = supportsPushState && expectScroll;

    if (supportsScroll) {
      this.listeners.push(setupScroll());
    }

    var handleRoutingEvent = function () {
      var current = this$1.current;
      if (!ensureSlash()) {
        return
      }
      this$1.transitionTo(getHash(), function (route) {
        if (supportsScroll) {
          handleScroll(this$1.router, route, current, true);
        }
        if (!supportsPushState) {
          replaceHash(route.fullPath);
        }
      });
    };
    var eventType = supportsPushState ? 'popstate' : 'hashchange';
    window.addEventListener(
      eventType,
      handleRoutingEvent
    );
    this.listeners.push(function () {
      window.removeEventListener(eventType, handleRoutingEvent);
    });
  };

  HashHistory.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(
      location,
      function (route) {
        pushHash(route.fullPath);
        handleScroll(this$1.router, route, fromRoute, false);
        onComplete && onComplete(route);
      },
      onAbort
    );
  };

  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(
      location,
      function (route) {
        replaceHash(route.fullPath);
        handleScroll(this$1.router, route, fromRoute, false);
        onComplete && onComplete(route);
      },
      onAbort
    );
  };

  HashHistory.prototype.go = function go (n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL (push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {
    return getHash()
  };

  return HashHistory;
}(History));

function checkFallback (base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + '/#' + location));
    return true
  }
}

function ensureSlash () {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true
  }
  replaceHash('/' + path);
  return false
}

function getHash () {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  // empty path
  if (index < 0) { return '' }

  href = href.slice(index + 1);
  // decode the hash but not the search or hash
  // as search(query) is already decoded
  // https://github.com/vuejs/vue-router/issues/2708
  var searchIndex = href.indexOf('?');
  if (searchIndex < 0) {
    var hashIndex = href.indexOf('#');
    if (hashIndex > -1) {
      href = decodeURI(href.slice(0, hashIndex)) + href.slice(hashIndex);
    } else { href = decodeURI(href); }
  } else {
    href = decodeURI(href.slice(0, searchIndex)) + href.slice(searchIndex);
  }

  return href
}

function getUrl (path) {
  var href = window.location.href;
  var i = href.indexOf('#');
  var base = i >= 0 ? href.slice(0, i) : href;
  return (base + "#" + path)
}

function pushHash (path) {
  if (supportsPushState) {
    pushState(getUrl(path));
  } else {
    window.location.hash = path;
  }
}

function replaceHash (path) {
  if (supportsPushState) {
    replaceState(getUrl(path));
  } else {
    window.location.replace(getUrl(path));
  }
}

/*  */

var AbstractHistory = /*@__PURE__*/(function (History) {
  function AbstractHistory (router, base) {
    History.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if ( History ) AbstractHistory.__proto__ = History;
  AbstractHistory.prototype = Object.create( History && History.prototype );
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(
      location,
      function (route) {
        this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
        this$1.index++;
        onComplete && onComplete(route);
      },
      onAbort
    );
  };

  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(
      location,
      function (route) {
        this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
        onComplete && onComplete(route);
      },
      onAbort
    );
  };

  AbstractHistory.prototype.go = function go (n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(
      route,
      function () {
        this$1.index = targetIndex;
        this$1.updateRoute(route);
      },
      function (err) {
        if (isRouterError(err, NavigationFailureType.duplicated)) {
          this$1.index = targetIndex;
        }
      }
    );
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/'
  };

  AbstractHistory.prototype.ensureURL = function ensureURL () {
    // noop
  };

  return AbstractHistory;
}(History));

/*  */



var VueRouter = function VueRouter (options) {
  if ( options === void 0 ) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.resolveHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || [], this);

  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break
    default:
      if (true) {
        assert(false, ("invalid mode: " + mode));
      }
  }
};

var prototypeAccessors = { currentRoute: { configurable: true } };

VueRouter.prototype.match = function match (
  raw,
  current,
  redirectedFrom
) {
  return this.matcher.match(raw, current, redirectedFrom)
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current
};

VueRouter.prototype.init = function init (app /* Vue component instance */) {
    var this$1 = this;

  "development" !== 'production' && assert(
    install.installed,
    "not installed. Make sure to call `Vue.use(VueRouter)` " +
    "before creating root instance."
  );

  this.apps.push(app);

  // set up app destroyed handler
  // https://github.com/vuejs/vue-router/issues/2639
  app.$once('hook:destroyed', function () {
    // clean out app from this.apps array once destroyed
    var index = this$1.apps.indexOf(app);
    if (index > -1) { this$1.apps.splice(index, 1); }
    // ensure we still have a main app or null if no apps
    // we do not release the router so it can be reused
    if (this$1.app === app) { this$1.app = this$1.apps[0] || null; }

    if (!this$1.app) {
      // clean up event listeners
      // https://github.com/vuejs/vue-router/issues/2341
      this$1.history.teardownListeners();
    }
  });

  // main app previously initialized
  // return as we don't need to set up new history listener
  if (this.app) {
    return
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History || history instanceof HashHistory) {
    var setupListeners = function () {
      history.setupListeners();
    };
    history.transitionTo(history.getCurrentLocation(), setupListeners, setupListeners);
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach (fn) {
  return registerHook(this.beforeHooks, fn)
};

VueRouter.prototype.beforeResolve = function beforeResolve (fn) {
  return registerHook(this.resolveHooks, fn)
};

VueRouter.prototype.afterEach = function afterEach (fn) {
  return registerHook(this.afterHooks, fn)
};

VueRouter.prototype.onReady = function onReady (cb, errorCb) {
  this.history.onReady(cb, errorCb);
};

VueRouter.prototype.onError = function onError (errorCb) {
  this.history.onError(errorCb);
};

VueRouter.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

  // $flow-disable-line
  if (!onComplete && !onAbort && typeof Promise !== 'undefined') {
    return new Promise(function (resolve, reject) {
      this$1.history.push(location, resolve, reject);
    })
  } else {
    this.history.push(location, onComplete, onAbort);
  }
};

VueRouter.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

  // $flow-disable-line
  if (!onComplete && !onAbort && typeof Promise !== 'undefined') {
    return new Promise(function (resolve, reject) {
      this$1.history.replace(location, resolve, reject);
    })
  } else {
    this.history.replace(location, onComplete, onAbort);
  }
};

VueRouter.prototype.go = function go (n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back () {
  this.go(-1);
};

VueRouter.prototype.forward = function forward () {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {
  var route = to
    ? to.matched
      ? to
      : this.resolve(to).route
    : this.currentRoute;
  if (!route) {
    return []
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key]
    })
  }))
};

VueRouter.prototype.resolve = function resolve (
  to,
  current,
  append
) {
  current = current || this.history.current;
  var location = normalizeLocation(
    to,
    current,
    append,
    this
  );
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  }
};

VueRouter.prototype.addRoutes = function addRoutes (routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties( VueRouter.prototype, prototypeAccessors );

function registerHook (list, fn) {
  list.push(fn);
  return function () {
    var i = list.indexOf(fn);
    if (i > -1) { list.splice(i, 1); }
  }
}

function createHref (base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path
}

VueRouter.install = install;
VueRouter.version = '3.3.2';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

/* harmony default export */ __webpack_exports__["default"] = (VueRouter);


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(67)
)

/* script */
__vue_exports__ = __webpack_require__(68)

/* template */
var __vue_template__ = __webpack_require__(84)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\src\\boot.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-76b81310"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 67 */
/***/ (function(module, exports) {

module.exports = {
  "wrapper": {
    "flex": 1,
    "width": "750",
    "backgroundColor": "#FFFFFF"
  },
  "image": {
    "width": "429",
    "height": "135"
  },
  "operations": {
    "height": "400",
    "flex": 0,
    "flexDirection": "row",
    "justifyContent": "center",
    "alignItems": "center"
  },
  "button": {
    "alignItems": "center",
    "justifyContent": "center",
    "borderRadius": "10",
    "height": "100",
    "width": "600",
    "backgroundColor": "#238FFF"
  }
}

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = __webpack_require__(7);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _utils = __webpack_require__(15);

var _utils2 = _interopRequireDefault(_utils);

var _gitee = __webpack_require__(10);

var _gitee2 = _interopRequireDefault(_gitee);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var modal = weex.requireModule('modal');
var image = __webpack_require__(53).default;
exports.default = {
    name: "boot",
    beforeCreate: function beforeCreate() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
            return _regenerator2.default.wrap(function _callee$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            _context.next = 2;
                            return _gitee2.default.isLogin();

                        case 2:
                            if (!_context.sent) {
                                _context.next = 7;
                                break;
                            }

                            _context.next = 5;
                            return _this.$router.push("/home");

                        case 5:
                            _context.next = 8;
                            break;

                        case 7:
                            _this.buttonEnable = true;

                        case 8:
                        case "end":
                            return _context.stop();
                    }
                }
            }, _callee, _this);
        }))();
    },

    methods: {
        onClick: function onClick() {
            var _this2 = this;

            return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
                var self, first;
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                self = _this2;
                                _context3.next = 3;
                                return _utils2.default.getValue('first-boot');

                            case 3:
                                first = _context3.sent;

                                if (!(first === null)) {
                                    _context3.next = 8;
                                    break;
                                }

                                modal.alert({
                                    okTitle: "我已确认",
                                    message: "gitee-weex是一个开源项目，它不会收集任何信息，甚至连服务器都没有，请放心授权此APP。"
                                }, function () {
                                    var _ref = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee2(value) {
                                        return _regenerator2.default.wrap(function _callee2$(_context2) {
                                            while (1) {
                                                switch (_context2.prev = _context2.next) {
                                                    case 0:
                                                        _context2.next = 2;
                                                        return _utils2.default.setValue('first-boot', true);

                                                    case 2:
                                                        _context2.next = 4;
                                                        return self.$router.push({
                                                            path: '/login'
                                                        });

                                                    case 4:
                                                    case "end":
                                                        return _context2.stop();
                                                }
                                            }
                                        }, _callee2, this);
                                    }));

                                    return function (_x) {
                                        return _ref.apply(this, arguments);
                                    };
                                }());
                                _context3.next = 10;
                                break;

                            case 8:
                                _context3.next = 10;
                                return self.$router.push({
                                    path: '/login'
                                });

                            case 10:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, _this2);
            }))();
        }
    },
    data: function data() {
        return {
            buttonEnable: false,
            text: "使用Apache Weex开发",
            buttonText: "登录Gitee",
            logo: image
        };
    }
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(70);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 70 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DOMImplementation = __webpack_require__(11);
var HTMLParser = __webpack_require__(28);
var Window = __webpack_require__(26);

exports.createDOMImplementation = function () {
  return new DOMImplementation(null);
};

exports.createDocument = function (html, force) {
  // Previous API couldn't let you pass '' as a document, and that
  // yields a slightly different document than createHTMLDocument('')
  // does.  The new `force` parameter lets you pass '' if you want to.
  if (html || force) {
    var parser = new HTMLParser();
    parser.parse(html || '', true);
    return parser.document();
  }
  return new DOMImplementation(null).createHTMLDocument("");
};

exports.createIncrementalHTMLParser = function () {
  var parser = new HTMLParser();
  /** API for incremental parser. */
  return {
    /** Provide an additional chunk of text to be parsed. */
    write: function write(s) {
      if (s.length > 0) {
        parser.parse(s, false, function () {
          return true;
        });
      }
    },
    /**
     * Signal that we are done providing input text, optionally
     * providing one last chunk as a parameter.
     */
    end: function end(s) {
      parser.parse(s || '', true, function () {
        return true;
      });
    },
    /**
     * Performs a chunk of parsing work, returning at the end of
     * the next token as soon as shouldPauseFunc() returns true.
     * Returns true iff there is more work to do.
     *
     * For example:
     * ```
     *  var incrParser = domino.createIncrementalHTMLParser();
     *  incrParser.end('...long html document...');
     *  while (true) {
     *    // Pause every 10ms
     *    var start = Date.now();
     *    var pauseIn10 = function() { return (Date.now() - start) >= 10; };
     *    if (!incrParser.process(pauseIn10)) {
     *      break;
     *    }
     *    ...yield to other tasks, do other housekeeping, etc...
     *  }
     * ```
     */
    process: function process(shouldPauseFunc) {
      return parser.parse('', false, shouldPauseFunc);
    },
    /**
     * Returns the result of the incremental parse.  Valid after
     * `this.end()` has been called and `this.process()` has returned
     * false.
     */
    document: function document() {
      return parser.document();
    }
  };
};

exports.createWindow = function (html, address) {
  var document = exports.createDocument(html);
  if (address !== undefined) {
    document._address = address;
  }
  return new Window(document);
};

exports.impl = __webpack_require__(51);

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* jshint esversion: 6 */


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

module.exports = function (_Array) {
    _inherits(NodeList, _Array);

    function NodeList(a) {
        _classCallCheck(this, NodeList);

        var _this = _possibleConstructorReturn(this, (NodeList.__proto__ || Object.getPrototypeOf(NodeList)).call(this, a && a.length || 0));

        if (a) {
            for (var idx in a) {
                _this[idx] = a[idx];
            }
        }
        return _this;
    }

    _createClass(NodeList, [{
        key: "item",
        value: function item(i) {
            return this[i] || null;
        }
    }]);

    return NodeList;
}(Array);

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// No support for subclassing array, return an actual Array object.

function item(i) {
    /* jshint validthis: true */
    return this[i] || null;
}

function NodeList(a) {
    if (!a) a = [];
    a.item = item;
    return a;
}

module.exports = NodeList;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = FilteredElementList;

var Node = __webpack_require__(2);

//
// This file defines node list implementation that lazily traverses
// the document tree (or a subtree rooted at any element) and includes
// only those elements for which a specified filter function returns true.
// It is used to implement the
// {Document,Element}.getElementsBy{TagName,ClassName}{,NS} methods.
//
// XXX this should inherit from NodeList

function FilteredElementList(root, filter) {
  this.root = root;
  this.filter = filter;
  this.lastModTime = root.lastModTime;
  this.done = false;
  this.cache = [];
  this.traverse();
}

FilteredElementList.prototype = Object.create(Object.prototype, {
  length: { get: function get() {
      this.checkcache();
      if (!this.done) this.traverse();
      return this.cache.length;
    } },

  item: { value: function value(n) {
      this.checkcache();
      if (!this.done && n >= this.cache.length) {
        // This can lead to O(N^2) behavior if we stop when we get to n
        // and the caller is iterating through the items in order; so
        // be sure to do the full traverse here.
        this.traverse();
      }
      return this.cache[n];
    } },

  checkcache: { value: function value() {
      if (this.lastModTime !== this.root.lastModTime) {
        // subtree has changed, so invalidate cache
        for (var i = this.cache.length - 1; i >= 0; i--) {
          this[i] = undefined;
        }
        this.cache.length = 0;
        this.done = false;
        this.lastModTime = this.root.lastModTime;
      }
    } },

  // If n is specified, then traverse the tree until we've found the nth
  // item (or until we've found all items).  If n is not specified,
  // traverse until we've found all items.
  traverse: { value: function value(n) {
      // increment n so we can compare to length, and so it is never falsy
      if (n !== undefined) n++;

      var elt;
      while ((elt = this.next()) !== null) {
        this[this.cache.length] = elt; //XXX Use proxy instead
        this.cache.push(elt);
        if (n && this.cache.length === n) return;
      }

      // no next element, so we've found everything
      this.done = true;
    } },

  // Return the next element under root that matches filter
  next: { value: function value() {
      var start = this.cache.length === 0 ? this.root // Start at the root or at
      : this.cache[this.cache.length - 1]; // the last element we found

      var elt;
      if (start.nodeType === Node.DOCUMENT_NODE) elt = start.documentElement;else elt = start.nextElement(this.root);

      while (elt) {
        if (this.filter(elt)) {
          return elt;
        }

        elt = elt.nextElement(this.root);
      }
      return null;
    } }
});

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = TreeWalker;

var Node = __webpack_require__(2);
var NodeFilter = __webpack_require__(13);
var NodeTraversal = __webpack_require__(46);
var utils = __webpack_require__(1);

var mapChild = {
  first: 'firstChild',
  last: 'lastChild',
  next: 'firstChild',
  previous: 'lastChild'
};

var mapSibling = {
  first: 'nextSibling',
  last: 'previousSibling',
  next: 'nextSibling',
  previous: 'previousSibling'
};

/* Private methods and helpers */

/**
 * @spec https://dom.spec.whatwg.org/#concept-traverse-children
 * @method
 * @access private
 * @param {TreeWalker} tw
 * @param {string} type One of 'first' or 'last'.
 * @return {Node|null}
 */
function traverseChildren(tw, type) {
  var child, node, parent, result, sibling;
  node = tw._currentNode[mapChild[type]];
  while (node !== null) {
    result = tw._internalFilter(node);
    if (result === NodeFilter.FILTER_ACCEPT) {
      tw._currentNode = node;
      return node;
    }
    if (result === NodeFilter.FILTER_SKIP) {
      child = node[mapChild[type]];
      if (child !== null) {
        node = child;
        continue;
      }
    }
    while (node !== null) {
      sibling = node[mapSibling[type]];
      if (sibling !== null) {
        node = sibling;
        break;
      }
      parent = node.parentNode;
      if (parent === null || parent === tw.root || parent === tw._currentNode) {
        return null;
      } else {
        node = parent;
      }
    }
  }
  return null;
}

/**
 * @spec https://dom.spec.whatwg.org/#concept-traverse-siblings
 * @method
 * @access private
 * @param {TreeWalker} tw
 * @param {TreeWalker} type One of 'next' or 'previous'.
 * @return {Node|nul}
 */
function traverseSiblings(tw, type) {
  var node, result, sibling;
  node = tw._currentNode;
  if (node === tw.root) {
    return null;
  }
  while (true) {
    sibling = node[mapSibling[type]];
    while (sibling !== null) {
      node = sibling;
      result = tw._internalFilter(node);
      if (result === NodeFilter.FILTER_ACCEPT) {
        tw._currentNode = node;
        return node;
      }
      sibling = node[mapChild[type]];
      if (result === NodeFilter.FILTER_REJECT || sibling === null) {
        sibling = node[mapSibling[type]];
      }
    }
    node = node.parentNode;
    if (node === null || node === tw.root) {
      return null;
    }
    if (tw._internalFilter(node) === NodeFilter.FILTER_ACCEPT) {
      return null;
    }
  }
}

/* Public API */

/**
 * Latest version: https://dom.spec.whatwg.org/#treewalker
 *
 * @constructor
 * @param {Node} root
 * @param {number} whatToShow [optional]
 * @param {Function|NodeFilter} filter [optional]
 * @throws Error
 */
function TreeWalker(root, whatToShow, filter) {
  if (!root || !root.nodeType) {
    utils.NotSupportedError();
  }

  // Read-only properties
  this._root = root;
  this._whatToShow = Number(whatToShow) || 0;
  this._filter = filter || null;
  this._active = false;
  // Read-write property
  this._currentNode = root;
}

Object.defineProperties(TreeWalker.prototype, {
  root: { get: function get() {
      return this._root;
    } },
  whatToShow: { get: function get() {
      return this._whatToShow;
    } },
  filter: { get: function get() {
      return this._filter;
    } },

  currentNode: {
    get: function currentNode() {
      return this._currentNode;
    },
    set: function setCurrentNode(v) {
      if (!(v instanceof Node)) {
        throw new TypeError("Not a Node"); // `null` is also not a node
      }
      this._currentNode = v;
    }
  },

  /**
   * @method
   * @param {Node} node
   * @return {Number} Constant NodeFilter.FILTER_ACCEPT,
   *  NodeFilter.FILTER_REJECT or NodeFilter.FILTER_SKIP.
   */
  _internalFilter: { value: function _internalFilter(node) {
      /* jshint bitwise: false */
      var result, filter;
      if (this._active) {
        utils.InvalidStateError();
      }

      // Maps nodeType to whatToShow
      if (!(1 << node.nodeType - 1 & this._whatToShow)) {
        return NodeFilter.FILTER_SKIP;
      }

      filter = this._filter;
      if (filter === null) {
        result = NodeFilter.FILTER_ACCEPT;
      } else {
        this._active = true;
        try {
          if (typeof filter === 'function') {
            result = filter(node);
          } else {
            result = filter.acceptNode(node);
          }
        } finally {
          this._active = false;
        }
      }

      // Note that coercing to a number means that
      //  `true` becomes `1` (which is NodeFilter.FILTER_ACCEPT)
      //  `false` becomes `0` (neither accept, reject, or skip)
      return +result;
    } },

  /**
   * @spec https://dom.spec.whatwg.org/#dom-treewalker-parentnode
   * @based on WebKit's TreeWalker::parentNode
   * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/dom/TreeWalker.cpp?rev=220453#L50
   * @method
   * @return {Node|null}
   */
  parentNode: { value: function parentNode() {
      var node = this._currentNode;
      while (node !== this.root) {
        node = node.parentNode;
        if (node === null) {
          return null;
        }
        if (this._internalFilter(node) === NodeFilter.FILTER_ACCEPT) {
          this._currentNode = node;
          return node;
        }
      }
      return null;
    } },

  /**
   * @spec https://dom.spec.whatwg.org/#dom-treewalker-firstchild
   * @method
   * @return {Node|null}
   */
  firstChild: { value: function firstChild() {
      return traverseChildren(this, 'first');
    } },

  /**
   * @spec https://dom.spec.whatwg.org/#dom-treewalker-lastchild
   * @method
   * @return {Node|null}
   */
  lastChild: { value: function lastChild() {
      return traverseChildren(this, 'last');
    } },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-previoussibling
   * @method
   * @return {Node|null}
   */
  previousSibling: { value: function previousSibling() {
      return traverseSiblings(this, 'previous');
    } },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-nextsibling
   * @method
   * @return {Node|null}
   */
  nextSibling: { value: function nextSibling() {
      return traverseSiblings(this, 'next');
    } },

  /**
   * @spec https://dom.spec.whatwg.org/#dom-treewalker-previousnode
   * @based on WebKit's TreeWalker::previousNode
   * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/dom/TreeWalker.cpp?rev=220453#L181
   * @method
   * @return {Node|null}
   */
  previousNode: { value: function previousNode() {
      var node, result, previousSibling, lastChild;
      node = this._currentNode;
      while (node !== this._root) {
        for (previousSibling = node.previousSibling; previousSibling; previousSibling = node.previousSibling) {
          node = previousSibling;
          result = this._internalFilter(node);
          if (result === NodeFilter.FILTER_REJECT) {
            continue;
          }
          for (lastChild = node.lastChild; lastChild; lastChild = node.lastChild) {
            node = lastChild;
            result = this._internalFilter(node);
            if (result === NodeFilter.FILTER_REJECT) {
              break;
            }
          }
          if (result === NodeFilter.FILTER_ACCEPT) {
            this._currentNode = node;
            return node;
          }
        }
        if (node === this.root || node.parentNode === null) {
          return null;
        }
        node = node.parentNode;
        if (this._internalFilter(node) === NodeFilter.FILTER_ACCEPT) {
          this._currentNode = node;
          return node;
        }
      }
      return null;
    } },

  /**
   * @spec https://dom.spec.whatwg.org/#dom-treewalker-nextnode
   * @based on WebKit's TreeWalker::nextNode
   * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/dom/TreeWalker.cpp?rev=220453#L228
   * @method
   * @return {Node|null}
   */
  nextNode: { value: function nextNode() {
      var node, result, firstChild, nextSibling;
      node = this._currentNode;
      result = NodeFilter.FILTER_ACCEPT;

      CHILDREN: while (true) {
        for (firstChild = node.firstChild; firstChild; firstChild = node.firstChild) {
          node = firstChild;
          result = this._internalFilter(node);
          if (result === NodeFilter.FILTER_ACCEPT) {
            this._currentNode = node;
            return node;
          } else if (result === NodeFilter.FILTER_REJECT) {
            break;
          }
        }
        for (nextSibling = NodeTraversal.nextSkippingChildren(node, this.root); nextSibling; nextSibling = NodeTraversal.nextSkippingChildren(node, this.root)) {
          node = nextSibling;
          result = this._internalFilter(node);
          if (result === NodeFilter.FILTER_ACCEPT) {
            this._currentNode = node;
            return node;
          } else if (result === NodeFilter.FILTER_SKIP) {
            continue CHILDREN;
          }
        }
        return null;
      }
    } },

  /** For compatibility with web-platform-tests. */
  toString: { value: function toString() {
      return "[object TreeWalker]";
    } }
});

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = NodeIterator;

var NodeFilter = __webpack_require__(13);
var NodeTraversal = __webpack_require__(46);
var utils = __webpack_require__(1);

/* Private methods and helpers */

/**
 * @based on WebKit's NodeIterator::moveToNext and NodeIterator::moveToPrevious
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeIterator.cpp?rev=186279#L51
 */
function move(node, stayWithin, directionIsNext) {
  if (directionIsNext) {
    return NodeTraversal.next(node, stayWithin);
  } else {
    if (node === stayWithin) {
      return null;
    }
    return NodeTraversal.previous(node, null);
  }
}

function isInclusiveAncestor(node, possibleChild) {
  for (; possibleChild; possibleChild = possibleChild.parentNode) {
    if (node === possibleChild) {
      return true;
    }
  }
  return false;
}

/**
 * @spec http://www.w3.org/TR/dom/#concept-nodeiterator-traverse
 * @method
 * @access private
 * @param {NodeIterator} ni
 * @param {string} direction One of 'next' or 'previous'.
 * @return {Node|null}
 */
function traverse(ni, directionIsNext) {
  var node, beforeNode;
  node = ni._referenceNode;
  beforeNode = ni._pointerBeforeReferenceNode;
  while (true) {
    if (beforeNode === directionIsNext) {
      beforeNode = !beforeNode;
    } else {
      node = move(node, ni._root, directionIsNext);
      if (node === null) {
        return null;
      }
    }
    var result = ni._internalFilter(node);
    if (result === NodeFilter.FILTER_ACCEPT) {
      break;
    }
  }
  ni._referenceNode = node;
  ni._pointerBeforeReferenceNode = beforeNode;
  return node;
}

/* Public API */

/**
 * Implemented version: http://www.w3.org/TR/2015/WD-dom-20150618/#nodeiterator
 * Latest version: http://www.w3.org/TR/dom/#nodeiterator
 *
 * @constructor
 * @param {Node} root
 * @param {number} whatToShow [optional]
 * @param {Function|NodeFilter} filter [optional]
 * @throws Error
 */
function NodeIterator(root, whatToShow, filter) {
  if (!root || !root.nodeType) {
    utils.NotSupportedError();
  }

  // Read-only properties
  this._root = root;
  this._referenceNode = root;
  this._pointerBeforeReferenceNode = true;
  this._whatToShow = Number(whatToShow) || 0;
  this._filter = filter || null;
  this._active = false;
  // Record active node iterators in the document, in order to perform
  // "node iterator pre-removal steps".
  root.doc._attachNodeIterator(this);
}

Object.defineProperties(NodeIterator.prototype, {
  root: { get: function root() {
      return this._root;
    } },
  referenceNode: { get: function referenceNode() {
      return this._referenceNode;
    } },
  pointerBeforeReferenceNode: { get: function pointerBeforeReferenceNode() {
      return this._pointerBeforeReferenceNode;
    } },
  whatToShow: { get: function whatToShow() {
      return this._whatToShow;
    } },
  filter: { get: function filter() {
      return this._filter;
    } },

  /**
   * @method
   * @param {Node} node
   * @return {Number} Constant NodeFilter.FILTER_ACCEPT,
   *  NodeFilter.FILTER_REJECT or NodeFilter.FILTER_SKIP.
   */
  _internalFilter: { value: function _internalFilter(node) {
      /* jshint bitwise: false */
      var result, filter;
      if (this._active) {
        utils.InvalidStateError();
      }

      // Maps nodeType to whatToShow
      if (!(1 << node.nodeType - 1 & this._whatToShow)) {
        return NodeFilter.FILTER_SKIP;
      }

      filter = this._filter;
      if (filter === null) {
        result = NodeFilter.FILTER_ACCEPT;
      } else {
        this._active = true;
        try {
          if (typeof filter === 'function') {
            result = filter(node);
          } else {
            result = filter.acceptNode(node);
          }
        } finally {
          this._active = false;
        }
      }

      // Note that coercing to a number means that
      //  `true` becomes `1` (which is NodeFilter.FILTER_ACCEPT)
      //  `false` becomes `0` (neither accept, reject, or skip)
      return +result;
    } },

  /**
   * @spec https://dom.spec.whatwg.org/#nodeiterator-pre-removing-steps
   * @method
   * @return void
   */
  _preremove: { value: function _preremove(toBeRemovedNode) {
      if (isInclusiveAncestor(toBeRemovedNode, this._root)) {
        return;
      }
      if (!isInclusiveAncestor(toBeRemovedNode, this._referenceNode)) {
        return;
      }
      if (this._pointerBeforeReferenceNode) {
        var next = toBeRemovedNode;
        while (next.lastChild) {
          next = next.lastChild;
        }
        next = NodeTraversal.next(next, this.root);
        if (next) {
          this._referenceNode = next;
          return;
        }
        this._pointerBeforeReferenceNode = false;
        // fall through
      }
      if (toBeRemovedNode.previousSibling === null) {
        this._referenceNode = toBeRemovedNode.parentNode;
      } else {
        this._referenceNode = toBeRemovedNode.previousSibling;
        var lastChild;
        for (lastChild = this._referenceNode.lastChild; lastChild; lastChild = this._referenceNode.lastChild) {
          this._referenceNode = lastChild;
        }
      }
    } },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-nextnode
   * @method
   * @return {Node|null}
   */
  nextNode: { value: function nextNode() {
      return traverse(this, true);
    } },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-previousnode
   * @method
   * @return {Node|null}
   */
  previousNode: { value: function previousNode() {
      return traverse(this, false);
    } },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-detach
   * @method
   * @return void
   */
  detach: { value: function detach() {
      /* "The detach() method must do nothing.
       * Its functionality (disabling a NodeIterator object) was removed,
       * but the method itself is preserved for compatibility.
       */
    } },

  /** For compatibility with web-platform-tests. */
  toString: { value: function toString() {
      return "[object NodeIterator]";
    } }
});

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = CustomEvent;

var Event = __webpack_require__(8);

function CustomEvent(type, dictionary) {
  // Just use the superclass constructor to initialize
  Event.call(this, type, dictionary);
}
CustomEvent.prototype = Object.create(Event.prototype, {
  constructor: { value: CustomEvent }
});

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* jshint node:true, latedef:false */
 // jshint ignore:line
/*!
Parser-Lib
Copyright (c) 2009-2011 Nicholas C. Zakas. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
/* Version v0.2.5+domino1, Build time: 30-January-2016 05:13:03 */

var parserlib = Object.create(null);
(function () {

    /**
     * A generic base to inherit from for any object
     * that needs event handling.
     * @class EventTarget
     * @constructor
     */
    function EventTarget() {

        /**
         * The array of listeners for various events.
         * @type Object
         * @property _listeners
         * @private
         */
        this._listeners = Object.create(null);
    }

    EventTarget.prototype = {

        //restore constructor
        constructor: EventTarget,

        /**
         * Adds a listener for a given event type.
         * @param {String} type The type of event to add a listener for.
         * @param {Function} listener The function to call when the event occurs.
         * @return {void}
         * @method addListener
         */
        addListener: function addListener(type, listener) {
            if (!this._listeners[type]) {
                this._listeners[type] = [];
            }

            this._listeners[type].push(listener);
        },

        /**
         * Fires an event based on the passed-in object.
         * @param {Object|String} event An object with at least a 'type' attribute
         *      or a string indicating the event name.
         * @return {void}
         * @method fire
         */
        fire: function fire(event) {
            if (typeof event === "string") {
                event = { type: event };
            }
            if (typeof event.target !== "undefined") {
                event.target = this;
            }

            if (typeof event.type === "undefined") {
                throw new Error("Event object missing 'type' property.");
            }

            if (this._listeners[event.type]) {

                //create a copy of the array and use that so listeners can't chane
                var listeners = this._listeners[event.type].concat();
                for (var i = 0, len = listeners.length; i < len; i++) {
                    listeners[i].call(this, event);
                }
            }
        },

        /**
         * Removes a listener for a given event type.
         * @param {String} type The type of event to remove a listener from.
         * @param {Function} listener The function to remove from the event.
         * @return {void}
         * @method removeListener
         */
        removeListener: function removeListener(type, listener) {
            if (this._listeners[type]) {
                var listeners = this._listeners[type];
                for (var i = 0, len = listeners.length; i < len; i++) {
                    if (listeners[i] === listener) {
                        listeners.splice(i, 1);
                        break;
                    }
                }
            }
        }
    };
    /**
     * Convenient way to read through strings.
     * @namespace parserlib.util
     * @class StringReader
     * @constructor
     * @param {String} text The text to read.
     */
    function StringReader(text) {

        /**
         * The input text with line endings normalized.
         * @property _input
         * @type String
         * @private
         */
        this._input = text.replace(/(\r|\n){1,2}/g, "\n");

        /**
         * The row for the character to be read next.
         * @property _line
         * @type int
         * @private
         */
        this._line = 1;

        /**
         * The column for the character to be read next.
         * @property _col
         * @type int
         * @private
         */
        this._col = 1;

        /**
         * The index of the character in the input to be read next.
         * @property _cursor
         * @type int
         * @private
         */
        this._cursor = 0;
    }

    StringReader.prototype = {

        //restore constructor
        constructor: StringReader,

        //-------------------------------------------------------------------------
        // Position info
        //-------------------------------------------------------------------------

        /**
         * Returns the column of the character to be read next.
         * @return {int} The column of the character to be read next.
         * @method getCol
         */
        getCol: function getCol() {
            return this._col;
        },

        /**
         * Returns the row of the character to be read next.
         * @return {int} The row of the character to be read next.
         * @method getLine
         */
        getLine: function getLine() {
            return this._line;
        },

        /**
         * Determines if you're at the end of the input.
         * @return {Boolean} True if there's no more input, false otherwise.
         * @method eof
         */
        eof: function eof() {
            return this._cursor === this._input.length;
        },

        //-------------------------------------------------------------------------
        // Basic reading
        //-------------------------------------------------------------------------

        /**
         * Reads the next character without advancing the cursor.
         * @param {int} count How many characters to look ahead (default is 1).
         * @return {String} The next character or null if there is no next character.
         * @method peek
         */
        peek: function peek(count) {
            var c = null;
            count = typeof count === "undefined" ? 1 : count;

            //if we're not at the end of the input...
            if (this._cursor < this._input.length) {

                //get character and increment cursor and column
                c = this._input.charAt(this._cursor + count - 1);
            }

            return c;
        },

        /**
         * Reads the next character from the input and adjusts the row and column
         * accordingly.
         * @return {String} The next character or null if there is no next character.
         * @method read
         */
        read: function read() {
            var c = null;

            //if we're not at the end of the input...
            if (this._cursor < this._input.length) {

                //if the last character was a newline, increment row count
                //and reset column count
                if (this._input.charAt(this._cursor) === "\n") {
                    this._line++;
                    this._col = 1;
                } else {
                    this._col++;
                }

                //get character and increment cursor and column
                c = this._input.charAt(this._cursor++);
            }

            return c;
        },

        //-------------------------------------------------------------------------
        // Misc
        //-------------------------------------------------------------------------

        /**
         * Saves the current location so it can be returned to later.
         * @method mark
         * @return {void}
         */
        mark: function mark() {
            this._bookmark = {
                cursor: this._cursor,
                line: this._line,
                col: this._col
            };
        },

        reset: function reset() {
            if (this._bookmark) {
                this._cursor = this._bookmark.cursor;
                this._line = this._bookmark.line;
                this._col = this._bookmark.col;
                delete this._bookmark;
            }
        },

        //-------------------------------------------------------------------------
        // Advanced reading
        //-------------------------------------------------------------------------

        /**
         * Reads up to and including the given string. Throws an error if that
         * string is not found.
         * @param {String} pattern The string to read.
         * @return {String} The string when it is found.
         * @throws Error when the string pattern is not found.
         * @method readTo
         */
        readTo: function readTo(pattern) {

            var buffer = "",
                c;

            /*
             * First, buffer must be the same length as the pattern.
             * Then, buffer must end with the pattern or else reach the
             * end of the input.
             */
            while (buffer.length < pattern.length || buffer.lastIndexOf(pattern) !== buffer.length - pattern.length) {
                c = this.read();
                if (c) {
                    buffer += c;
                } else {
                    throw new Error("Expected \"" + pattern + "\" at line " + this._line + ", col " + this._col + ".");
                }
            }

            return buffer;
        },

        /**
         * Reads characters while each character causes the given
         * filter function to return true. The function is passed
         * in each character and either returns true to continue
         * reading or false to stop.
         * @param {Function} filter The function to read on each character.
         * @return {String} The string made up of all characters that passed the
         *      filter check.
         * @method readWhile
         */
        readWhile: function readWhile(filter) {

            var buffer = "",
                c = this.read();

            while (c !== null && filter(c)) {
                buffer += c;
                c = this.read();
            }

            return buffer;
        },

        /**
         * Reads characters that match either text or a regular expression and
         * returns those characters. If a match is found, the row and column
         * are adjusted; if no match is found, the reader's state is unchanged.
         * reading or false to stop.
         * @param {String|RegExp} matchter If a string, then the literal string
         *      value is searched for. If a regular expression, then any string
         *      matching the pattern is search for.
         * @return {String} The string made up of all characters that matched or
         *      null if there was no match.
         * @method readMatch
         */
        readMatch: function readMatch(matcher) {

            var source = this._input.substring(this._cursor),
                value = null;

            //if it's a string, just do a straight match
            if (typeof matcher === "string") {
                if (source.indexOf(matcher) === 0) {
                    value = this.readCount(matcher.length);
                }
            } else if (matcher instanceof RegExp) {
                if (matcher.test(source)) {
                    value = this.readCount(RegExp.lastMatch.length);
                }
            }

            return value;
        },

        /**
         * Reads a given number of characters. If the end of the input is reached,
         * it reads only the remaining characters and does not throw an error.
         * @param {int} count The number of characters to read.
         * @return {String} The string made up the read characters.
         * @method readCount
         */
        readCount: function readCount(count) {
            var buffer = "";

            while (count--) {
                buffer += this.read();
            }

            return buffer;
        }

    };
    /**
     * Type to use when a syntax error occurs.
     * @class SyntaxError
     * @namespace parserlib.util
     * @constructor
     * @param {String} message The error message.
     * @param {int} line The line at which the error occurred.
     * @param {int} col The column at which the error occurred.
     */
    function SyntaxError(message, line, col) {
        Error.call(this);
        this.name = this.constructor.name;

        /**
         * The column at which the error occurred.
         * @type int
         * @property col
         */
        this.col = col;

        /**
         * The line at which the error occurred.
         * @type int
         * @property line
         */
        this.line = line;

        /**
         * The text representation of the unit.
         * @type String
         * @property text
         */
        this.message = message;
    }

    //inherit from Error
    SyntaxError.prototype = Object.create(Error.prototype); // jshint ignore:line
    SyntaxError.prototype.constructor = SyntaxError; // jshint ignore:line
    /**
     * Base type to represent a single syntactic unit.
     * @class SyntaxUnit
     * @namespace parserlib.util
     * @constructor
     * @param {String} text The text of the unit.
     * @param {int} line The line of text on which the unit resides.
     * @param {int} col The column of text on which the unit resides.
     */
    function SyntaxUnit(text, line, col, type) {

        /**
         * The column of text on which the unit resides.
         * @type int
         * @property col
         */
        this.col = col;

        /**
         * The line of text on which the unit resides.
         * @type int
         * @property line
         */
        this.line = line;

        /**
         * The text representation of the unit.
         * @type String
         * @property text
         */
        this.text = text;

        /**
         * The type of syntax unit.
         * @type int
         * @property type
         */
        this.type = type;
    }

    /**
     * Create a new syntax unit based solely on the given token.
     * Convenience method for creating a new syntax unit when
     * it represents a single token instead of multiple.
     * @param {Object} token The token object to represent.
     * @return {parserlib.util.SyntaxUnit} The object representing the token.
     * @static
     * @method fromToken
     */
    SyntaxUnit.fromToken = function (token) {
        return new SyntaxUnit(token.value, token.startLine, token.startCol);
    };

    SyntaxUnit.prototype = {

        //restore constructor
        constructor: SyntaxUnit,

        /**
         * Returns the text representation of the unit.
         * @return {String} The text representation of the unit.
         * @method valueOf
         */
        valueOf: function valueOf() {
            return this.toString();
        },

        /**
         * Returns the text representation of the unit.
         * @return {String} The text representation of the unit.
         * @method toString
         */
        toString: function toString() {
            return this.text;
        }

    };

    /**
     * Generic TokenStream providing base functionality.
     * @class TokenStreamBase
     * @namespace parserlib.util
     * @constructor
     * @param {String|StringReader} input The text to tokenize or a reader from
     *      which to read the input.
     */
    function TokenStreamBase(input, tokenData) {

        /**
         * The string reader for easy access to the text.
         * @type StringReader
         * @property _reader
         * @private
         */
        this._reader = input ? new StringReader(input.toString()) : null;

        /**
         * Token object for the last consumed token.
         * @type Token
         * @property _token
         * @private
         */
        this._token = null;

        /**
         * The array of token information.
         * @type Array
         * @property _tokenData
         * @private
         */
        this._tokenData = tokenData;

        /**
         * Lookahead token buffer.
         * @type Array
         * @property _lt
         * @private
         */
        this._lt = [];

        /**
         * Lookahead token buffer index.
         * @type int
         * @property _ltIndex
         * @private
         */
        this._ltIndex = 0;

        this._ltIndexCache = [];
    }

    /**
     * Accepts an array of token information and outputs
     * an array of token data containing key-value mappings
     * and matching functions that the TokenStream needs.
     * @param {Array} tokens An array of token descriptors.
     * @return {Array} An array of processed token data.
     * @method createTokenData
     * @static
     */
    TokenStreamBase.createTokenData = function (tokens) {

        var nameMap = [],
            typeMap = Object.create(null),
            tokenData = tokens.concat([]),
            i = 0,
            len = tokenData.length + 1;

        tokenData.UNKNOWN = -1;
        tokenData.unshift({ name: "EOF" });

        for (; i < len; i++) {
            nameMap.push(tokenData[i].name);
            tokenData[tokenData[i].name] = i;
            if (tokenData[i].text) {
                typeMap[tokenData[i].text] = i;
            }
        }

        tokenData.name = function (tt) {
            return nameMap[tt];
        };

        tokenData.type = function (c) {
            return typeMap[c];
        };

        return tokenData;
    };

    TokenStreamBase.prototype = {

        //restore constructor
        constructor: TokenStreamBase,

        //-------------------------------------------------------------------------
        // Matching methods
        //-------------------------------------------------------------------------

        /**
         * Determines if the next token matches the given token type.
         * If so, that token is consumed; if not, the token is placed
         * back onto the token stream. You can pass in any number of
         * token types and this will return true if any of the token
         * types is found.
         * @param {int|int[]} tokenTypes Either a single token type or an array of
         *      token types that the next token might be. If an array is passed,
         *      it's assumed that the token can be any of these.
         * @param {variant} channel (Optional) The channel to read from. If not
         *      provided, reads from the default (unnamed) channel.
         * @return {Boolean} True if the token type matches, false if not.
         * @method match
         */
        match: function match(tokenTypes, channel) {

            //always convert to an array, makes things easier
            if (!(tokenTypes instanceof Array)) {
                tokenTypes = [tokenTypes];
            }

            var tt = this.get(channel),
                i = 0,
                len = tokenTypes.length;

            while (i < len) {
                if (tt === tokenTypes[i++]) {
                    return true;
                }
            }

            //no match found, put the token back
            this.unget();
            return false;
        },

        /**
         * Determines if the next token matches the given token type.
         * If so, that token is consumed; if not, an error is thrown.
         * @param {int|int[]} tokenTypes Either a single token type or an array of
         *      token types that the next token should be. If an array is passed,
         *      it's assumed that the token must be one of these.
         * @param {variant} channel (Optional) The channel to read from. If not
         *      provided, reads from the default (unnamed) channel.
         * @return {void}
         * @method mustMatch
         */
        mustMatch: function mustMatch(tokenTypes, channel) {

            var token;

            //always convert to an array, makes things easier
            if (!(tokenTypes instanceof Array)) {
                tokenTypes = [tokenTypes];
            }

            if (!this.match.apply(this, arguments)) {
                token = this.LT(1);
                throw new SyntaxError("Expected " + this._tokenData[tokenTypes[0]].name + " at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
            }
        },

        //-------------------------------------------------------------------------
        // Consuming methods
        //-------------------------------------------------------------------------

        /**
         * Keeps reading from the token stream until either one of the specified
         * token types is found or until the end of the input is reached.
         * @param {int|int[]} tokenTypes Either a single token type or an array of
         *      token types that the next token should be. If an array is passed,
         *      it's assumed that the token must be one of these.
         * @param {variant} channel (Optional) The channel to read from. If not
         *      provided, reads from the default (unnamed) channel.
         * @return {void}
         * @method advance
         */
        advance: function advance(tokenTypes, channel) {

            while (this.LA(0) !== 0 && !this.match(tokenTypes, channel)) {
                this.get();
            }

            return this.LA(0);
        },

        /**
         * Consumes the next token from the token stream.
         * @return {int} The token type of the token that was just consumed.
         * @method get
         */
        get: function get(channel) {

            var tokenInfo = this._tokenData,
                i = 0,
                token,
                info;

            //check the lookahead buffer first
            if (this._lt.length && this._ltIndex >= 0 && this._ltIndex < this._lt.length) {

                i++;
                this._token = this._lt[this._ltIndex++];
                info = tokenInfo[this._token.type];

                //obey channels logic
                while (info.channel !== undefined && channel !== info.channel && this._ltIndex < this._lt.length) {
                    this._token = this._lt[this._ltIndex++];
                    info = tokenInfo[this._token.type];
                    i++;
                }

                //here be dragons
                if ((info.channel === undefined || channel === info.channel) && this._ltIndex <= this._lt.length) {
                    this._ltIndexCache.push(i);
                    return this._token.type;
                }
            }

            //call token retriever method
            token = this._getToken();

            //if it should be hidden, don't save a token
            if (token.type > -1 && !tokenInfo[token.type].hide) {

                //apply token channel
                token.channel = tokenInfo[token.type].channel;

                //save for later
                this._token = token;
                this._lt.push(token);

                //save space that will be moved (must be done before array is truncated)
                this._ltIndexCache.push(this._lt.length - this._ltIndex + i);

                //keep the buffer under 5 items
                if (this._lt.length > 5) {
                    this._lt.shift();
                }

                //also keep the shift buffer under 5 items
                if (this._ltIndexCache.length > 5) {
                    this._ltIndexCache.shift();
                }

                //update lookahead index
                this._ltIndex = this._lt.length;
            }

            /*
             * Skip to the next token if:
             * 1. The token type is marked as hidden.
             * 2. The token type has a channel specified and it isn't the current channel.
             */
            info = tokenInfo[token.type];
            if (info && (info.hide || info.channel !== undefined && channel !== info.channel)) {
                return this.get(channel);
            } else {
                //return just the type
                return token.type;
            }
        },

        /**
         * Looks ahead a certain number of tokens and returns the token type at
         * that position. This will throw an error if you lookahead past the
         * end of input, past the size of the lookahead buffer, or back past
         * the first token in the lookahead buffer.
         * @param {int} The index of the token type to retrieve. 0 for the
         *      current token, 1 for the next, -1 for the previous, etc.
         * @return {int} The token type of the token in the given position.
         * @method LA
         */
        LA: function LA(index) {
            var total = index,
                tt;
            if (index > 0) {
                //TODO: Store 5 somewhere
                if (index > 5) {
                    throw new Error("Too much lookahead.");
                }

                //get all those tokens
                while (total) {
                    tt = this.get();
                    total--;
                }

                //unget all those tokens
                while (total < index) {
                    this.unget();
                    total++;
                }
            } else if (index < 0) {

                if (this._lt[this._ltIndex + index]) {
                    tt = this._lt[this._ltIndex + index].type;
                } else {
                    throw new Error("Too much lookbehind.");
                }
            } else {
                tt = this._token.type;
            }

            return tt;
        },

        /**
         * Looks ahead a certain number of tokens and returns the token at
         * that position. This will throw an error if you lookahead past the
         * end of input, past the size of the lookahead buffer, or back past
         * the first token in the lookahead buffer.
         * @param {int} The index of the token type to retrieve. 0 for the
         *      current token, 1 for the next, -1 for the previous, etc.
         * @return {Object} The token of the token in the given position.
         * @method LA
         */
        LT: function LT(index) {

            //lookahead first to prime the token buffer
            this.LA(index);

            //now find the token, subtract one because _ltIndex is already at the next index
            return this._lt[this._ltIndex + index - 1];
        },

        /**
         * Returns the token type for the next token in the stream without
         * consuming it.
         * @return {int} The token type of the next token in the stream.
         * @method peek
         */
        peek: function peek() {
            return this.LA(1);
        },

        /**
         * Returns the actual token object for the last consumed token.
         * @return {Token} The token object for the last consumed token.
         * @method token
         */
        token: function token() {
            return this._token;
        },

        /**
         * Returns the name of the token for the given token type.
         * @param {int} tokenType The type of token to get the name of.
         * @return {String} The name of the token or "UNKNOWN_TOKEN" for any
         *      invalid token type.
         * @method tokenName
         */
        tokenName: function tokenName(tokenType) {
            if (tokenType < 0 || tokenType > this._tokenData.length) {
                return "UNKNOWN_TOKEN";
            } else {
                return this._tokenData[tokenType].name;
            }
        },

        /**
         * Returns the token type value for the given token name.
         * @param {String} tokenName The name of the token whose value should be returned.
         * @return {int} The token type value for the given token name or -1
         *      for an unknown token.
         * @method tokenName
         */
        tokenType: function tokenType(tokenName) {
            return this._tokenData[tokenName] || -1;
        },

        /**
         * Returns the last consumed token to the token stream.
         * @method unget
         */
        unget: function unget() {
            //if (this._ltIndex > -1){
            if (this._ltIndexCache.length) {
                this._ltIndex -= this._ltIndexCache.pop(); //--;
                this._token = this._lt[this._ltIndex - 1];
            } else {
                throw new Error("Too much lookahead.");
            }
        }

    };

    parserlib.util = {
        __proto__: null,
        StringReader: StringReader,
        SyntaxError: SyntaxError,
        SyntaxUnit: SyntaxUnit,
        EventTarget: EventTarget,
        TokenStreamBase: TokenStreamBase
    };
})();
/*
Parser-Lib
Copyright (c) 2009-2011 Nicholas C. Zakas. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
/* Version v0.2.5+domino1, Build time: 30-January-2016 05:13:03 */
(function () {
    var EventTarget = parserlib.util.EventTarget,
        TokenStreamBase = parserlib.util.TokenStreamBase,
        StringReader = parserlib.util.StringReader,
        // jshint ignore:line
    SyntaxError = parserlib.util.SyntaxError,
        SyntaxUnit = parserlib.util.SyntaxUnit;

    var Colors = {
        __proto__: null,
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgrey: "#a9a9a9",
        darkgreen: "#006400",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gray: "#808080",
        grey: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavender: "#e6e6fa",
        lavenderblush: "#fff0f5",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgrey: "#d3d3d3",
        lightgreen: "#90ee90",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370d8",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#d87093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32",
        //'currentColor' color keyword http://www.w3.org/TR/css3-color/#currentcolor
        currentColor: "The value of the 'color' property.",
        //CSS2 system colors http://www.w3.org/TR/css3-color/#css2-system
        activeBorder: "Active window border.",
        activecaption: "Active window caption.",
        appworkspace: "Background color of multiple document interface.",
        background: "Desktop background.",
        buttonface: "The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.",
        buttonhighlight: "The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
        buttonshadow: "The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
        buttontext: "Text on push buttons.",
        captiontext: "Text in caption, size box, and scrollbar arrow box.",
        graytext: "Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.",
        greytext: "Greyed (disabled) text. This color is set to #000 if the current display driver does not support a solid grey color.",
        highlight: "Item(s) selected in a control.",
        highlighttext: "Text of item(s) selected in a control.",
        inactiveborder: "Inactive window border.",
        inactivecaption: "Inactive window caption.",
        inactivecaptiontext: "Color of text in an inactive caption.",
        infobackground: "Background color for tooltip controls.",
        infotext: "Text color for tooltip controls.",
        menu: "Menu background.",
        menutext: "Text in menus.",
        scrollbar: "Scroll bar gray area.",
        threeddarkshadow: "The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
        threedface: "The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
        threedhighlight: "The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
        threedlightshadow: "The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
        threedshadow: "The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
        window: "Window background.",
        windowframe: "Window frame.",
        windowtext: "Text in windows."
    };
    /**
     * Represents a selector combinator (whitespace, +, >).
     * @namespace parserlib.css
     * @class Combinator
     * @extends parserlib.util.SyntaxUnit
     * @constructor
     * @param {String} text The text representation of the unit.
     * @param {int} line The line of text on which the unit resides.
     * @param {int} col The column of text on which the unit resides.
     */
    function Combinator(text, line, col) {

        SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);

        /**
         * The type of modifier.
         * @type String
         * @property type
         */
        this.type = "unknown";

        //pretty simple
        if (/^\s+$/.test(text)) {
            this.type = "descendant";
        } else if (text === ">") {
            this.type = "child";
        } else if (text === "+") {
            this.type = "adjacent-sibling";
        } else if (text === "~") {
            this.type = "sibling";
        }
    }

    Combinator.prototype = new SyntaxUnit();
    Combinator.prototype.constructor = Combinator;

    /**
     * Represents a media feature, such as max-width:500.
     * @namespace parserlib.css
     * @class MediaFeature
     * @extends parserlib.util.SyntaxUnit
     * @constructor
     * @param {SyntaxUnit} name The name of the feature.
     * @param {SyntaxUnit} value The value of the feature or null if none.
     */
    function MediaFeature(name, value) {

        SyntaxUnit.call(this, "(" + name + (value !== null ? ":" + value : "") + ")", name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE);

        /**
         * The name of the media feature
         * @type String
         * @property name
         */
        this.name = name;

        /**
         * The value for the feature or null if there is none.
         * @type SyntaxUnit
         * @property value
         */
        this.value = value;
    }

    MediaFeature.prototype = new SyntaxUnit();
    MediaFeature.prototype.constructor = MediaFeature;

    /**
     * Represents an individual media query.
     * @namespace parserlib.css
     * @class MediaQuery
     * @extends parserlib.util.SyntaxUnit
     * @constructor
     * @param {String} modifier The modifier "not" or "only" (or null).
     * @param {String} mediaType The type of media (i.e., "print").
     * @param {Array} parts Array of selectors parts making up this selector.
     * @param {int} line The line of text on which the unit resides.
     * @param {int} col The column of text on which the unit resides.
     */
    function MediaQuery(modifier, mediaType, features, line, col) {

        SyntaxUnit.call(this, (modifier ? modifier + " " : "") + (mediaType ? mediaType : "") + (mediaType && features.length > 0 ? " and " : "") + features.join(" and "), line, col, Parser.MEDIA_QUERY_TYPE);

        /**
         * The media modifier ("not" or "only")
         * @type String
         * @property modifier
         */
        this.modifier = modifier;

        /**
         * The mediaType (i.e., "print")
         * @type String
         * @property mediaType
         */
        this.mediaType = mediaType;

        /**
         * The parts that make up the selector.
         * @type Array
         * @property features
         */
        this.features = features;
    }

    MediaQuery.prototype = new SyntaxUnit();
    MediaQuery.prototype.constructor = MediaQuery;

    /**
     * A CSS3 parser.
     * @namespace parserlib.css
     * @class Parser
     * @constructor
     * @param {Object} options (Optional) Various options for the parser:
     *      starHack (true|false) to allow IE6 star hack as valid,
     *      underscoreHack (true|false) to interpret leading underscores
     *      as IE6-7 targeting for known properties, ieFilters (true|false)
     *      to indicate that IE < 8 filters should be accepted and not throw
     *      syntax errors.
     */
    function Parser(options) {

        //inherit event functionality
        EventTarget.call(this);

        this.options = options || {};

        this._tokenStream = null;
    }

    //Static constants
    Parser.DEFAULT_TYPE = 0;
    Parser.COMBINATOR_TYPE = 1;
    Parser.MEDIA_FEATURE_TYPE = 2;
    Parser.MEDIA_QUERY_TYPE = 3;
    Parser.PROPERTY_NAME_TYPE = 4;
    Parser.PROPERTY_VALUE_TYPE = 5;
    Parser.PROPERTY_VALUE_PART_TYPE = 6;
    Parser.SELECTOR_TYPE = 7;
    Parser.SELECTOR_PART_TYPE = 8;
    Parser.SELECTOR_SUB_PART_TYPE = 9;

    Parser.prototype = function () {

        var proto = new EventTarget(),
            //new prototype
        prop,
            additions = {
            __proto__: null,

            //restore constructor
            constructor: Parser,

            //instance constants - yuck
            DEFAULT_TYPE: 0,
            COMBINATOR_TYPE: 1,
            MEDIA_FEATURE_TYPE: 2,
            MEDIA_QUERY_TYPE: 3,
            PROPERTY_NAME_TYPE: 4,
            PROPERTY_VALUE_TYPE: 5,
            PROPERTY_VALUE_PART_TYPE: 6,
            SELECTOR_TYPE: 7,
            SELECTOR_PART_TYPE: 8,
            SELECTOR_SUB_PART_TYPE: 9,

            //-----------------------------------------------------------------
            // Grammar
            //-----------------------------------------------------------------

            _stylesheet: function _stylesheet() {

                /*
                 * stylesheet
                 *  : [ CHARSET_SYM S* STRING S* ';' ]?
                 *    [S|CDO|CDC]* [ import [S|CDO|CDC]* ]*
                 *    [ namespace [S|CDO|CDC]* ]*
                 *    [ [ ruleset | media | page | font_face | keyframes ] [S|CDO|CDC]* ]*
                 *  ;
                 */

                var tokenStream = this._tokenStream,
                    count,
                    token,
                    tt;

                this.fire("startstylesheet");

                //try to read character set
                this._charset();

                this._skipCruft();

                //try to read imports - may be more than one
                while (tokenStream.peek() === Tokens.IMPORT_SYM) {
                    this._import();
                    this._skipCruft();
                }

                //try to read namespaces - may be more than one
                while (tokenStream.peek() === Tokens.NAMESPACE_SYM) {
                    this._namespace();
                    this._skipCruft();
                }

                //get the next token
                tt = tokenStream.peek();

                //try to read the rest
                while (tt > Tokens.EOF) {

                    try {

                        switch (tt) {
                            case Tokens.MEDIA_SYM:
                                this._media();
                                this._skipCruft();
                                break;
                            case Tokens.PAGE_SYM:
                                this._page();
                                this._skipCruft();
                                break;
                            case Tokens.FONT_FACE_SYM:
                                this._font_face();
                                this._skipCruft();
                                break;
                            case Tokens.KEYFRAMES_SYM:
                                this._keyframes();
                                this._skipCruft();
                                break;
                            case Tokens.VIEWPORT_SYM:
                                this._viewport();
                                this._skipCruft();
                                break;
                            case Tokens.DOCUMENT_SYM:
                                this._document();
                                this._skipCruft();
                                break;
                            case Tokens.UNKNOWN_SYM:
                                //unknown @ rule
                                tokenStream.get();
                                if (!this.options.strict) {

                                    //fire error event
                                    this.fire({
                                        type: "error",
                                        error: null,
                                        message: "Unknown @ rule: " + tokenStream.LT(0).value + ".",
                                        line: tokenStream.LT(0).startLine,
                                        col: tokenStream.LT(0).startCol
                                    });

                                    //skip braces
                                    count = 0;
                                    while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) === Tokens.LBRACE) {
                                        count++; //keep track of nesting depth
                                    }

                                    while (count) {
                                        tokenStream.advance([Tokens.RBRACE]);
                                        count--;
                                    }
                                } else {
                                    //not a syntax error, rethrow it
                                    throw new SyntaxError("Unknown @ rule.", tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);
                                }
                                break;
                            case Tokens.S:
                                this._readWhitespace();
                                break;
                            default:
                                if (!this._ruleset()) {

                                    //error handling for known issues
                                    switch (tt) {
                                        case Tokens.CHARSET_SYM:
                                            token = tokenStream.LT(1);
                                            this._charset(false);
                                            throw new SyntaxError("@charset not allowed here.", token.startLine, token.startCol);
                                        case Tokens.IMPORT_SYM:
                                            token = tokenStream.LT(1);
                                            this._import(false);
                                            throw new SyntaxError("@import not allowed here.", token.startLine, token.startCol);
                                        case Tokens.NAMESPACE_SYM:
                                            token = tokenStream.LT(1);
                                            this._namespace(false);
                                            throw new SyntaxError("@namespace not allowed here.", token.startLine, token.startCol);
                                        default:
                                            tokenStream.get(); //get the last token
                                            this._unexpectedToken(tokenStream.token());
                                    }
                                }
                        }
                    } catch (ex) {
                        if (ex instanceof SyntaxError && !this.options.strict) {
                            this.fire({
                                type: "error",
                                error: ex,
                                message: ex.message,
                                line: ex.line,
                                col: ex.col
                            });
                        } else {
                            throw ex;
                        }
                    }

                    tt = tokenStream.peek();
                }

                if (tt !== Tokens.EOF) {
                    this._unexpectedToken(tokenStream.token());
                }

                this.fire("endstylesheet");
            },

            _charset: function _charset(emit) {
                var tokenStream = this._tokenStream,
                    charset,
                    token,
                    line,
                    col;

                if (tokenStream.match(Tokens.CHARSET_SYM)) {
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.STRING);

                    token = tokenStream.token();
                    charset = token.value;

                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.SEMICOLON);

                    if (emit !== false) {
                        this.fire({
                            type: "charset",
                            charset: charset,
                            line: line,
                            col: col
                        });
                    }
                }
            },

            _import: function _import(emit) {
                /*
                 * import
                 *   : IMPORT_SYM S*
                 *    [STRING|URI] S* media_query_list? ';' S*
                 */

                var tokenStream = this._tokenStream,
                    uri,
                    importToken,
                    mediaList = [];

                //read import symbol
                tokenStream.mustMatch(Tokens.IMPORT_SYM);
                importToken = tokenStream.token();
                this._readWhitespace();

                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);

                //grab the URI value
                uri = tokenStream.token().value.replace(/^(?:url\()?["']?([^"']+?)["']?\)?$/, "$1");

                this._readWhitespace();

                mediaList = this._media_query_list();

                //must end with a semicolon
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();

                if (emit !== false) {
                    this.fire({
                        type: "import",
                        uri: uri,
                        media: mediaList,
                        line: importToken.startLine,
                        col: importToken.startCol
                    });
                }
            },

            _namespace: function _namespace(emit) {
                /*
                 * namespace
                 *   : NAMESPACE_SYM S* [namespace_prefix S*]? [STRING|URI] S* ';' S*
                 */

                var tokenStream = this._tokenStream,
                    line,
                    col,
                    prefix,
                    uri;

                //read import symbol
                tokenStream.mustMatch(Tokens.NAMESPACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
                this._readWhitespace();

                //it's a namespace prefix - no _namespace_prefix() method because it's just an IDENT
                if (tokenStream.match(Tokens.IDENT)) {
                    prefix = tokenStream.token().value;
                    this._readWhitespace();
                }

                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
                /*if (!tokenStream.match(Tokens.STRING)){
                    tokenStream.mustMatch(Tokens.URI);
                }*/

                //grab the URI value
                uri = tokenStream.token().value.replace(/(?:url\()?["']([^"']+)["']\)?/, "$1");

                this._readWhitespace();

                //must end with a semicolon
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();

                if (emit !== false) {
                    this.fire({
                        type: "namespace",
                        prefix: prefix,
                        uri: uri,
                        line: line,
                        col: col
                    });
                }
            },

            _media: function _media() {
                /*
                 * media
                 *   : MEDIA_SYM S* media_query_list S* '{' S* ruleset* '}' S*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    mediaList; //       = [];

                //look for @media
                tokenStream.mustMatch(Tokens.MEDIA_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                mediaList = this._media_query_list();

                tokenStream.mustMatch(Tokens.LBRACE);
                this._readWhitespace();

                this.fire({
                    type: "startmedia",
                    media: mediaList,
                    line: line,
                    col: col
                });

                while (true) {
                    if (tokenStream.peek() === Tokens.PAGE_SYM) {
                        this._page();
                    } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM) {
                        this._font_face();
                    } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM) {
                        this._viewport();
                    } else if (tokenStream.peek() === Tokens.DOCUMENT_SYM) {
                        this._document();
                    } else if (!this._ruleset()) {
                        break;
                    }
                }

                tokenStream.mustMatch(Tokens.RBRACE);
                this._readWhitespace();

                this.fire({
                    type: "endmedia",
                    media: mediaList,
                    line: line,
                    col: col
                });
            },

            //CSS3 Media Queries
            _media_query_list: function _media_query_list() {
                /*
                 * media_query_list
                 *   : S* [media_query [ ',' S* media_query ]* ]?
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    mediaList = [];

                this._readWhitespace();

                if (tokenStream.peek() === Tokens.IDENT || tokenStream.peek() === Tokens.LPAREN) {
                    mediaList.push(this._media_query());
                }

                while (tokenStream.match(Tokens.COMMA)) {
                    this._readWhitespace();
                    mediaList.push(this._media_query());
                }

                return mediaList;
            },

            /*
             * Note: "expression" in the grammar maps to the _media_expression
             * method.
              */
            _media_query: function _media_query() {
                /*
                 * media_query
                 *   : [ONLY | NOT]? S* media_type S* [ AND S* expression ]*
                 *   | expression [ AND S* expression ]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    type = null,
                    ident = null,
                    token = null,
                    expressions = [];

                if (tokenStream.match(Tokens.IDENT)) {
                    ident = tokenStream.token().value.toLowerCase();

                    //since there's no custom tokens for these, need to manually check
                    if (ident !== "only" && ident !== "not") {
                        tokenStream.unget();
                        ident = null;
                    } else {
                        token = tokenStream.token();
                    }
                }

                this._readWhitespace();

                if (tokenStream.peek() === Tokens.IDENT) {
                    type = this._media_type();
                    if (token === null) {
                        token = tokenStream.token();
                    }
                } else if (tokenStream.peek() === Tokens.LPAREN) {
                    if (token === null) {
                        token = tokenStream.LT(1);
                    }
                    expressions.push(this._media_expression());
                }

                if (type === null && expressions.length === 0) {
                    return null;
                } else {
                    this._readWhitespace();
                    while (tokenStream.match(Tokens.IDENT)) {
                        if (tokenStream.token().value.toLowerCase() !== "and") {
                            this._unexpectedToken(tokenStream.token());
                        }

                        this._readWhitespace();
                        expressions.push(this._media_expression());
                    }
                }

                return new MediaQuery(ident, type, expressions, token.startLine, token.startCol);
            },

            //CSS3 Media Queries
            _media_type: function _media_type() {
                /*
                 * media_type
                 *   : IDENT
                 *   ;
                 */
                return this._media_feature();
            },

            /**
             * Note: in CSS3 Media Queries, this is called "expression".
             * Renamed here to avoid conflict with CSS3 Selectors
             * definition of "expression". Also note that "expr" in the
             * grammar now maps to "expression" from CSS3 selectors.
             * @method _media_expression
             * @private
             */
            _media_expression: function _media_expression() {
                /*
                 * expression
                 *  : '(' S* media_feature S* [ ':' S* expr ]? ')' S*
                 *  ;
                 */
                var tokenStream = this._tokenStream,
                    feature = null,
                    token,
                    expression = null;

                tokenStream.mustMatch(Tokens.LPAREN);

                feature = this._media_feature();
                this._readWhitespace();

                if (tokenStream.match(Tokens.COLON)) {
                    this._readWhitespace();
                    token = tokenStream.LT(1);
                    expression = this._expression();
                }

                tokenStream.mustMatch(Tokens.RPAREN);
                this._readWhitespace();

                return new MediaFeature(feature, expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null);
            },

            //CSS3 Media Queries
            _media_feature: function _media_feature() {
                /*
                 * media_feature
                 *   : IDENT
                 *   ;
                 */
                var tokenStream = this._tokenStream;

                this._readWhitespace();

                tokenStream.mustMatch(Tokens.IDENT);

                return SyntaxUnit.fromToken(tokenStream.token());
            },

            //CSS3 Paged Media
            _page: function _page() {
                /*
                 * page:
                 *    PAGE_SYM S* IDENT? pseudo_page? S*
                 *    '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*
                 *    ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    identifier = null,
                    pseudoPage = null;

                //look for @page
                tokenStream.mustMatch(Tokens.PAGE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                if (tokenStream.match(Tokens.IDENT)) {
                    identifier = tokenStream.token().value;

                    //The value 'auto' may not be used as a page name and MUST be treated as a syntax error.
                    if (identifier.toLowerCase() === "auto") {
                        this._unexpectedToken(tokenStream.token());
                    }
                }

                //see if there's a colon upcoming
                if (tokenStream.peek() === Tokens.COLON) {
                    pseudoPage = this._pseudo_page();
                }

                this._readWhitespace();

                this.fire({
                    type: "startpage",
                    id: identifier,
                    pseudo: pseudoPage,
                    line: line,
                    col: col
                });

                this._readDeclarations(true, true);

                this.fire({
                    type: "endpage",
                    id: identifier,
                    pseudo: pseudoPage,
                    line: line,
                    col: col
                });
            },

            //CSS3 Paged Media
            _margin: function _margin() {
                /*
                 * margin :
                 *    margin_sym S* '{' declaration [ ';' S* declaration? ]* '}' S*
                 *    ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    marginSym = this._margin_sym();

                if (marginSym) {
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this.fire({
                        type: "startpagemargin",
                        margin: marginSym,
                        line: line,
                        col: col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type: "endpagemargin",
                        margin: marginSym,
                        line: line,
                        col: col
                    });
                    return true;
                } else {
                    return false;
                }
            },

            //CSS3 Paged Media
            _margin_sym: function _margin_sym() {

                /*
                 * margin_sym :
                 *    TOPLEFTCORNER_SYM |
                 *    TOPLEFT_SYM |
                 *    TOPCENTER_SYM |
                 *    TOPRIGHT_SYM |
                 *    TOPRIGHTCORNER_SYM |
                 *    BOTTOMLEFTCORNER_SYM |
                 *    BOTTOMLEFT_SYM |
                 *    BOTTOMCENTER_SYM |
                 *    BOTTOMRIGHT_SYM |
                 *    BOTTOMRIGHTCORNER_SYM |
                 *    LEFTTOP_SYM |
                 *    LEFTMIDDLE_SYM |
                 *    LEFTBOTTOM_SYM |
                 *    RIGHTTOP_SYM |
                 *    RIGHTMIDDLE_SYM |
                 *    RIGHTBOTTOM_SYM
                 *    ;
                 */

                var tokenStream = this._tokenStream;

                if (tokenStream.match([Tokens.TOPLEFTCORNER_SYM, Tokens.TOPLEFT_SYM, Tokens.TOPCENTER_SYM, Tokens.TOPRIGHT_SYM, Tokens.TOPRIGHTCORNER_SYM, Tokens.BOTTOMLEFTCORNER_SYM, Tokens.BOTTOMLEFT_SYM, Tokens.BOTTOMCENTER_SYM, Tokens.BOTTOMRIGHT_SYM, Tokens.BOTTOMRIGHTCORNER_SYM, Tokens.LEFTTOP_SYM, Tokens.LEFTMIDDLE_SYM, Tokens.LEFTBOTTOM_SYM, Tokens.RIGHTTOP_SYM, Tokens.RIGHTMIDDLE_SYM, Tokens.RIGHTBOTTOM_SYM])) {
                    return SyntaxUnit.fromToken(tokenStream.token());
                } else {
                    return null;
                }
            },

            _pseudo_page: function _pseudo_page() {
                /*
                 * pseudo_page
                 *   : ':' IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream;

                tokenStream.mustMatch(Tokens.COLON);
                tokenStream.mustMatch(Tokens.IDENT);

                //TODO: CSS3 Paged Media says only "left", "center", and "right" are allowed

                return tokenStream.token().value;
            },

            _font_face: function _font_face() {
                /*
                 * font_face
                 *   : FONT_FACE_SYM S*
                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col;

                //look for @page
                tokenStream.mustMatch(Tokens.FONT_FACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                this.fire({
                    type: "startfontface",
                    line: line,
                    col: col
                });

                this._readDeclarations(true);

                this.fire({
                    type: "endfontface",
                    line: line,
                    col: col
                });
            },

            _viewport: function _viewport() {
                /*
                 * viewport
                 *   : VIEWPORT_SYM S*
                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col;

                tokenStream.mustMatch(Tokens.VIEWPORT_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                this.fire({
                    type: "startviewport",
                    line: line,
                    col: col
                });

                this._readDeclarations(true);

                this.fire({
                    type: "endviewport",
                    line: line,
                    col: col
                });
            },

            _document: function _document() {
                /*
                 * document
                 *   : DOCUMENT_SYM S*
                 *     _document_function [ ',' S* _document_function ]* S*
                 *     '{' S* ruleset* '}'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token,
                    functions = [],
                    prefix = "";

                tokenStream.mustMatch(Tokens.DOCUMENT_SYM);
                token = tokenStream.token();
                if (/^@\-([^\-]+)\-/.test(token.value)) {
                    prefix = RegExp.$1;
                }

                this._readWhitespace();
                functions.push(this._document_function());

                while (tokenStream.match(Tokens.COMMA)) {
                    this._readWhitespace();
                    functions.push(this._document_function());
                }

                tokenStream.mustMatch(Tokens.LBRACE);
                this._readWhitespace();

                this.fire({
                    type: "startdocument",
                    functions: functions,
                    prefix: prefix,
                    line: token.startLine,
                    col: token.startCol
                });

                while (true) {
                    if (tokenStream.peek() === Tokens.PAGE_SYM) {
                        this._page();
                    } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM) {
                        this._font_face();
                    } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM) {
                        this._viewport();
                    } else if (tokenStream.peek() === Tokens.MEDIA_SYM) {
                        this._media();
                    } else if (!this._ruleset()) {
                        break;
                    }
                }

                tokenStream.mustMatch(Tokens.RBRACE);
                this._readWhitespace();

                this.fire({
                    type: "enddocument",
                    functions: functions,
                    prefix: prefix,
                    line: token.startLine,
                    col: token.startCol
                });
            },

            _document_function: function _document_function() {
                /*
                 * document_function
                 *   : function | URI S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value;

                if (tokenStream.match(Tokens.URI)) {
                    value = tokenStream.token().value;
                    this._readWhitespace();
                } else {
                    value = this._function();
                }

                return value;
            },

            _operator: function _operator(inFunction) {

                /*
                 * operator (outside function)
                 *  : '/' S* | ',' S* | /( empty )/
                 * operator (inside function)
                 *  : '/' S* | '+' S* | '*' S* | '-' S* /( empty )/
                 *  ;
                 */

                var tokenStream = this._tokenStream,
                    token = null;

                if (tokenStream.match([Tokens.SLASH, Tokens.COMMA]) || inFunction && tokenStream.match([Tokens.PLUS, Tokens.STAR, Tokens.MINUS])) {
                    token = tokenStream.token();
                    this._readWhitespace();
                }
                return token ? PropertyValuePart.fromToken(token) : null;
            },

            _combinator: function _combinator() {

                /*
                 * combinator
                 *  : PLUS S* | GREATER S* | TILDE S* | S+
                 *  ;
                 */

                var tokenStream = this._tokenStream,
                    value = null,
                    token;

                if (tokenStream.match([Tokens.PLUS, Tokens.GREATER, Tokens.TILDE])) {
                    token = tokenStream.token();
                    value = new Combinator(token.value, token.startLine, token.startCol);
                    this._readWhitespace();
                }

                return value;
            },

            _unary_operator: function _unary_operator() {

                /*
                 * unary_operator
                 *  : '-' | '+'
                 *  ;
                 */

                var tokenStream = this._tokenStream;

                if (tokenStream.match([Tokens.MINUS, Tokens.PLUS])) {
                    return tokenStream.token().value;
                } else {
                    return null;
                }
            },

            _property: function _property() {

                /*
                 * property
                 *   : IDENT S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value = null,
                    hack = null,
                    tokenValue,
                    token,
                    line,
                    col;

                //check for star hack - throws error if not allowed
                if (tokenStream.peek() === Tokens.STAR && this.options.starHack) {
                    tokenStream.get();
                    token = tokenStream.token();
                    hack = token.value;
                    line = token.startLine;
                    col = token.startCol;
                }

                if (tokenStream.match(Tokens.IDENT)) {
                    token = tokenStream.token();
                    tokenValue = token.value;

                    //check for underscore hack - no error if not allowed because it's valid CSS syntax
                    if (tokenValue.charAt(0) === "_" && this.options.underscoreHack) {
                        hack = "_";
                        tokenValue = tokenValue.substring(1);
                    }

                    value = new PropertyName(tokenValue, hack, line || token.startLine, col || token.startCol);
                    this._readWhitespace();
                }

                return value;
            },

            //Augmented with CSS3 Selectors
            _ruleset: function _ruleset() {
                /*
                 * ruleset
                 *   : selectors_group
                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    tt,
                    selectors;

                /*
                 * Error Recovery: If even a single selector fails to parse,
                 * then the entire ruleset should be thrown away.
                 */
                try {
                    selectors = this._selectors_group();
                } catch (ex) {
                    if (ex instanceof SyntaxError && !this.options.strict) {

                        //fire error event
                        this.fire({
                            type: "error",
                            error: ex,
                            message: ex.message,
                            line: ex.line,
                            col: ex.col
                        });

                        //skip over everything until closing brace
                        tt = tokenStream.advance([Tokens.RBRACE]);
                        if (tt === Tokens.RBRACE) {
                            //if there's a right brace, the rule is finished so don't do anything
                        } else {
                            //otherwise, rethrow the error because it wasn't handled properly
                            throw ex;
                        }
                    } else {
                        //not a syntax error, rethrow it
                        throw ex;
                    }

                    //trigger parser to continue
                    return true;
                }

                //if it got here, all selectors parsed
                if (selectors) {

                    this.fire({
                        type: "startrule",
                        selectors: selectors,
                        line: selectors[0].line,
                        col: selectors[0].col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type: "endrule",
                        selectors: selectors,
                        line: selectors[0].line,
                        col: selectors[0].col
                    });
                }

                return selectors;
            },

            //CSS3 Selectors
            _selectors_group: function _selectors_group() {

                /*
                 * selectors_group
                 *   : selector [ COMMA S* selector ]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    selectors = [],
                    selector;

                selector = this._selector();
                if (selector !== null) {

                    selectors.push(selector);
                    while (tokenStream.match(Tokens.COMMA)) {
                        this._readWhitespace();
                        selector = this._selector();
                        if (selector !== null) {
                            selectors.push(selector);
                        } else {
                            this._unexpectedToken(tokenStream.LT(1));
                        }
                    }
                }

                return selectors.length ? selectors : null;
            },

            //CSS3 Selectors
            _selector: function _selector() {
                /*
                 * selector
                 *   : simple_selector_sequence [ combinator simple_selector_sequence ]*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    selector = [],
                    nextSelector = null,
                    combinator = null,
                    ws = null;

                //if there's no simple selector, then there's no selector
                nextSelector = this._simple_selector_sequence();
                if (nextSelector === null) {
                    return null;
                }

                selector.push(nextSelector);

                do {

                    //look for a combinator
                    combinator = this._combinator();

                    if (combinator !== null) {
                        selector.push(combinator);
                        nextSelector = this._simple_selector_sequence();

                        //there must be a next selector
                        if (nextSelector === null) {
                            this._unexpectedToken(tokenStream.LT(1));
                        } else {

                            //nextSelector is an instance of SelectorPart
                            selector.push(nextSelector);
                        }
                    } else {

                        //if there's not whitespace, we're done
                        if (this._readWhitespace()) {

                            //add whitespace separator
                            ws = new Combinator(tokenStream.token().value, tokenStream.token().startLine, tokenStream.token().startCol);

                            //combinator is not required
                            combinator = this._combinator();

                            //selector is required if there's a combinator
                            nextSelector = this._simple_selector_sequence();
                            if (nextSelector === null) {
                                if (combinator !== null) {
                                    this._unexpectedToken(tokenStream.LT(1));
                                }
                            } else {

                                if (combinator !== null) {
                                    selector.push(combinator);
                                } else {
                                    selector.push(ws);
                                }

                                selector.push(nextSelector);
                            }
                        } else {
                            break;
                        }
                    }
                } while (true);

                return new Selector(selector, selector[0].line, selector[0].col);
            },

            //CSS3 Selectors
            _simple_selector_sequence: function _simple_selector_sequence() {
                /*
                 * simple_selector_sequence
                 *   : [ type_selector | universal ]
                 *     [ HASH | class | attrib | pseudo | negation ]*
                 *   | [ HASH | class | attrib | pseudo | negation ]+
                 *   ;
                 */

                var tokenStream = this._tokenStream,


                //parts of a simple selector
                elementName = null,
                    modifiers = [],


                //complete selector text
                selectorText = "",


                //the different parts after the element name to search for
                components = [
                //HASH
                function () {
                    return tokenStream.match(Tokens.HASH) ? new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) : null;
                }, this._class, this._attrib, this._pseudo, this._negation],
                    i = 0,
                    len = components.length,
                    component = null,
                    line,
                    col;

                //get starting line and column for the selector
                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;

                elementName = this._type_selector();
                if (!elementName) {
                    elementName = this._universal();
                }

                if (elementName !== null) {
                    selectorText += elementName;
                }

                while (true) {

                    //whitespace means we're done
                    if (tokenStream.peek() === Tokens.S) {
                        break;
                    }

                    //check for each component
                    while (i < len && component === null) {
                        component = components[i++].call(this);
                    }

                    if (component === null) {

                        //we don't have a selector
                        if (selectorText === "") {
                            return null;
                        } else {
                            break;
                        }
                    } else {
                        i = 0;
                        modifiers.push(component);
                        selectorText += component.toString();
                        component = null;
                    }
                }

                return selectorText !== "" ? new SelectorPart(elementName, modifiers, selectorText, line, col) : null;
            },

            //CSS3 Selectors
            _type_selector: function _type_selector() {
                /*
                 * type_selector
                 *   : [ namespace_prefix ]? element_name
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    ns = this._namespace_prefix(),
                    elementName = this._element_name();

                if (!elementName) {
                    /*
                     * Need to back out the namespace that was read due to both
                     * type_selector and universal reading namespace_prefix
                     * first. Kind of hacky, but only way I can figure out
                     * right now how to not change the grammar.
                     */
                    if (ns) {
                        tokenStream.unget();
                        if (ns.length > 1) {
                            tokenStream.unget();
                        }
                    }

                    return null;
                } else {
                    if (ns) {
                        elementName.text = ns + elementName.text;
                        elementName.col -= ns.length;
                    }
                    return elementName;
                }
            },

            //CSS3 Selectors
            _class: function _class() {
                /*
                 * class
                 *   : '.' IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.DOT)) {
                    tokenStream.mustMatch(Tokens.IDENT);
                    token = tokenStream.token();
                    return new SelectorSubPart("." + token.value, "class", token.startLine, token.startCol - 1);
                } else {
                    return null;
                }
            },

            //CSS3 Selectors
            _element_name: function _element_name() {
                /*
                 * element_name
                 *   : IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.IDENT)) {
                    token = tokenStream.token();
                    return new SelectorSubPart(token.value, "elementName", token.startLine, token.startCol);
                } else {
                    return null;
                }
            },

            //CSS3 Selectors
            _namespace_prefix: function _namespace_prefix() {
                /*
                 * namespace_prefix
                 *   : [ IDENT | '*' ]? '|'
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    value = "";

                //verify that this is a namespace prefix
                if (tokenStream.LA(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens.PIPE) {

                    if (tokenStream.match([Tokens.IDENT, Tokens.STAR])) {
                        value += tokenStream.token().value;
                    }

                    tokenStream.mustMatch(Tokens.PIPE);
                    value += "|";
                }

                return value.length ? value : null;
            },

            //CSS3 Selectors
            _universal: function _universal() {
                /*
                 * universal
                 *   : [ namespace_prefix ]? '*'
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    value = "",
                    ns;

                ns = this._namespace_prefix();
                if (ns) {
                    value += ns;
                }

                if (tokenStream.match(Tokens.STAR)) {
                    value += "*";
                }

                return value.length ? value : null;
            },

            //CSS3 Selectors
            _attrib: function _attrib() {
                /*
                 * attrib
                 *   : '[' S* [ namespace_prefix ]? IDENT S*
                 *         [ [ PREFIXMATCH |
                 *             SUFFIXMATCH |
                 *             SUBSTRINGMATCH |
                 *             '=' |
                 *             INCLUDES |
                 *             DASHMATCH ] S* [ IDENT | STRING ] S*
                 *         ]? ']'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value = null,
                    ns,
                    token;

                if (tokenStream.match(Tokens.LBRACKET)) {
                    token = tokenStream.token();
                    value = token.value;
                    value += this._readWhitespace();

                    ns = this._namespace_prefix();

                    if (ns) {
                        value += ns;
                    }

                    tokenStream.mustMatch(Tokens.IDENT);
                    value += tokenStream.token().value;
                    value += this._readWhitespace();

                    if (tokenStream.match([Tokens.PREFIXMATCH, Tokens.SUFFIXMATCH, Tokens.SUBSTRINGMATCH, Tokens.EQUALS, Tokens.INCLUDES, Tokens.DASHMATCH])) {

                        value += tokenStream.token().value;
                        value += this._readWhitespace();

                        tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                        value += tokenStream.token().value;
                        value += this._readWhitespace();
                    }

                    tokenStream.mustMatch(Tokens.RBRACKET);

                    return new SelectorSubPart(value + "]", "attribute", token.startLine, token.startCol);
                } else {
                    return null;
                }
            },

            //CSS3 Selectors
            _pseudo: function _pseudo() {

                /*
                 * pseudo
                 *   : ':' ':'? [ IDENT | functional_pseudo ]
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    pseudo = null,
                    colons = ":",
                    line,
                    col;

                if (tokenStream.match(Tokens.COLON)) {

                    if (tokenStream.match(Tokens.COLON)) {
                        colons += ":";
                    }

                    if (tokenStream.match(Tokens.IDENT)) {
                        pseudo = tokenStream.token().value;
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol - colons.length;
                    } else if (tokenStream.peek() === Tokens.FUNCTION) {
                        line = tokenStream.LT(1).startLine;
                        col = tokenStream.LT(1).startCol - colons.length;
                        pseudo = this._functional_pseudo();
                    }

                    if (pseudo) {
                        pseudo = new SelectorSubPart(colons + pseudo, "pseudo", line, col);
                    }
                }

                return pseudo;
            },

            //CSS3 Selectors
            _functional_pseudo: function _functional_pseudo() {
                /*
                 * functional_pseudo
                 *   : FUNCTION S* expression ')'
                 *   ;
                */

                var tokenStream = this._tokenStream,
                    value = null;

                if (tokenStream.match(Tokens.FUNCTION)) {
                    value = tokenStream.token().value;
                    value += this._readWhitespace();
                    value += this._expression();
                    tokenStream.mustMatch(Tokens.RPAREN);
                    value += ")";
                }

                return value;
            },

            //CSS3 Selectors
            _expression: function _expression() {
                /*
                 * expression
                 *   : [ [ PLUS | '-' | DIMENSION | NUMBER | STRING | IDENT ] S* ]+
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value = "";

                while (tokenStream.match([Tokens.PLUS, Tokens.MINUS, Tokens.DIMENSION, Tokens.NUMBER, Tokens.STRING, Tokens.IDENT, Tokens.LENGTH, Tokens.FREQ, Tokens.ANGLE, Tokens.TIME, Tokens.RESOLUTION, Tokens.SLASH])) {

                    value += tokenStream.token().value;
                    value += this._readWhitespace();
                }

                return value.length ? value : null;
            },

            //CSS3 Selectors
            _negation: function _negation() {
                /*
                 * negation
                 *   : NOT S* negation_arg S* ')'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    line,
                    col,
                    value = "",
                    arg,
                    subpart = null;

                if (tokenStream.match(Tokens.NOT)) {
                    value = tokenStream.token().value;
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                    value += this._readWhitespace();
                    arg = this._negation_arg();
                    value += arg;
                    value += this._readWhitespace();
                    tokenStream.match(Tokens.RPAREN);
                    value += tokenStream.token().value;

                    subpart = new SelectorSubPart(value, "not", line, col);
                    subpart.args.push(arg);
                }

                return subpart;
            },

            //CSS3 Selectors
            _negation_arg: function _negation_arg() {
                /*
                 * negation_arg
                 *   : type_selector | universal | HASH | class | attrib | pseudo
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    args = [this._type_selector, this._universal, function () {
                    return tokenStream.match(Tokens.HASH) ? new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) : null;
                }, this._class, this._attrib, this._pseudo],
                    arg = null,
                    i = 0,
                    len = args.length,
                    line,
                    col,
                    part;

                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;

                while (i < len && arg === null) {

                    arg = args[i].call(this);
                    i++;
                }

                //must be a negation arg
                if (arg === null) {
                    this._unexpectedToken(tokenStream.LT(1));
                }

                //it's an element name
                if (arg.type === "elementName") {
                    part = new SelectorPart(arg, [], arg.toString(), line, col);
                } else {
                    part = new SelectorPart(null, [arg], arg.toString(), line, col);
                }

                return part;
            },

            _declaration: function _declaration() {

                /*
                 * declaration
                 *   : property ':' S* expr prio?
                 *   | /( empty )/
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    property = null,
                    expr = null,
                    prio = null,
                    invalid = null,
                    propertyName = "";

                property = this._property();
                if (property !== null) {

                    tokenStream.mustMatch(Tokens.COLON);
                    this._readWhitespace();

                    expr = this._expr();

                    //if there's no parts for the value, it's an error
                    if (!expr || expr.length === 0) {
                        this._unexpectedToken(tokenStream.LT(1));
                    }

                    prio = this._prio();

                    /*
                     * If hacks should be allowed, then only check the root
                     * property. If hacks should not be allowed, treat
                     * _property or *property as invalid properties.
                     */
                    propertyName = property.toString();
                    if (this.options.starHack && property.hack === "*" || this.options.underscoreHack && property.hack === "_") {

                        propertyName = property.text;
                    }

                    try {
                        this._validateProperty(propertyName, expr);
                    } catch (ex) {
                        invalid = ex;
                    }

                    this.fire({
                        type: "property",
                        property: property,
                        value: expr,
                        important: prio,
                        line: property.line,
                        col: property.col,
                        invalid: invalid
                    });

                    return true;
                } else {
                    return false;
                }
            },

            _prio: function _prio() {
                /*
                 * prio
                 *   : IMPORTANT_SYM S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    result = tokenStream.match(Tokens.IMPORTANT_SYM);

                this._readWhitespace();
                return result;
            },

            _expr: function _expr(inFunction) {
                /*
                 * expr
                 *   : term [ operator term ]*
                 *   ;
                 */

                var values = [],

                //valueParts	= [],
                value = null,
                    operator = null;

                value = this._term(inFunction);
                if (value !== null) {

                    values.push(value);

                    do {
                        operator = this._operator(inFunction);

                        //if there's an operator, keep building up the value parts
                        if (operator) {
                            values.push(operator);
                        } /*else {
                            //if there's not an operator, you have a full value
                          values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
                          valueParts = [];
                          }*/

                        value = this._term(inFunction);

                        if (value === null) {
                            break;
                        } else {
                            values.push(value);
                        }
                    } while (true);
                }

                //cleanup
                /*if (valueParts.length){
                    values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
                }*/

                return values.length > 0 ? new PropertyValue(values, values[0].line, values[0].col) : null;
            },

            _term: function _term(inFunction) {

                /*
                 * term
                 *   : unary_operator?
                 *     [ NUMBER S* | PERCENTAGE S* | LENGTH S* | ANGLE S* |
                 *       TIME S* | FREQ S* | function | ie_function ]
                 *   | STRING S* | IDENT S* | URI S* | UNICODERANGE S* | hexcolor
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    unary = null,
                    value = null,
                    endChar = null,
                    token,
                    line,
                    col;

                //returns the operator or null
                unary = this._unary_operator();
                if (unary !== null) {
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                }

                //exception for IE filters
                if (tokenStream.peek() === Tokens.IE_FUNCTION && this.options.ieFilters) {

                    value = this._ie_function();
                    if (unary === null) {
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }

                    //see if it's a simple block
                } else if (inFunction && tokenStream.match([Tokens.LPAREN, Tokens.LBRACE, Tokens.LBRACKET])) {

                    token = tokenStream.token();
                    endChar = token.endChar;
                    value = token.value + this._expr(inFunction).text;
                    if (unary === null) {
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                    tokenStream.mustMatch(Tokens.type(endChar));
                    value += endChar;
                    this._readWhitespace();

                    //see if there's a simple match
                } else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH, Tokens.ANGLE, Tokens.TIME, Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])) {

                    value = tokenStream.token().value;
                    if (unary === null) {
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                    this._readWhitespace();
                } else {

                    //see if it's a color
                    token = this._hexcolor();
                    if (token === null) {

                        //if there's no unary, get the start of the next token for line/col info
                        if (unary === null) {
                            line = tokenStream.LT(1).startLine;
                            col = tokenStream.LT(1).startCol;
                        }

                        //has to be a function
                        if (value === null) {

                            /*
                             * This checks for alpha(opacity=0) style of IE
                             * functions. IE_FUNCTION only presents progid: style.
                             */
                            if (tokenStream.LA(3) === Tokens.EQUALS && this.options.ieFilters) {
                                value = this._ie_function();
                            } else {
                                value = this._function();
                            }
                        }

                        /*if (value === null){
                            return null;
                            //throw new Error("Expected identifier at line " + tokenStream.token().startLine + ", character " +  tokenStream.token().startCol + ".");
                        }*/
                    } else {
                        value = token.value;
                        if (unary === null) {
                            line = token.startLine;
                            col = token.startCol;
                        }
                    }
                }

                return value !== null ? new PropertyValuePart(unary !== null ? unary + value : value, line, col) : null;
            },

            _function: function _function() {

                /*
                 * function
                 *   : FUNCTION S* expr ')' S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    functionText = null,
                    expr = null,
                    lt;

                if (tokenStream.match(Tokens.FUNCTION)) {
                    functionText = tokenStream.token().value;
                    this._readWhitespace();
                    expr = this._expr(true);
                    functionText += expr;

                    //START: Horrible hack in case it's an IE filter
                    if (this.options.ieFilters && tokenStream.peek() === Tokens.EQUALS) {
                        do {

                            if (this._readWhitespace()) {
                                functionText += tokenStream.token().value;
                            }

                            //might be second time in the loop
                            if (tokenStream.LA(0) === Tokens.COMMA) {
                                functionText += tokenStream.token().value;
                            }

                            tokenStream.match(Tokens.IDENT);
                            functionText += tokenStream.token().value;

                            tokenStream.match(Tokens.EQUALS);
                            functionText += tokenStream.token().value;

                            //functionText += this._term();
                            lt = tokenStream.peek();
                            while (lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN) {
                                tokenStream.get();
                                functionText += tokenStream.token().value;
                                lt = tokenStream.peek();
                            }
                        } while (tokenStream.match([Tokens.COMMA, Tokens.S]));
                    }

                    //END: Horrible Hack

                    tokenStream.match(Tokens.RPAREN);
                    functionText += ")";
                    this._readWhitespace();
                }

                return functionText;
            },

            _ie_function: function _ie_function() {

                /* (My own extension)
                 * ie_function
                 *   : IE_FUNCTION S* IDENT '=' term [S* ','? IDENT '=' term]+ ')' S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    functionText = null,
                    lt;

                //IE function can begin like a regular function, too
                if (tokenStream.match([Tokens.IE_FUNCTION, Tokens.FUNCTION])) {
                    functionText = tokenStream.token().value;

                    do {

                        if (this._readWhitespace()) {
                            functionText += tokenStream.token().value;
                        }

                        //might be second time in the loop
                        if (tokenStream.LA(0) === Tokens.COMMA) {
                            functionText += tokenStream.token().value;
                        }

                        tokenStream.match(Tokens.IDENT);
                        functionText += tokenStream.token().value;

                        tokenStream.match(Tokens.EQUALS);
                        functionText += tokenStream.token().value;

                        //functionText += this._term();
                        lt = tokenStream.peek();
                        while (lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN) {
                            tokenStream.get();
                            functionText += tokenStream.token().value;
                            lt = tokenStream.peek();
                        }
                    } while (tokenStream.match([Tokens.COMMA, Tokens.S]));

                    tokenStream.match(Tokens.RPAREN);
                    functionText += ")";
                    this._readWhitespace();
                }

                return functionText;
            },

            _hexcolor: function _hexcolor() {
                /*
                 * There is a constraint on the color that it must
                 * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])
                 * after the "#"; e.g., "#000" is OK, but "#abcd" is not.
                 *
                 * hexcolor
                 *   : HASH S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token = null,
                    color;

                if (tokenStream.match(Tokens.HASH)) {

                    //need to do some validation here

                    token = tokenStream.token();
                    color = token.value;
                    if (!/#[a-f0-9]{3,6}/i.test(color)) {
                        throw new SyntaxError("Expected a hex color but found '" + color + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
                    }
                    this._readWhitespace();
                }

                return token;
            },

            //-----------------------------------------------------------------
            // Animations methods
            //-----------------------------------------------------------------

            _keyframes: function _keyframes() {

                /*
                 * keyframes:
                 *   : KEYFRAMES_SYM S* keyframe_name S* '{' S* keyframe_rule* '}' {
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    token,
                    tt,
                    name,
                    prefix = "";

                tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);
                token = tokenStream.token();
                if (/^@\-([^\-]+)\-/.test(token.value)) {
                    prefix = RegExp.$1;
                }

                this._readWhitespace();
                name = this._keyframe_name();

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.LBRACE);

                this.fire({
                    type: "startkeyframes",
                    name: name,
                    prefix: prefix,
                    line: token.startLine,
                    col: token.startCol
                });

                this._readWhitespace();
                tt = tokenStream.peek();

                //check for key
                while (tt === Tokens.IDENT || tt === Tokens.PERCENTAGE) {
                    this._keyframe_rule();
                    this._readWhitespace();
                    tt = tokenStream.peek();
                }

                this.fire({
                    type: "endkeyframes",
                    name: name,
                    prefix: prefix,
                    line: token.startLine,
                    col: token.startCol
                });

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.RBRACE);
            },

            _keyframe_name: function _keyframe_name() {

                /*
                 * keyframe_name:
                 *   : IDENT
                 *   | STRING
                 *   ;
                 */
                var tokenStream = this._tokenStream;

                tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                return SyntaxUnit.fromToken(tokenStream.token());
            },

            _keyframe_rule: function _keyframe_rule() {

                /*
                 * keyframe_rule:
                 *   : key_list S*
                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*
                 *   ;
                 */
                var keyList = this._key_list();

                this.fire({
                    type: "startkeyframerule",
                    keys: keyList,
                    line: keyList[0].line,
                    col: keyList[0].col
                });

                this._readDeclarations(true);

                this.fire({
                    type: "endkeyframerule",
                    keys: keyList,
                    line: keyList[0].line,
                    col: keyList[0].col
                });
            },

            _key_list: function _key_list() {

                /*
                 * key_list:
                 *   : key [ S* ',' S* key]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    keyList = [];

                //must be least one key
                keyList.push(this._key());

                this._readWhitespace();

                while (tokenStream.match(Tokens.COMMA)) {
                    this._readWhitespace();
                    keyList.push(this._key());
                    this._readWhitespace();
                }

                return keyList;
            },

            _key: function _key() {
                /*
                 * There is a restriction that IDENT can be only "from" or "to".
                 *
                 * key
                 *   : PERCENTAGE
                 *   | IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.PERCENTAGE)) {
                    return SyntaxUnit.fromToken(tokenStream.token());
                } else if (tokenStream.match(Tokens.IDENT)) {
                    token = tokenStream.token();

                    if (/from|to/i.test(token.value)) {
                        return SyntaxUnit.fromToken(token);
                    }

                    tokenStream.unget();
                }

                //if it gets here, there wasn't a valid token, so time to explode
                this._unexpectedToken(tokenStream.LT(1));
            },

            //-----------------------------------------------------------------
            // Helper methods
            //-----------------------------------------------------------------

            /**
             * Not part of CSS grammar, but useful for skipping over
             * combination of white space and HTML-style comments.
             * @return {void}
             * @method _skipCruft
             * @private
             */
            _skipCruft: function _skipCruft() {
                while (this._tokenStream.match([Tokens.S, Tokens.CDO, Tokens.CDC])) {
                    //noop
                }
            },

            /**
             * Not part of CSS grammar, but this pattern occurs frequently
             * in the official CSS grammar. Split out here to eliminate
             * duplicate code.
             * @param {Boolean} checkStart Indicates if the rule should check
             *      for the left brace at the beginning.
             * @param {Boolean} readMargins Indicates if the rule should check
             *      for margin patterns.
             * @return {void}
             * @method _readDeclarations
             * @private
             */
            _readDeclarations: function _readDeclarations(checkStart, readMargins) {
                /*
                 * Reads the pattern
                 * S* '{' S* declaration [ ';' S* declaration ]* '}' S*
                 * or
                 * S* '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*
                 * Note that this is how it is described in CSS3 Paged Media, but is actually incorrect.
                 * A semicolon is only necessary following a declaration if there's another declaration
                 * or margin afterwards.
                 */
                var tokenStream = this._tokenStream,
                    tt;

                this._readWhitespace();

                if (checkStart) {
                    tokenStream.mustMatch(Tokens.LBRACE);
                }

                this._readWhitespace();

                try {

                    while (true) {

                        if (tokenStream.match(Tokens.SEMICOLON) || readMargins && this._margin()) {
                            //noop
                        } else if (this._declaration()) {
                            if (!tokenStream.match(Tokens.SEMICOLON)) {
                                break;
                            }
                        } else {
                            break;
                        }

                        //if ((!this._margin() && !this._declaration()) || !tokenStream.match(Tokens.SEMICOLON)){
                        //    break;
                        //}
                        this._readWhitespace();
                    }

                    tokenStream.mustMatch(Tokens.RBRACE);
                    this._readWhitespace();
                } catch (ex) {
                    if (ex instanceof SyntaxError && !this.options.strict) {

                        //fire error event
                        this.fire({
                            type: "error",
                            error: ex,
                            message: ex.message,
                            line: ex.line,
                            col: ex.col
                        });

                        //see if there's another declaration
                        tt = tokenStream.advance([Tokens.SEMICOLON, Tokens.RBRACE]);
                        if (tt === Tokens.SEMICOLON) {
                            //if there's a semicolon, then there might be another declaration
                            this._readDeclarations(false, readMargins);
                        } else if (tt !== Tokens.RBRACE) {
                            //if there's a right brace, the rule is finished so don't do anything
                            //otherwise, rethrow the error because it wasn't handled properly
                            throw ex;
                        }
                    } else {
                        //not a syntax error, rethrow it
                        throw ex;
                    }
                }
            },

            /**
             * In some cases, you can end up with two white space tokens in a
             * row. Instead of making a change in every function that looks for
             * white space, this function is used to match as much white space
             * as necessary.
             * @method _readWhitespace
             * @return {String} The white space if found, empty string if not.
             * @private
             */
            _readWhitespace: function _readWhitespace() {

                var tokenStream = this._tokenStream,
                    ws = "";

                while (tokenStream.match(Tokens.S)) {
                    ws += tokenStream.token().value;
                }

                return ws;
            },

            /**
             * Throws an error when an unexpected token is found.
             * @param {Object} token The token that was found.
             * @method _unexpectedToken
             * @return {void}
             * @private
             */
            _unexpectedToken: function _unexpectedToken(token) {
                throw new SyntaxError("Unexpected token '" + token.value + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
            },

            /**
             * Helper method used for parsing subparts of a style sheet.
             * @return {void}
             * @method _verifyEnd
             * @private
             */
            _verifyEnd: function _verifyEnd() {
                if (this._tokenStream.LA(1) !== Tokens.EOF) {
                    this._unexpectedToken(this._tokenStream.LT(1));
                }
            },

            //-----------------------------------------------------------------
            // Validation methods
            //-----------------------------------------------------------------
            _validateProperty: function _validateProperty(property, value) {
                Validation.validate(property, value);
            },

            //-----------------------------------------------------------------
            // Parsing methods
            //-----------------------------------------------------------------

            parse: function parse(input) {
                this._tokenStream = new TokenStream(input, Tokens);
                this._stylesheet();
            },

            parseStyleSheet: function parseStyleSheet(input) {
                //just passthrough
                return this.parse(input);
            },

            parseMediaQuery: function parseMediaQuery(input) {
                this._tokenStream = new TokenStream(input, Tokens);
                var result = this._media_query();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses a property value (everything after the semicolon).
             * @return {parserlib.css.PropertyValue} The property value.
             * @throws parserlib.util.SyntaxError If an unexpected token is found.
             * @method parserPropertyValue
             */
            parsePropertyValue: function parsePropertyValue(input) {

                this._tokenStream = new TokenStream(input, Tokens);
                this._readWhitespace();

                var result = this._expr();

                //okay to have a trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses a complete CSS rule, including selectors and
             * properties.
             * @param {String} input The text to parser.
             * @return {Boolean} True if the parse completed successfully, false if not.
             * @method parseRule
             */
            parseRule: function parseRule(input) {
                this._tokenStream = new TokenStream(input, Tokens);

                //skip any leading white space
                this._readWhitespace();

                var result = this._ruleset();

                //skip any trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses a single CSS selector (no comma)
             * @param {String} input The text to parse as a CSS selector.
             * @return {Selector} An object representing the selector.
             * @throws parserlib.util.SyntaxError If an unexpected token is found.
             * @method parseSelector
             */
            parseSelector: function parseSelector(input) {

                this._tokenStream = new TokenStream(input, Tokens);

                //skip any leading white space
                this._readWhitespace();

                var result = this._selector();

                //skip any trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses an HTML style attribute: a set of CSS declarations
             * separated by semicolons.
             * @param {String} input The text to parse as a style attribute
             * @return {void}
             * @method parseStyleAttribute
             */
            parseStyleAttribute: function parseStyleAttribute(input) {
                input += "}"; // for error recovery in _readDeclarations()
                this._tokenStream = new TokenStream(input, Tokens);
                this._readDeclarations();
            }
        };

        //copy over onto prototype
        for (prop in additions) {
            if (Object.prototype.hasOwnProperty.call(additions, prop)) {
                proto[prop] = additions[prop];
            }
        }

        return proto;
    }();

    /*
    nth
      : S* [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]? |
             ['-'|'+']? INTEGER | {O}{D}{D} | {E}{V}{E}{N} ] S*
      ;
    */
    var Properties = {
        __proto__: null,

        //A
        "align-items": "flex-start | flex-end | center | baseline | stretch",
        "align-content": "flex-start | flex-end | center | space-between | space-around | stretch",
        "align-self": "auto | flex-start | flex-end | center | baseline | stretch",
        "-webkit-align-items": "flex-start | flex-end | center | baseline | stretch",
        "-webkit-align-content": "flex-start | flex-end | center | space-between | space-around | stretch",
        "-webkit-align-self": "auto | flex-start | flex-end | center | baseline | stretch",
        "alignment-adjust": "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | <percentage> | <length>",
        "alignment-baseline": "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
        "animation": 1,
        "animation-delay": { multi: "<time>", comma: true },
        "animation-direction": { multi: "normal | alternate", comma: true },
        "animation-duration": { multi: "<time>", comma: true },
        "animation-fill-mode": { multi: "none | forwards | backwards | both", comma: true },
        "animation-iteration-count": { multi: "<number> | infinite", comma: true },
        "animation-name": { multi: "none | <ident>", comma: true },
        "animation-play-state": { multi: "running | paused", comma: true },
        "animation-timing-function": 1,

        //vendor prefixed
        "-moz-animation-delay": { multi: "<time>", comma: true },
        "-moz-animation-direction": { multi: "normal | alternate", comma: true },
        "-moz-animation-duration": { multi: "<time>", comma: true },
        "-moz-animation-iteration-count": { multi: "<number> | infinite", comma: true },
        "-moz-animation-name": { multi: "none | <ident>", comma: true },
        "-moz-animation-play-state": { multi: "running | paused", comma: true },

        "-ms-animation-delay": { multi: "<time>", comma: true },
        "-ms-animation-direction": { multi: "normal | alternate", comma: true },
        "-ms-animation-duration": { multi: "<time>", comma: true },
        "-ms-animation-iteration-count": { multi: "<number> | infinite", comma: true },
        "-ms-animation-name": { multi: "none | <ident>", comma: true },
        "-ms-animation-play-state": { multi: "running | paused", comma: true },

        "-webkit-animation-delay": { multi: "<time>", comma: true },
        "-webkit-animation-direction": { multi: "normal | alternate", comma: true },
        "-webkit-animation-duration": { multi: "<time>", comma: true },
        "-webkit-animation-fill-mode": { multi: "none | forwards | backwards | both", comma: true },
        "-webkit-animation-iteration-count": { multi: "<number> | infinite", comma: true },
        "-webkit-animation-name": { multi: "none | <ident>", comma: true },
        "-webkit-animation-play-state": { multi: "running | paused", comma: true },

        "-o-animation-delay": { multi: "<time>", comma: true },
        "-o-animation-direction": { multi: "normal | alternate", comma: true },
        "-o-animation-duration": { multi: "<time>", comma: true },
        "-o-animation-iteration-count": { multi: "<number> | infinite", comma: true },
        "-o-animation-name": { multi: "none | <ident>", comma: true },
        "-o-animation-play-state": { multi: "running | paused", comma: true },

        "appearance": "icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal | none | inherit",
        "azimuth": function azimuth(expression) {
            var simple = "<angle> | leftwards | rightwards | inherit",
                direction = "left-side | far-left | left | center-left | center | center-right | right | far-right | right-side",
                behind = false,
                valid = false,
                part;

            if (!ValidationTypes.isAny(expression, simple)) {
                if (ValidationTypes.isAny(expression, "behind")) {
                    behind = true;
                    valid = true;
                }

                if (ValidationTypes.isAny(expression, direction)) {
                    valid = true;
                    if (!behind) {
                        ValidationTypes.isAny(expression, "behind");
                    }
                }
            }

            if (expression.hasNext()) {
                part = expression.next();
                if (valid) {
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
                } else {
                    throw new ValidationError("Expected (<'azimuth'>) but found '" + part + "'.", part.line, part.col);
                }
            }
        },

        //B
        "backface-visibility": "visible | hidden",
        "background": 1,
        "background-attachment": { multi: "<attachment>", comma: true },
        "background-clip": { multi: "<box>", comma: true },
        "background-color": "<color> | inherit",
        "background-image": { multi: "<bg-image>", comma: true },
        "background-origin": { multi: "<box>", comma: true },
        "background-position": { multi: "<bg-position>", comma: true },
        "background-repeat": { multi: "<repeat-style>" },
        "background-size": { multi: "<bg-size>", comma: true },
        "baseline-shift": "baseline | sub | super | <percentage> | <length>",
        "behavior": 1,
        "binding": 1,
        "bleed": "<length>",
        "bookmark-label": "<content> | <attr> | <string>",
        "bookmark-level": "none | <integer>",
        "bookmark-state": "open | closed",
        "bookmark-target": "none | <uri> | <attr>",
        "border": "<border-width> || <border-style> || <color>",
        "border-bottom": "<border-width> || <border-style> || <color>",
        "border-bottom-color": "<color> | inherit",
        "border-bottom-left-radius": "<x-one-radius>",
        "border-bottom-right-radius": "<x-one-radius>",
        "border-bottom-style": "<border-style>",
        "border-bottom-width": "<border-width>",
        "border-collapse": "collapse | separate | inherit",
        "border-color": { multi: "<color> | inherit", max: 4 },
        "border-image": 1,
        "border-image-outset": { multi: "<length> | <number>", max: 4 },
        "border-image-repeat": { multi: "stretch | repeat | round", max: 2 },
        "border-image-slice": function borderImageSlice(expression) {

            var valid = false,
                numeric = "<number> | <percentage>",
                fill = false,
                count = 0,
                max = 4,
                part;

            if (ValidationTypes.isAny(expression, "fill")) {
                fill = true;
                valid = true;
            }

            while (expression.hasNext() && count < max) {
                valid = ValidationTypes.isAny(expression, numeric);
                if (!valid) {
                    break;
                }
                count++;
            }

            if (!fill) {
                ValidationTypes.isAny(expression, "fill");
            } else {
                valid = true;
            }

            if (expression.hasNext()) {
                part = expression.next();
                if (valid) {
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
                } else {
                    throw new ValidationError("Expected ([<number> | <percentage>]{1,4} && fill?) but found '" + part + "'.", part.line, part.col);
                }
            }
        },
        "border-image-source": "<image> | none",
        "border-image-width": { multi: "<length> | <percentage> | <number> | auto", max: 4 },
        "border-left": "<border-width> || <border-style> || <color>",
        "border-left-color": "<color> | inherit",
        "border-left-style": "<border-style>",
        "border-left-width": "<border-width>",
        "border-radius": function borderRadius(expression) {

            var valid = false,
                simple = "<length> | <percentage> | inherit",
                slash = false,
                count = 0,
                max = 8,
                part;

            while (expression.hasNext() && count < max) {
                valid = ValidationTypes.isAny(expression, simple);
                if (!valid) {

                    if (String(expression.peek()) === "/" && count > 0 && !slash) {
                        slash = true;
                        max = count + 5;
                        expression.next();
                    } else {
                        break;
                    }
                }
                count++;
            }

            if (expression.hasNext()) {
                part = expression.next();
                if (valid) {
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
                } else {
                    throw new ValidationError("Expected (<'border-radius'>) but found '" + part + "'.", part.line, part.col);
                }
            }
        },
        "border-right": "<border-width> || <border-style> || <color>",
        "border-right-color": "<color> | inherit",
        "border-right-style": "<border-style>",
        "border-right-width": "<border-width>",
        "border-spacing": { multi: "<length> | inherit", max: 2 },
        "border-style": { multi: "<border-style>", max: 4 },
        "border-top": "<border-width> || <border-style> || <color>",
        "border-top-color": "<color> | inherit",
        "border-top-left-radius": "<x-one-radius>",
        "border-top-right-radius": "<x-one-radius>",
        "border-top-style": "<border-style>",
        "border-top-width": "<border-width>",
        "border-width": { multi: "<border-width>", max: 4 },
        "bottom": "<margin-width> | inherit",
        "-moz-box-align": "start | end | center | baseline | stretch",
        "-moz-box-decoration-break": "slice |clone",
        "-moz-box-direction": "normal | reverse | inherit",
        "-moz-box-flex": "<number>",
        "-moz-box-flex-group": "<integer>",
        "-moz-box-lines": "single | multiple",
        "-moz-box-ordinal-group": "<integer>",
        "-moz-box-orient": "horizontal | vertical | inline-axis | block-axis | inherit",
        "-moz-box-pack": "start | end | center | justify",
        "-o-box-decoration-break": "slice | clone",
        "-webkit-box-align": "start | end | center | baseline | stretch",
        "-webkit-box-decoration-break": "slice |clone",
        "-webkit-box-direction": "normal | reverse | inherit",
        "-webkit-box-flex": "<number>",
        "-webkit-box-flex-group": "<integer>",
        "-webkit-box-lines": "single | multiple",
        "-webkit-box-ordinal-group": "<integer>",
        "-webkit-box-orient": "horizontal | vertical | inline-axis | block-axis | inherit",
        "-webkit-box-pack": "start | end | center | justify",
        "box-decoration-break": "slice | clone",
        "box-shadow": function boxShadow(expression) {
            var part;

            if (!ValidationTypes.isAny(expression, "none")) {
                Validation.multiProperty("<shadow>", expression, true, Infinity);
            } else {
                if (expression.hasNext()) {
                    part = expression.next();
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
                }
            }
        },
        "box-sizing": "content-box | border-box | inherit",
        "break-after": "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
        "break-before": "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
        "break-inside": "auto | avoid | avoid-page | avoid-column",

        //C
        "caption-side": "top | bottom | inherit",
        "clear": "none | right | left | both | inherit",
        "clip": 1,
        "color": "<color> | inherit",
        "color-profile": 1,
        "column-count": "<integer> | auto", //http://www.w3.org/TR/css3-multicol/
        "column-fill": "auto | balance",
        "column-gap": "<length> | normal",
        "column-rule": "<border-width> || <border-style> || <color>",
        "column-rule-color": "<color>",
        "column-rule-style": "<border-style>",
        "column-rule-width": "<border-width>",
        "column-span": "none | all",
        "column-width": "<length> | auto",
        "columns": 1,
        "content": 1,
        "counter-increment": 1,
        "counter-reset": 1,
        "crop": "<shape> | auto",
        "cue": "cue-after | cue-before | inherit",
        "cue-after": 1,
        "cue-before": 1,
        "cursor": 1,

        //D
        "direction": "ltr | rtl | inherit",
        "display": "inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | none | inherit | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box | -ms-flexbox | -ms-inline-flexbox | flex | -webkit-flex | inline-flex | -webkit-inline-flex",
        "dominant-baseline": 1,
        "drop-initial-after-adjust": "central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | <percentage> | <length>",
        "drop-initial-after-align": "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
        "drop-initial-before-adjust": "before-edge | text-before-edge | central | middle | hanging | mathematical | <percentage> | <length>",
        "drop-initial-before-align": "caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
        "drop-initial-size": "auto | line | <length> | <percentage>",
        "drop-initial-value": "initial | <integer>",

        //E
        "elevation": "<angle> | below | level | above | higher | lower | inherit",
        "empty-cells": "show | hide | inherit",

        //F
        "filter": 1,
        "fit": "fill | hidden | meet | slice",
        "fit-position": 1,
        "flex": "<flex>",
        "flex-basis": "<width>",
        "flex-direction": "row | row-reverse | column | column-reverse",
        "flex-flow": "<flex-direction> || <flex-wrap>",
        "flex-grow": "<number>",
        "flex-shrink": "<number>",
        "flex-wrap": "nowrap | wrap | wrap-reverse",
        "-webkit-flex": "<flex>",
        "-webkit-flex-basis": "<width>",
        "-webkit-flex-direction": "row | row-reverse | column | column-reverse",
        "-webkit-flex-flow": "<flex-direction> || <flex-wrap>",
        "-webkit-flex-grow": "<number>",
        "-webkit-flex-shrink": "<number>",
        "-webkit-flex-wrap": "nowrap | wrap | wrap-reverse",
        "-ms-flex": "<flex>",
        "-ms-flex-align": "start | end | center | stretch | baseline",
        "-ms-flex-direction": "row | row-reverse | column | column-reverse | inherit",
        "-ms-flex-order": "<number>",
        "-ms-flex-pack": "start | end | center | justify",
        "-ms-flex-wrap": "nowrap | wrap | wrap-reverse",
        "float": "left | right | none | inherit",
        "float-offset": 1,
        "font": 1,
        "font-family": 1,
        "font-feature-settings": "<feature-tag-value> | normal | inherit",
        "font-kerning": "auto | normal | none | initial | inherit | unset",
        "font-size": "<absolute-size> | <relative-size> | <length> | <percentage> | inherit",
        "font-size-adjust": "<number> | none | inherit",
        "font-stretch": "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | inherit",
        "font-style": "normal | italic | oblique | inherit",
        "font-variant": "normal | small-caps | inherit",
        "font-variant-caps": "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
        "font-variant-position": "normal | sub | super | inherit | initial | unset",
        "font-weight": "normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit",

        //G
        "grid": 1,
        "grid-area": 1,
        "grid-auto-columns": 1,
        "grid-auto-flow": 1,
        "grid-auto-position": 1,
        "grid-auto-rows": 1,
        "grid-cell-stacking": "columns | rows | layer",
        "grid-column": 1,
        "grid-columns": 1,
        "grid-column-align": "start | end | center | stretch",
        "grid-column-sizing": 1,
        "grid-column-start": 1,
        "grid-column-end": 1,
        "grid-column-span": "<integer>",
        "grid-flow": "none | rows | columns",
        "grid-layer": "<integer>",
        "grid-row": 1,
        "grid-rows": 1,
        "grid-row-align": "start | end | center | stretch",
        "grid-row-start": 1,
        "grid-row-end": 1,
        "grid-row-span": "<integer>",
        "grid-row-sizing": 1,
        "grid-template": 1,
        "grid-template-areas": 1,
        "grid-template-columns": 1,
        "grid-template-rows": 1,

        //H
        "hanging-punctuation": 1,
        "height": "<margin-width> | <content-sizing> | inherit",
        "hyphenate-after": "<integer> | auto",
        "hyphenate-before": "<integer> | auto",
        "hyphenate-character": "<string> | auto",
        "hyphenate-lines": "no-limit | <integer>",
        "hyphenate-resource": 1,
        "hyphens": "none | manual | auto",

        //I
        "icon": 1,
        "image-orientation": "angle | auto",
        "image-rendering": 1,
        "image-resolution": 1,
        "ime-mode": "auto | normal | active | inactive | disabled | inherit",
        "inline-box-align": "initial | last | <integer>",

        //J
        "justify-content": "flex-start | flex-end | center | space-between | space-around",
        "-webkit-justify-content": "flex-start | flex-end | center | space-between | space-around",

        //L
        "left": "<margin-width> | inherit",
        "letter-spacing": "<length> | normal | inherit",
        "line-height": "<number> | <length> | <percentage> | normal | inherit",
        "line-break": "auto | loose | normal | strict",
        "line-stacking": 1,
        "line-stacking-ruby": "exclude-ruby | include-ruby",
        "line-stacking-shift": "consider-shifts | disregard-shifts",
        "line-stacking-strategy": "inline-line-height | block-line-height | max-height | grid-height",
        "list-style": 1,
        "list-style-image": "<uri> | none | inherit",
        "list-style-position": "inside | outside | inherit",
        "list-style-type": "disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none | inherit",

        //M
        "margin": { multi: "<margin-width> | inherit", max: 4 },
        "margin-bottom": "<margin-width> | inherit",
        "margin-left": "<margin-width> | inherit",
        "margin-right": "<margin-width> | inherit",
        "margin-top": "<margin-width> | inherit",
        "mark": 1,
        "mark-after": 1,
        "mark-before": 1,
        "marks": 1,
        "marquee-direction": 1,
        "marquee-play-count": 1,
        "marquee-speed": 1,
        "marquee-style": 1,
        "max-height": "<length> | <percentage> | <content-sizing> | none | inherit",
        "max-width": "<length> | <percentage> | <content-sizing> | none | inherit",
        "min-height": "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit",
        "min-width": "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit",
        "move-to": 1,

        //N
        "nav-down": 1,
        "nav-index": 1,
        "nav-left": 1,
        "nav-right": 1,
        "nav-up": 1,

        //O
        "object-fit": "fill | contain | cover | none | scale-down",
        "object-position": "<bg-position>",
        "opacity": "<number> | inherit",
        "order": "<integer>",
        "-webkit-order": "<integer>",
        "orphans": "<integer> | inherit",
        "outline": 1,
        "outline-color": "<color> | invert | inherit",
        "outline-offset": 1,
        "outline-style": "<border-style> | inherit",
        "outline-width": "<border-width> | inherit",
        "overflow": "visible | hidden | scroll | auto | inherit",
        "overflow-style": 1,
        "overflow-wrap": "normal | break-word",
        "overflow-x": 1,
        "overflow-y": 1,

        //P
        "padding": { multi: "<padding-width> | inherit", max: 4 },
        "padding-bottom": "<padding-width> | inherit",
        "padding-left": "<padding-width> | inherit",
        "padding-right": "<padding-width> | inherit",
        "padding-top": "<padding-width> | inherit",
        "page": 1,
        "page-break-after": "auto | always | avoid | left | right | inherit",
        "page-break-before": "auto | always | avoid | left | right | inherit",
        "page-break-inside": "auto | avoid | inherit",
        "page-policy": 1,
        "pause": 1,
        "pause-after": 1,
        "pause-before": 1,
        "perspective": 1,
        "perspective-origin": 1,
        "phonemes": 1,
        "pitch": 1,
        "pitch-range": 1,
        "play-during": 1,
        "pointer-events": "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
        "position": "static | relative | absolute | fixed | inherit",
        "presentation-level": 1,
        "punctuation-trim": 1,

        //Q
        "quotes": 1,

        //R
        "rendering-intent": 1,
        "resize": 1,
        "rest": 1,
        "rest-after": 1,
        "rest-before": 1,
        "richness": 1,
        "right": "<margin-width> | inherit",
        "rotation": 1,
        "rotation-point": 1,
        "ruby-align": 1,
        "ruby-overhang": 1,
        "ruby-position": 1,
        "ruby-span": 1,

        //S
        "size": 1,
        "speak": "normal | none | spell-out | inherit",
        "speak-header": "once | always | inherit",
        "speak-numeral": "digits | continuous | inherit",
        "speak-punctuation": "code | none | inherit",
        "speech-rate": 1,
        "src": 1,
        "stress": 1,
        "string-set": 1,

        "table-layout": "auto | fixed | inherit",
        "tab-size": "<integer> | <length>",
        "target": 1,
        "target-name": 1,
        "target-new": 1,
        "target-position": 1,
        "text-align": "left | right | center | justify | match-parent | start | end | inherit",
        "text-align-last": 1,
        "text-decoration": 1,
        "text-emphasis": 1,
        "text-height": 1,
        "text-indent": "<length> | <percentage> | inherit",
        "text-justify": "auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida",
        "text-outline": 1,
        "text-overflow": 1,
        "text-rendering": "auto | optimizeSpeed | optimizeLegibility | geometricPrecision | inherit",
        "text-shadow": 1,
        "text-transform": "capitalize | uppercase | lowercase | none | inherit",
        "text-wrap": "normal | none | avoid",
        "top": "<margin-width> | inherit",
        "-ms-touch-action": "auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation",
        "touch-action": "auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation",
        "transform": 1,
        "transform-origin": 1,
        "transform-style": 1,
        "transition": 1,
        "transition-delay": 1,
        "transition-duration": 1,
        "transition-property": 1,
        "transition-timing-function": 1,

        //U
        "unicode-bidi": "normal | embed | isolate | bidi-override | isolate-override | plaintext | inherit",
        "user-modify": "read-only | read-write | write-only | inherit",
        "user-select": "none | text | toggle | element | elements | all | inherit",

        //V
        "vertical-align": "auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | <percentage> | <length> | inherit",
        "visibility": "visible | hidden | collapse | inherit",
        "voice-balance": 1,
        "voice-duration": 1,
        "voice-family": 1,
        "voice-pitch": 1,
        "voice-pitch-range": 1,
        "voice-rate": 1,
        "voice-stress": 1,
        "voice-volume": 1,
        "volume": 1,

        //W
        "white-space": "normal | pre | nowrap | pre-wrap | pre-line | inherit | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap", //http://perishablepress.com/wrapping-content/
        "white-space-collapse": 1,
        "widows": "<integer> | inherit",
        "width": "<length> | <percentage> | <content-sizing> | auto | inherit",
        "will-change": { multi: "<ident>", comma: true },
        "word-break": "normal | keep-all | break-all",
        "word-spacing": "<length> | normal | inherit",
        "word-wrap": "normal | break-word",
        "writing-mode": "horizontal-tb | vertical-rl | vertical-lr | lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb | inherit",

        //Z
        "z-index": "<integer> | auto | inherit",
        "zoom": "<number> | <percentage> | normal"
    };
    /**
     * Represents a selector combinator (whitespace, +, >).
     * @namespace parserlib.css
     * @class PropertyName
     * @extends parserlib.util.SyntaxUnit
     * @constructor
     * @param {String} text The text representation of the unit.
     * @param {String} hack The type of IE hack applied ("*", "_", or null).
     * @param {int} line The line of text on which the unit resides.
     * @param {int} col The column of text on which the unit resides.
     */
    function PropertyName(text, hack, line, col) {

        SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);

        /**
         * The type of IE hack applied ("*", "_", or null).
         * @type String
         * @property hack
         */
        this.hack = hack;
    }

    PropertyName.prototype = new SyntaxUnit();
    PropertyName.prototype.constructor = PropertyName;
    PropertyName.prototype.toString = function () {
        return (this.hack ? this.hack : "") + this.text;
    };
    /**
     * Represents a single part of a CSS property value, meaning that it represents
     * just everything single part between ":" and ";". If there are multiple values
     * separated by commas, this type represents just one of the values.
     * @param {String[]} parts An array of value parts making up this value.
     * @param {int} line The line of text on which the unit resides.
     * @param {int} col The column of text on which the unit resides.
     * @namespace parserlib.css
     * @class PropertyValue
     * @extends parserlib.util.SyntaxUnit
     * @constructor
     */
    function PropertyValue(parts, line, col) {

        SyntaxUnit.call(this, parts.join(" "), line, col, Parser.PROPERTY_VALUE_TYPE);

        /**
         * The parts that make up the selector.
         * @type Array
         * @property parts
         */
        this.parts = parts;
    }

    PropertyValue.prototype = new SyntaxUnit();
    PropertyValue.prototype.constructor = PropertyValue;

    /**
     * A utility class that allows for easy iteration over the various parts of a
     * property value.
     * @param {parserlib.css.PropertyValue} value The property value to iterate over.
     * @namespace parserlib.css
     * @class PropertyValueIterator
     * @constructor
     */
    function PropertyValueIterator(value) {

        /**
         * Iterator value
         * @type int
         * @property _i
         * @private
         */
        this._i = 0;

        /**
         * The parts that make up the value.
         * @type Array
         * @property _parts
         * @private
         */
        this._parts = value.parts;

        /**
         * Keeps track of bookmarks along the way.
         * @type Array
         * @property _marks
         * @private
         */
        this._marks = [];

        /**
         * Holds the original property value.
         * @type parserlib.css.PropertyValue
         * @property value
         */
        this.value = value;
    }

    /**
     * Returns the total number of parts in the value.
     * @return {int} The total number of parts in the value.
     * @method count
     */
    PropertyValueIterator.prototype.count = function () {
        return this._parts.length;
    };

    /**
     * Indicates if the iterator is positioned at the first item.
     * @return {Boolean} True if positioned at first item, false if not.
     * @method isFirst
     */
    PropertyValueIterator.prototype.isFirst = function () {
        return this._i === 0;
    };

    /**
     * Indicates if there are more parts of the property value.
     * @return {Boolean} True if there are more parts, false if not.
     * @method hasNext
     */
    PropertyValueIterator.prototype.hasNext = function () {
        return this._i < this._parts.length;
    };

    /**
     * Marks the current spot in the iteration so it can be restored to
     * later on.
     * @return {void}
     * @method mark
     */
    PropertyValueIterator.prototype.mark = function () {
        this._marks.push(this._i);
    };

    /**
     * Returns the next part of the property value or null if there is no next
     * part. Does not move the internal counter forward.
     * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next
     * part.
     * @method peek
     */
    PropertyValueIterator.prototype.peek = function (count) {
        return this.hasNext() ? this._parts[this._i + (count || 0)] : null;
    };

    /**
     * Returns the next part of the property value or null if there is no next
     * part.
     * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next
     * part.
     * @method next
     */
    PropertyValueIterator.prototype.next = function () {
        return this.hasNext() ? this._parts[this._i++] : null;
    };

    /**
     * Returns the previous part of the property value or null if there is no
     * previous part.
     * @return {parserlib.css.PropertyValuePart} The previous part of the
     * property value or null if there is no previous part.
     * @method previous
     */
    PropertyValueIterator.prototype.previous = function () {
        return this._i > 0 ? this._parts[--this._i] : null;
    };

    /**
     * Restores the last saved bookmark.
     * @return {void}
     * @method restore
     */
    PropertyValueIterator.prototype.restore = function () {
        if (this._marks.length) {
            this._i = this._marks.pop();
        }
    };

    /**
     * Represents a single part of a CSS property value, meaning that it represents
     * just one part of the data between ":" and ";".
     * @param {String} text The text representation of the unit.
     * @param {int} line The line of text on which the unit resides.
     * @param {int} col The column of text on which the unit resides.
     * @namespace parserlib.css
     * @class PropertyValuePart
     * @extends parserlib.util.SyntaxUnit
     * @constructor
     */
    function PropertyValuePart(text, line, col) {

        SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);

        /**
         * Indicates the type of value unit.
         * @type String
         * @property type
         */
        this.type = "unknown";

        //figure out what type of data it is

        var temp;

        //it is a measurement?
        if (/^([+\-]?[\d\.]+)([a-z]+)$/i.test(text)) {
            //dimension
            this.type = "dimension";
            this.value = +RegExp.$1;
            this.units = RegExp.$2;

            //try to narrow down
            switch (this.units.toLowerCase()) {

                case "em":
                case "rem":
                case "ex":
                case "px":
                case "cm":
                case "mm":
                case "in":
                case "pt":
                case "pc":
                case "ch":
                case "vh":
                case "vw":
                case "vmax":
                case "vmin":
                    this.type = "length";
                    break;

                case "fr":
                    this.type = "grid";
                    break;

                case "deg":
                case "rad":
                case "grad":
                    this.type = "angle";
                    break;

                case "ms":
                case "s":
                    this.type = "time";
                    break;

                case "hz":
                case "khz":
                    this.type = "frequency";
                    break;

                case "dpi":
                case "dpcm":
                    this.type = "resolution";
                    break;

                //default

            }
        } else if (/^([+\-]?[\d\.]+)%$/i.test(text)) {
            //percentage
            this.type = "percentage";
            this.value = +RegExp.$1;
        } else if (/^([+\-]?\d+)$/i.test(text)) {
            //integer
            this.type = "integer";
            this.value = +RegExp.$1;
        } else if (/^([+\-]?[\d\.]+)$/i.test(text)) {
            //number
            this.type = "number";
            this.value = +RegExp.$1;
        } else if (/^#([a-f0-9]{3,6})/i.test(text)) {
            //hexcolor
            this.type = "color";
            temp = RegExp.$1;
            if (temp.length === 3) {
                this.red = parseInt(temp.charAt(0) + temp.charAt(0), 16);
                this.green = parseInt(temp.charAt(1) + temp.charAt(1), 16);
                this.blue = parseInt(temp.charAt(2) + temp.charAt(2), 16);
            } else {
                this.red = parseInt(temp.substring(0, 2), 16);
                this.green = parseInt(temp.substring(2, 4), 16);
                this.blue = parseInt(temp.substring(4, 6), 16);
            }
        } else if (/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.test(text)) {
            //rgb() color with absolute numbers
            this.type = "color";
            this.red = +RegExp.$1;
            this.green = +RegExp.$2;
            this.blue = +RegExp.$3;
        } else if (/^rgb\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) {
            //rgb() color with percentages
            this.type = "color";
            this.red = +RegExp.$1 * 255 / 100;
            this.green = +RegExp.$2 * 255 / 100;
            this.blue = +RegExp.$3 * 255 / 100;
        } else if (/^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/i.test(text)) {
            //rgba() color with absolute numbers
            this.type = "color";
            this.red = +RegExp.$1;
            this.green = +RegExp.$2;
            this.blue = +RegExp.$3;
            this.alpha = +RegExp.$4;
        } else if (/^rgba\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)) {
            //rgba() color with percentages
            this.type = "color";
            this.red = +RegExp.$1 * 255 / 100;
            this.green = +RegExp.$2 * 255 / 100;
            this.blue = +RegExp.$3 * 255 / 100;
            this.alpha = +RegExp.$4;
        } else if (/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) {
            //hsl()
            this.type = "color";
            this.hue = +RegExp.$1;
            this.saturation = +RegExp.$2 / 100;
            this.lightness = +RegExp.$3 / 100;
        } else if (/^hsla\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)) {
            //hsla() color with percentages
            this.type = "color";
            this.hue = +RegExp.$1;
            this.saturation = +RegExp.$2 / 100;
            this.lightness = +RegExp.$3 / 100;
            this.alpha = +RegExp.$4;
        } else if (/^url\(["']?([^\)"']+)["']?\)/i.test(text)) {
            //URI
            this.type = "uri";
            this.uri = RegExp.$1;
        } else if (/^([^\(]+)\(/i.test(text)) {
            this.type = "function";
            this.name = RegExp.$1;
            this.value = text;
        } else if (/^"([^\n\r\f\\"]|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*"/i.test(text)) {
            //double-quoted string
            this.type = "string";
            this.value = PropertyValuePart.parseString(text);
        } else if (/^'([^\n\r\f\\']|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*'/i.test(text)) {
            //single-quoted string
            this.type = "string";
            this.value = PropertyValuePart.parseString(text);
        } else if (Colors[text.toLowerCase()]) {
            //named color
            this.type = "color";
            temp = Colors[text.toLowerCase()].substring(1);
            this.red = parseInt(temp.substring(0, 2), 16);
            this.green = parseInt(temp.substring(2, 4), 16);
            this.blue = parseInt(temp.substring(4, 6), 16);
        } else if (/^[\,\/]$/.test(text)) {
            this.type = "operator";
            this.value = text;
        } else if (/^[a-z\-_\u0080-\uFFFF][a-z0-9\-_\u0080-\uFFFF]*$/i.test(text)) {
            this.type = "identifier";
            this.value = text;
        }
    }

    PropertyValuePart.prototype = new SyntaxUnit();
    PropertyValuePart.prototype.constructor = PropertyValuePart;

    /**
     * Helper method to parse a CSS string.
     */
    PropertyValuePart.parseString = function (str) {
        str = str.slice(1, -1); // Strip surrounding single/double quotes
        var replacer = function replacer(match, esc) {
            if (/^(\n|\r\n|\r|\f)$/.test(esc)) {
                return '';
            }
            var m = /^[0-9a-f]{1,6}/i.exec(esc);
            if (m) {
                var codePoint = parseInt(m[0], 16);
                if (String.fromCodePoint) {
                    return String.fromCodePoint(codePoint);
                } else {
                    // XXX No support for surrogates on old JavaScript engines.
                    return String.fromCharCode(codePoint);
                }
            }
            return esc;
        };
        return str.replace(/\\(\r\n|[^\r0-9a-f]|[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)/ig, replacer);
    };

    /**
     * Helper method to serialize a CSS string.
     */
    PropertyValuePart.serializeString = function (value) {
        var replacer = function replacer(match, c) {
            if (c === '"') {
                return "\\" + c;
            }
            var cp = String.codePointAt ? String.codePointAt(0) :
            // We only escape non-surrogate chars, so using charCodeAt
            // is harmless here.
            String.charCodeAt(0);
            return "\\" + cp.toString(16) + " ";
        };
        return '"' + value.replace(/["\r\n\f]/g, replacer) + '"';
    };

    /**
     * Create a new syntax unit based solely on the given token.
     * Convenience method for creating a new syntax unit when
     * it represents a single token instead of multiple.
     * @param {Object} token The token object to represent.
     * @return {parserlib.css.PropertyValuePart} The object representing the token.
     * @static
     * @method fromToken
     */
    PropertyValuePart.fromToken = function (token) {
        return new PropertyValuePart(token.value, token.startLine, token.startCol);
    };
    var Pseudos = {
        __proto__: null,
        ":first-letter": 1,
        ":first-line": 1,
        ":before": 1,
        ":after": 1
    };

    Pseudos.ELEMENT = 1;
    Pseudos.CLASS = 2;

    Pseudos.isElement = function (pseudo) {
        return pseudo.indexOf("::") === 0 || Pseudos[pseudo.toLowerCase()] === Pseudos.ELEMENT;
    };
    /**
     * Represents an entire single selector, including all parts but not
     * including multiple selectors (those separated by commas).
     * @namespace parserlib.css
     * @class Selector
     * @extends parserlib.util.SyntaxUnit
     * @constructor
     * @param {Array} parts Array of selectors parts making up this selector.
     * @param {int} line The line of text on which the unit resides.
     * @param {int} col The column of text on which the unit resides.
     */
    function Selector(parts, line, col) {

        SyntaxUnit.call(this, parts.join(" "), line, col, Parser.SELECTOR_TYPE);

        /**
         * The parts that make up the selector.
         * @type Array
         * @property parts
         */
        this.parts = parts;

        /**
         * The specificity of the selector.
         * @type parserlib.css.Specificity
         * @property specificity
         */
        this.specificity = Specificity.calculate(this);
    }

    Selector.prototype = new SyntaxUnit();
    Selector.prototype.constructor = Selector;

    /**
     * Represents a single part of a selector string, meaning a single set of
     * element name and modifiers. This does not include combinators such as
     * spaces, +, >, etc.
     * @namespace parserlib.css
     * @class SelectorPart
     * @extends parserlib.util.SyntaxUnit
     * @constructor
     * @param {String} elementName The element name in the selector or null
     *      if there is no element name.
     * @param {Array} modifiers Array of individual modifiers for the element.
     *      May be empty if there are none.
     * @param {String} text The text representation of the unit.
     * @param {int} line The line of text on which the unit resides.
     * @param {int} col The column of text on which the unit resides.
     */
    function SelectorPart(elementName, modifiers, text, line, col) {

        SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);

        /**
         * The tag name of the element to which this part
         * of the selector affects.
         * @type String
         * @property elementName
         */
        this.elementName = elementName;

        /**
         * The parts that come after the element name, such as class names, IDs,
         * pseudo classes/elements, etc.
         * @type Array
         * @property modifiers
         */
        this.modifiers = modifiers;
    }

    SelectorPart.prototype = new SyntaxUnit();
    SelectorPart.prototype.constructor = SelectorPart;

    /**
     * Represents a selector modifier string, meaning a class name, element name,
     * element ID, pseudo rule, etc.
     * @namespace parserlib.css
     * @class SelectorSubPart
     * @extends parserlib.util.SyntaxUnit
     * @constructor
     * @param {String} text The text representation of the unit.
     * @param {String} type The type of selector modifier.
     * @param {int} line The line of text on which the unit resides.
     * @param {int} col The column of text on which the unit resides.
     */
    function SelectorSubPart(text, type, line, col) {

        SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);

        /**
         * The type of modifier.
         * @type String
         * @property type
         */
        this.type = type;

        /**
         * Some subparts have arguments, this represents them.
         * @type Array
         * @property args
         */
        this.args = [];
    }

    SelectorSubPart.prototype = new SyntaxUnit();
    SelectorSubPart.prototype.constructor = SelectorSubPart;

    /**
     * Represents a selector's specificity.
     * @namespace parserlib.css
     * @class Specificity
     * @constructor
     * @param {int} a Should be 1 for inline styles, zero for stylesheet styles
     * @param {int} b Number of ID selectors
     * @param {int} c Number of classes and pseudo classes
     * @param {int} d Number of element names and pseudo elements
     */
    function Specificity(a, b, c, d) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }

    Specificity.prototype = {
        constructor: Specificity,

        /**
         * Compare this specificity to another.
         * @param {Specificity} other The other specificity to compare to.
         * @return {int} -1 if the other specificity is larger, 1 if smaller, 0 if equal.
         * @method compare
         */
        compare: function compare(other) {
            var comps = ["a", "b", "c", "d"],
                i,
                len;

            for (i = 0, len = comps.length; i < len; i++) {
                if (this[comps[i]] < other[comps[i]]) {
                    return -1;
                } else if (this[comps[i]] > other[comps[i]]) {
                    return 1;
                }
            }

            return 0;
        },

        /**
         * Creates a numeric value for the specificity.
         * @return {int} The numeric value for the specificity.
         * @method valueOf
         */
        valueOf: function valueOf() {
            return this.a * 1000 + this.b * 100 + this.c * 10 + this.d;
        },

        /**
         * Returns a string representation for specificity.
         * @return {String} The string representation of specificity.
         * @method toString
         */
        toString: function toString() {
            return this.a + "," + this.b + "," + this.c + "," + this.d;
        }

    };

    /**
     * Calculates the specificity of the given selector.
     * @param {parserlib.css.Selector} The selector to calculate specificity for.
     * @return {parserlib.css.Specificity} The specificity of the selector.
     * @static
     * @method calculate
     */
    Specificity.calculate = function (selector) {

        var i,
            len,
            part,
            b = 0,
            c = 0,
            d = 0;

        function updateValues(part) {

            var i,
                j,
                len,
                num,
                elementName = part.elementName ? part.elementName.text : "",
                modifier;

            if (elementName && elementName.charAt(elementName.length - 1) !== "*") {
                d++;
            }

            for (i = 0, len = part.modifiers.length; i < len; i++) {
                modifier = part.modifiers[i];
                switch (modifier.type) {
                    case "class":
                    case "attribute":
                        c++;
                        break;

                    case "id":
                        b++;
                        break;

                    case "pseudo":
                        if (Pseudos.isElement(modifier.text)) {
                            d++;
                        } else {
                            c++;
                        }
                        break;

                    case "not":
                        for (j = 0, num = modifier.args.length; j < num; j++) {
                            updateValues(modifier.args[j]);
                        }
                }
            }
        }

        for (i = 0, len = selector.parts.length; i < len; i++) {
            part = selector.parts[i];

            if (part instanceof SelectorPart) {
                updateValues(part);
            }
        }

        return new Specificity(0, b, c, d);
    };

    var h = /^[0-9a-fA-F]$/,

    //nonascii = /^[\u0080-\uFFFF]$/,
    nl = /\n|\r\n|\r|\f/;

    //-----------------------------------------------------------------------------
    // Helper functions
    //-----------------------------------------------------------------------------


    function isHexDigit(c) {
        return c !== null && h.test(c);
    }

    function isDigit(c) {
        return c !== null && /\d/.test(c);
    }

    function isWhitespace(c) {
        return c !== null && /\s/.test(c);
    }

    function isNewLine(c) {
        return c !== null && nl.test(c);
    }

    function isNameStart(c) {
        return c !== null && /[a-z_\u0080-\uFFFF\\]/i.test(c);
    }

    function isNameChar(c) {
        return c !== null && (isNameStart(c) || /[0-9\-\\]/.test(c));
    }

    function isIdentStart(c) {
        return c !== null && (isNameStart(c) || /\-\\/.test(c));
    }

    function mix(receiver, supplier) {
        for (var prop in supplier) {
            if (Object.prototype.hasOwnProperty.call(supplier, prop)) {
                receiver[prop] = supplier[prop];
            }
        }
        return receiver;
    }

    //-----------------------------------------------------------------------------
    // CSS Token Stream
    //-----------------------------------------------------------------------------


    /**
     * A token stream that produces CSS tokens.
     * @param {String|Reader} input The source of text to tokenize.
     * @constructor
     * @class TokenStream
     * @namespace parserlib.css
     */
    function TokenStream(input) {
        TokenStreamBase.call(this, input, Tokens);
    }

    TokenStream.prototype = mix(new TokenStreamBase(), {

        /**
         * Overrides the TokenStreamBase method of the same name
         * to produce CSS tokens.
         * @param {variant} channel The name of the channel to use
         *      for the next token.
         * @return {Object} A token object representing the next token.
         * @method _getToken
         * @private
         */
        _getToken: function _getToken(channel) {

            var c,
                reader = this._reader,
                token = null,
                startLine = reader.getLine(),
                startCol = reader.getCol();

            c = reader.read();

            while (c) {
                switch (c) {

                    /*
                     * Potential tokens:
                     * - COMMENT
                     * - SLASH
                     * - CHAR
                     */
                    case "/":

                        if (reader.peek() === "*") {
                            token = this.commentToken(c, startLine, startCol);
                        } else {
                            token = this.charToken(c, startLine, startCol);
                        }
                        break;

                    /*
                     * Potential tokens:
                     * - DASHMATCH
                     * - INCLUDES
                     * - PREFIXMATCH
                     * - SUFFIXMATCH
                     * - SUBSTRINGMATCH
                     * - CHAR
                     */
                    case "|":
                    case "~":
                    case "^":
                    case "$":
                    case "*":
                        if (reader.peek() === "=") {
                            token = this.comparisonToken(c, startLine, startCol);
                        } else {
                            token = this.charToken(c, startLine, startCol);
                        }
                        break;

                    /*
                     * Potential tokens:
                     * - STRING
                     * - INVALID
                     */
                    case "\"":
                    case "'":
                        token = this.stringToken(c, startLine, startCol);
                        break;

                    /*
                     * Potential tokens:
                     * - HASH
                     * - CHAR
                     */
                    case "#":
                        if (isNameChar(reader.peek())) {
                            token = this.hashToken(c, startLine, startCol);
                        } else {
                            token = this.charToken(c, startLine, startCol);
                        }
                        break;

                    /*
                     * Potential tokens:
                     * - DOT
                     * - NUMBER
                     * - DIMENSION
                     * - PERCENTAGE
                     */
                    case ".":
                        if (isDigit(reader.peek())) {
                            token = this.numberToken(c, startLine, startCol);
                        } else {
                            token = this.charToken(c, startLine, startCol);
                        }
                        break;

                    /*
                     * Potential tokens:
                     * - CDC
                     * - MINUS
                     * - NUMBER
                     * - DIMENSION
                     * - PERCENTAGE
                     */
                    case "-":
                        if (reader.peek() === "-") {
                            //could be closing HTML-style comment
                            token = this.htmlCommentEndToken(c, startLine, startCol);
                        } else if (isNameStart(reader.peek())) {
                            token = this.identOrFunctionToken(c, startLine, startCol);
                        } else {
                            token = this.charToken(c, startLine, startCol);
                        }
                        break;

                    /*
                     * Potential tokens:
                     * - IMPORTANT_SYM
                     * - CHAR
                     */
                    case "!":
                        token = this.importantToken(c, startLine, startCol);
                        break;

                    /*
                     * Any at-keyword or CHAR
                     */
                    case "@":
                        token = this.atRuleToken(c, startLine, startCol);
                        break;

                    /*
                     * Potential tokens:
                     * - NOT
                     * - CHAR
                     */
                    case ":":
                        token = this.notToken(c, startLine, startCol);
                        break;

                    /*
                     * Potential tokens:
                     * - CDO
                     * - CHAR
                     */
                    case "<":
                        token = this.htmlCommentStartToken(c, startLine, startCol);
                        break;

                    /*
                     * Potential tokens:
                     * - UNICODE_RANGE
                     * - URL
                     * - CHAR
                     */
                    case "U":
                    case "u":
                        if (reader.peek() === "+") {
                            token = this.unicodeRangeToken(c, startLine, startCol);
                            break;
                        }
                    /* falls through */
                    default:

                        /*
                         * Potential tokens:
                         * - NUMBER
                         * - DIMENSION
                         * - LENGTH
                         * - FREQ
                         * - TIME
                         * - EMS
                         * - EXS
                         * - ANGLE
                         */
                        if (isDigit(c)) {
                            token = this.numberToken(c, startLine, startCol);
                        } else

                            /*
                             * Potential tokens:
                             * - S
                             */
                            if (isWhitespace(c)) {
                                token = this.whitespaceToken(c, startLine, startCol);
                            } else

                                /*
                                 * Potential tokens:
                                 * - IDENT
                                 */
                                if (isIdentStart(c)) {
                                    token = this.identOrFunctionToken(c, startLine, startCol);
                                } else

                                    /*
                                     * Potential tokens:
                                     * - CHAR
                                     * - PLUS
                                     */
                                    {
                                        token = this.charToken(c, startLine, startCol);
                                    }

                }

                //make sure this token is wanted
                //TODO: check channel
                break;
            }

            if (!token && c === null) {
                token = this.createToken(Tokens.EOF, null, startLine, startCol);
            }

            return token;
        },

        //-------------------------------------------------------------------------
        // Methods to create tokens
        //-------------------------------------------------------------------------

        /**
         * Produces a token based on available data and the current
         * reader position information. This method is called by other
         * private methods to create tokens and is never called directly.
         * @param {int} tt The token type.
         * @param {String} value The text value of the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @param {Object} options (Optional) Specifies a channel property
         *      to indicate that a different channel should be scanned
         *      and/or a hide property indicating that the token should
         *      be hidden.
         * @return {Object} A token object.
         * @method createToken
         */
        createToken: function createToken(tt, value, startLine, startCol, options) {
            var reader = this._reader;
            options = options || {};

            return {
                value: value,
                type: tt,
                channel: options.channel,
                endChar: options.endChar,
                hide: options.hide || false,
                startLine: startLine,
                startCol: startCol,
                endLine: reader.getLine(),
                endCol: reader.getCol()
            };
        },

        //-------------------------------------------------------------------------
        // Methods to create specific tokens
        //-------------------------------------------------------------------------

        /**
         * Produces a token for any at-rule. If the at-rule is unknown, then
         * the token is for a single "@" character.
         * @param {String} first The first character for the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method atRuleToken
         */
        atRuleToken: function atRuleToken(first, startLine, startCol) {
            var rule = first,
                reader = this._reader,
                tt = Tokens.CHAR,
                ident;

            /*
             * First, mark where we are. There are only four @ rules,
             * so anything else is really just an invalid token.
             * Basically, if this doesn't match one of the known @
             * rules, just return '@' as an unknown token and allow
             * parsing to continue after that point.
             */
            reader.mark();

            //try to find the at-keyword
            ident = this.readName();
            rule = first + ident;
            tt = Tokens.type(rule.toLowerCase());

            //if it's not valid, use the first character only and reset the reader
            if (tt === Tokens.CHAR || tt === Tokens.UNKNOWN) {
                if (rule.length > 1) {
                    tt = Tokens.UNKNOWN_SYM;
                } else {
                    tt = Tokens.CHAR;
                    rule = first;
                    reader.reset();
                }
            }

            return this.createToken(tt, rule, startLine, startCol);
        },

        /**
         * Produces a character token based on the given character
         * and location in the stream. If there's a special (non-standard)
         * token name, this is used; otherwise CHAR is used.
         * @param {String} c The character for the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method charToken
         */
        charToken: function charToken(c, startLine, startCol) {
            var tt = Tokens.type(c);
            var opts = {};

            if (tt === -1) {
                tt = Tokens.CHAR;
            } else {
                opts.endChar = Tokens[tt].endChar;
            }

            return this.createToken(tt, c, startLine, startCol, opts);
        },

        /**
         * Produces a character token based on the given character
         * and location in the stream. If there's a special (non-standard)
         * token name, this is used; otherwise CHAR is used.
         * @param {String} first The first character for the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method commentToken
         */
        commentToken: function commentToken(first, startLine, startCol) {
            var comment = this.readComment(first);

            return this.createToken(Tokens.COMMENT, comment, startLine, startCol);
        },

        /**
         * Produces a comparison token based on the given character
         * and location in the stream. The next character must be
         * read and is already known to be an equals sign.
         * @param {String} c The character for the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method comparisonToken
         */
        comparisonToken: function comparisonToken(c, startLine, startCol) {
            var reader = this._reader,
                comparison = c + reader.read(),
                tt = Tokens.type(comparison) || Tokens.CHAR;

            return this.createToken(tt, comparison, startLine, startCol);
        },

        /**
         * Produces a hash token based on the specified information. The
         * first character provided is the pound sign (#) and then this
         * method reads a name afterward.
         * @param {String} first The first character (#) in the hash name.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method hashToken
         */
        hashToken: function hashToken(first, startLine, startCol) {
            var name = this.readName(first);

            return this.createToken(Tokens.HASH, name, startLine, startCol);
        },

        /**
         * Produces a CDO or CHAR token based on the specified information. The
         * first character is provided and the rest is read by the function to determine
         * the correct token to create.
         * @param {String} first The first character in the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method htmlCommentStartToken
         */
        htmlCommentStartToken: function htmlCommentStartToken(first, startLine, startCol) {
            var reader = this._reader,
                text = first;

            reader.mark();
            text += reader.readCount(3);

            if (text === "<!--") {
                return this.createToken(Tokens.CDO, text, startLine, startCol);
            } else {
                reader.reset();
                return this.charToken(first, startLine, startCol);
            }
        },

        /**
         * Produces a CDC or CHAR token based on the specified information. The
         * first character is provided and the rest is read by the function to determine
         * the correct token to create.
         * @param {String} first The first character in the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method htmlCommentEndToken
         */
        htmlCommentEndToken: function htmlCommentEndToken(first, startLine, startCol) {
            var reader = this._reader,
                text = first;

            reader.mark();
            text += reader.readCount(2);

            if (text === "-->") {
                return this.createToken(Tokens.CDC, text, startLine, startCol);
            } else {
                reader.reset();
                return this.charToken(first, startLine, startCol);
            }
        },

        /**
         * Produces an IDENT or FUNCTION token based on the specified information. The
         * first character is provided and the rest is read by the function to determine
         * the correct token to create.
         * @param {String} first The first character in the identifier.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method identOrFunctionToken
         */
        identOrFunctionToken: function identOrFunctionToken(first, startLine, startCol) {
            var reader = this._reader,
                ident = this.readName(first),
                tt = Tokens.IDENT,
                uriFns = ["url(", "url-prefix(", "domain("];

            //if there's a left paren immediately after, it's a URI or function
            if (reader.peek() === "(") {
                ident += reader.read();
                if (uriFns.indexOf(ident.toLowerCase()) > -1) {
                    tt = Tokens.URI;
                    ident = this.readURI(ident);

                    //didn't find a valid URL or there's no closing paren
                    if (uriFns.indexOf(ident.toLowerCase()) > -1) {
                        tt = Tokens.FUNCTION;
                    }
                } else {
                    tt = Tokens.FUNCTION;
                }
            } else if (reader.peek() === ":") {
                //might be an IE function

                //IE-specific functions always being with progid:
                if (ident.toLowerCase() === "progid") {
                    ident += reader.readTo("(");
                    tt = Tokens.IE_FUNCTION;
                }
            }

            return this.createToken(tt, ident, startLine, startCol);
        },

        /**
         * Produces an IMPORTANT_SYM or CHAR token based on the specified information. The
         * first character is provided and the rest is read by the function to determine
         * the correct token to create.
         * @param {String} first The first character in the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method importantToken
         */
        importantToken: function importantToken(first, startLine, startCol) {
            var reader = this._reader,
                important = first,
                tt = Tokens.CHAR,
                temp,
                c;

            reader.mark();
            c = reader.read();

            while (c) {

                //there can be a comment in here
                if (c === "/") {

                    //if the next character isn't a star, then this isn't a valid !important token
                    if (reader.peek() !== "*") {
                        break;
                    } else {
                        temp = this.readComment(c);
                        if (temp === "") {
                            //broken!
                            break;
                        }
                    }
                } else if (isWhitespace(c)) {
                    important += c + this.readWhitespace();
                } else if (/i/i.test(c)) {
                    temp = reader.readCount(8);
                    if (/mportant/i.test(temp)) {
                        important += c + temp;
                        tt = Tokens.IMPORTANT_SYM;
                    }
                    break; //we're done
                } else {
                    break;
                }

                c = reader.read();
            }

            if (tt === Tokens.CHAR) {
                reader.reset();
                return this.charToken(first, startLine, startCol);
            } else {
                return this.createToken(tt, important, startLine, startCol);
            }
        },

        /**
         * Produces a NOT or CHAR token based on the specified information. The
         * first character is provided and the rest is read by the function to determine
         * the correct token to create.
         * @param {String} first The first character in the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method notToken
         */
        notToken: function notToken(first, startLine, startCol) {
            var reader = this._reader,
                text = first;

            reader.mark();
            text += reader.readCount(4);

            if (text.toLowerCase() === ":not(") {
                return this.createToken(Tokens.NOT, text, startLine, startCol);
            } else {
                reader.reset();
                return this.charToken(first, startLine, startCol);
            }
        },

        /**
         * Produces a number token based on the given character
         * and location in the stream. This may return a token of
         * NUMBER, EMS, EXS, LENGTH, ANGLE, TIME, FREQ, DIMENSION,
         * or PERCENTAGE.
         * @param {String} first The first character for the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method numberToken
         */
        numberToken: function numberToken(first, startLine, startCol) {
            var reader = this._reader,
                value = this.readNumber(first),
                ident,
                tt = Tokens.NUMBER,
                c = reader.peek();

            if (isIdentStart(c)) {
                ident = this.readName(reader.read());
                value += ident;

                if (/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vmax$|^vmin$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)) {
                    tt = Tokens.LENGTH;
                } else if (/^deg|^rad$|^grad$/i.test(ident)) {
                    tt = Tokens.ANGLE;
                } else if (/^ms$|^s$/i.test(ident)) {
                    tt = Tokens.TIME;
                } else if (/^hz$|^khz$/i.test(ident)) {
                    tt = Tokens.FREQ;
                } else if (/^dpi$|^dpcm$/i.test(ident)) {
                    tt = Tokens.RESOLUTION;
                } else {
                    tt = Tokens.DIMENSION;
                }
            } else if (c === "%") {
                value += reader.read();
                tt = Tokens.PERCENTAGE;
            }

            return this.createToken(tt, value, startLine, startCol);
        },

        /**
         * Produces a string token based on the given character
         * and location in the stream. Since strings may be indicated
         * by single or double quotes, a failure to match starting
         * and ending quotes results in an INVALID token being generated.
         * The first character in the string is passed in and then
         * the rest are read up to and including the final quotation mark.
         * @param {String} first The first character in the string.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method stringToken
         */
        stringToken: function stringToken(first, startLine, startCol) {
            var delim = first,
                string = first,
                reader = this._reader,
                prev = first,
                tt = Tokens.STRING,
                c = reader.read();

            while (c) {
                string += c;

                //if the delimiter is found with an escapement, we're done.
                if (c === delim && prev !== "\\") {
                    break;
                }

                //if there's a newline without an escapement, it's an invalid string
                if (isNewLine(reader.peek()) && c !== "\\") {
                    tt = Tokens.INVALID;
                    break;
                }

                //save previous and get next
                prev = c;
                c = reader.read();
            }

            //if c is null, that means we're out of input and the string was never closed
            if (c === null) {
                tt = Tokens.INVALID;
            }

            return this.createToken(tt, string, startLine, startCol);
        },

        unicodeRangeToken: function unicodeRangeToken(first, startLine, startCol) {
            var reader = this._reader,
                value = first,
                temp,
                tt = Tokens.CHAR;

            //then it should be a unicode range
            if (reader.peek() === "+") {
                reader.mark();
                value += reader.read();
                value += this.readUnicodeRangePart(true);

                //ensure there's an actual unicode range here
                if (value.length === 2) {
                    reader.reset();
                } else {

                    tt = Tokens.UNICODE_RANGE;

                    //if there's a ? in the first part, there can't be a second part
                    if (value.indexOf("?") === -1) {

                        if (reader.peek() === "-") {
                            reader.mark();
                            temp = reader.read();
                            temp += this.readUnicodeRangePart(false);

                            //if there's not another value, back up and just take the first
                            if (temp.length === 1) {
                                reader.reset();
                            } else {
                                value += temp;
                            }
                        }
                    }
                }
            }

            return this.createToken(tt, value, startLine, startCol);
        },

        /**
         * Produces a S token based on the specified information. Since whitespace
         * may have multiple characters, this consumes all whitespace characters
         * into a single token.
         * @param {String} first The first character in the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method whitespaceToken
         */
        whitespaceToken: function whitespaceToken(first, startLine, startCol) {
            var value = first + this.readWhitespace();
            return this.createToken(Tokens.S, value, startLine, startCol);
        },

        //-------------------------------------------------------------------------
        // Methods to read values from the string stream
        //-------------------------------------------------------------------------

        readUnicodeRangePart: function readUnicodeRangePart(allowQuestionMark) {
            var reader = this._reader,
                part = "",
                c = reader.peek();

            //first read hex digits
            while (isHexDigit(c) && part.length < 6) {
                reader.read();
                part += c;
                c = reader.peek();
            }

            //then read question marks if allowed
            if (allowQuestionMark) {
                while (c === "?" && part.length < 6) {
                    reader.read();
                    part += c;
                    c = reader.peek();
                }
            }

            //there can't be any other characters after this point

            return part;
        },

        readWhitespace: function readWhitespace() {
            var reader = this._reader,
                whitespace = "",
                c = reader.peek();

            while (isWhitespace(c)) {
                reader.read();
                whitespace += c;
                c = reader.peek();
            }

            return whitespace;
        },
        readNumber: function readNumber(first) {
            var reader = this._reader,
                number = first,
                hasDot = first === ".",
                c = reader.peek();

            while (c) {
                if (isDigit(c)) {
                    number += reader.read();
                } else if (c === ".") {
                    if (hasDot) {
                        break;
                    } else {
                        hasDot = true;
                        number += reader.read();
                    }
                } else {
                    break;
                }

                c = reader.peek();
            }

            return number;
        },
        readString: function readString() {
            var reader = this._reader,
                delim = reader.read(),
                string = delim,
                prev = delim,
                c = reader.peek();

            while (c) {
                c = reader.read();
                string += c;

                //if the delimiter is found with an escapement, we're done.
                if (c === delim && prev !== "\\") {
                    break;
                }

                //if there's a newline without an escapement, it's an invalid string
                if (isNewLine(reader.peek()) && c !== "\\") {
                    string = "";
                    break;
                }

                //save previous and get next
                prev = c;
                c = reader.peek();
            }

            //if c is null, that means we're out of input and the string was never closed
            if (c === null) {
                string = "";
            }

            return string;
        },
        readURI: function readURI(first) {
            var reader = this._reader,
                uri = first,
                inner = "",
                c = reader.peek();

            reader.mark();

            //skip whitespace before
            while (c && isWhitespace(c)) {
                reader.read();
                c = reader.peek();
            }

            //it's a string
            if (c === "'" || c === "\"") {
                inner = this.readString();
            } else {
                inner = this.readURL();
            }

            c = reader.peek();

            //skip whitespace after
            while (c && isWhitespace(c)) {
                reader.read();
                c = reader.peek();
            }

            //if there was no inner value or the next character isn't closing paren, it's not a URI
            if (inner === "" || c !== ")") {
                uri = first;
                reader.reset();
            } else {
                uri += inner + reader.read();
            }

            return uri;
        },
        readURL: function readURL() {
            var reader = this._reader,
                url = "",
                c = reader.peek();

            //TODO: Check for escape and nonascii
            while (/^[!#$%&\\*-~]$/.test(c)) {
                url += reader.read();
                c = reader.peek();
            }

            return url;
        },
        readName: function readName(first) {
            var reader = this._reader,
                ident = first || "",
                c = reader.peek();

            while (true) {
                if (c === "\\") {
                    ident += this.readEscape(reader.read());
                    c = reader.peek();
                } else if (c && isNameChar(c)) {
                    ident += reader.read();
                    c = reader.peek();
                } else {
                    break;
                }
            }

            return ident;
        },

        readEscape: function readEscape(first) {
            var reader = this._reader,
                cssEscape = first || "",
                i = 0,
                c = reader.peek();

            if (isHexDigit(c)) {
                do {
                    cssEscape += reader.read();
                    c = reader.peek();
                } while (c && isHexDigit(c) && ++i < 6);
            }

            if (cssEscape.length === 3 && /\s/.test(c) || cssEscape.length === 7 || cssEscape.length === 1) {
                reader.read();
            } else {
                c = "";
            }

            return cssEscape + c;
        },

        readComment: function readComment(first) {
            var reader = this._reader,
                comment = first || "",
                c = reader.read();

            if (c === "*") {
                while (c) {
                    comment += c;

                    //look for end of comment
                    if (comment.length > 2 && c === "*" && reader.peek() === "/") {
                        comment += reader.read();
                        break;
                    }

                    c = reader.read();
                }

                return comment;
            } else {
                return "";
            }
        }
    });

    var Tokens = [

    /*
     * The following token names are defined in CSS3 Grammar: http://www.w3.org/TR/css3-syntax/#lexical
     */

    //HTML-style comments
    { name: "CDO" }, { name: "CDC" },

    //ignorables
    { name: "S", whitespace: true /*, channel: "ws"*/ }, { name: "COMMENT", comment: true, hide: true, channel: "comment" },

    //attribute equality
    { name: "INCLUDES", text: "~=" }, { name: "DASHMATCH", text: "|=" }, { name: "PREFIXMATCH", text: "^=" }, { name: "SUFFIXMATCH", text: "$=" }, { name: "SUBSTRINGMATCH", text: "*=" },

    //identifier types
    { name: "STRING" }, { name: "IDENT" }, { name: "HASH" },

    //at-keywords
    { name: "IMPORT_SYM", text: "@import" }, { name: "PAGE_SYM", text: "@page" }, { name: "MEDIA_SYM", text: "@media" }, { name: "FONT_FACE_SYM", text: "@font-face" }, { name: "CHARSET_SYM", text: "@charset" }, { name: "NAMESPACE_SYM", text: "@namespace" }, { name: "VIEWPORT_SYM", text: ["@viewport", "@-ms-viewport", "@-o-viewport"] }, { name: "DOCUMENT_SYM", text: ["@document", "@-moz-document"] }, { name: "UNKNOWN_SYM" },
    //{ name: "ATKEYWORD"},

    //CSS3 animations
    { name: "KEYFRAMES_SYM", text: ["@keyframes", "@-webkit-keyframes", "@-moz-keyframes", "@-o-keyframes"] },

    //important symbol
    { name: "IMPORTANT_SYM" },

    //measurements
    { name: "LENGTH" }, { name: "ANGLE" }, { name: "TIME" }, { name: "FREQ" }, { name: "DIMENSION" }, { name: "PERCENTAGE" }, { name: "NUMBER" },

    //functions
    { name: "URI" }, { name: "FUNCTION" },

    //Unicode ranges
    { name: "UNICODE_RANGE" },

    /*
     * The following token names are defined in CSS3 Selectors: http://www.w3.org/TR/css3-selectors/#selector-syntax
     */

    //invalid string
    { name: "INVALID" },

    //combinators
    { name: "PLUS", text: "+" }, { name: "GREATER", text: ">" }, { name: "COMMA", text: "," }, { name: "TILDE", text: "~" },

    //modifier
    { name: "NOT" },

    /*
     * Defined in CSS3 Paged Media
     */
    { name: "TOPLEFTCORNER_SYM", text: "@top-left-corner" }, { name: "TOPLEFT_SYM", text: "@top-left" }, { name: "TOPCENTER_SYM", text: "@top-center" }, { name: "TOPRIGHT_SYM", text: "@top-right" }, { name: "TOPRIGHTCORNER_SYM", text: "@top-right-corner" }, { name: "BOTTOMLEFTCORNER_SYM", text: "@bottom-left-corner" }, { name: "BOTTOMLEFT_SYM", text: "@bottom-left" }, { name: "BOTTOMCENTER_SYM", text: "@bottom-center" }, { name: "BOTTOMRIGHT_SYM", text: "@bottom-right" }, { name: "BOTTOMRIGHTCORNER_SYM", text: "@bottom-right-corner" }, { name: "LEFTTOP_SYM", text: "@left-top" }, { name: "LEFTMIDDLE_SYM", text: "@left-middle" }, { name: "LEFTBOTTOM_SYM", text: "@left-bottom" }, { name: "RIGHTTOP_SYM", text: "@right-top" }, { name: "RIGHTMIDDLE_SYM", text: "@right-middle" }, { name: "RIGHTBOTTOM_SYM", text: "@right-bottom" },

    /*
     * The following token names are defined in CSS3 Media Queries: http://www.w3.org/TR/css3-mediaqueries/#syntax
     */
    /*{ name: "MEDIA_ONLY", state: "media"},
    { name: "MEDIA_NOT", state: "media"},
    { name: "MEDIA_AND", state: "media"},*/
    { name: "RESOLUTION", state: "media" },

    /*
     * The following token names are not defined in any CSS specification but are used by the lexer.
     */

    //not a real token, but useful for stupid IE filters
    { name: "IE_FUNCTION" },

    //part of CSS3 grammar but not the Flex code
    { name: "CHAR" },

    //TODO: Needed?
    //Not defined as tokens, but might as well be
    {
        name: "PIPE",
        text: "|"
    }, {
        name: "SLASH",
        text: "/"
    }, {
        name: "MINUS",
        text: "-"
    }, {
        name: "STAR",
        text: "*"
    }, {
        name: "LBRACE",
        endChar: "}",
        text: "{"
    }, {
        name: "RBRACE",
        text: "}"
    }, {
        name: "LBRACKET",
        endChar: "]",
        text: "["
    }, {
        name: "RBRACKET",
        text: "]"
    }, {
        name: "EQUALS",
        text: "="
    }, {
        name: "COLON",
        text: ":"
    }, {
        name: "SEMICOLON",
        text: ";"
    }, {
        name: "LPAREN",
        endChar: ")",
        text: "("
    }, {
        name: "RPAREN",
        text: ")"
    }, {
        name: "DOT",
        text: "."
    }];

    (function () {

        var nameMap = [],
            typeMap = Object.create(null);

        Tokens.UNKNOWN = -1;
        Tokens.unshift({ name: "EOF" });
        for (var i = 0, len = Tokens.length; i < len; i++) {
            nameMap.push(Tokens[i].name);
            Tokens[Tokens[i].name] = i;
            if (Tokens[i].text) {
                if (Tokens[i].text instanceof Array) {
                    for (var j = 0; j < Tokens[i].text.length; j++) {
                        typeMap[Tokens[i].text[j]] = i;
                    }
                } else {
                    typeMap[Tokens[i].text] = i;
                }
            }
        }

        Tokens.name = function (tt) {
            return nameMap[tt];
        };

        Tokens.type = function (c) {
            return typeMap[c] || -1;
        };
    })();

    //This file will likely change a lot! Very experimental!
    var Validation = {

        validate: function validate(property, value) {

            //normalize name
            var name = property.toString().toLowerCase(),
                expression = new PropertyValueIterator(value),
                spec = Properties[name];

            if (!spec) {
                if (name.indexOf("-") !== 0) {
                    //vendor prefixed are ok
                    throw new ValidationError("Unknown property '" + property + "'.", property.line, property.col);
                }
            } else if (typeof spec !== "number") {

                //initialization
                if (typeof spec === "string") {
                    if (spec.indexOf("||") > -1) {
                        this.groupProperty(spec, expression);
                    } else {
                        this.singleProperty(spec, expression, 1);
                    }
                } else if (spec.multi) {
                    this.multiProperty(spec.multi, expression, spec.comma, spec.max || Infinity);
                } else if (typeof spec === "function") {
                    spec(expression);
                }
            }
        },

        singleProperty: function singleProperty(types, expression, max, partial) {

            var result = false,
                value = expression.value,
                count = 0,
                part;

            while (expression.hasNext() && count < max) {
                result = ValidationTypes.isAny(expression, types);
                if (!result) {
                    break;
                }
                count++;
            }

            if (!result) {
                if (expression.hasNext() && !expression.isFirst()) {
                    part = expression.peek();
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
                } else {
                    throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
                }
            } else if (expression.hasNext()) {
                part = expression.next();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            }
        },

        multiProperty: function multiProperty(types, expression, comma, max) {

            var result = false,
                value = expression.value,
                count = 0,
                part;

            while (expression.hasNext() && !result && count < max) {
                if (ValidationTypes.isAny(expression, types)) {
                    count++;
                    if (!expression.hasNext()) {
                        result = true;
                    } else if (comma) {
                        if (String(expression.peek()) === ",") {
                            part = expression.next();
                        } else {
                            break;
                        }
                    }
                } else {
                    break;
                }
            }

            if (!result) {
                if (expression.hasNext() && !expression.isFirst()) {
                    part = expression.peek();
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
                } else {
                    part = expression.previous();
                    if (comma && String(part) === ",") {
                        throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
                    } else {
                        throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
                    }
                }
            } else if (expression.hasNext()) {
                part = expression.next();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            }
        },

        groupProperty: function groupProperty(types, expression, comma) {

            var result = false,
                value = expression.value,
                typeCount = types.split("||").length,
                groups = { count: 0 },
                partial = false,
                name,
                part;

            while (expression.hasNext() && !result) {
                name = ValidationTypes.isAnyOfGroup(expression, types);
                if (name) {

                    //no dupes
                    if (groups[name]) {
                        break;
                    } else {
                        groups[name] = 1;
                        groups.count++;
                        partial = true;

                        if (groups.count === typeCount || !expression.hasNext()) {
                            result = true;
                        }
                    }
                } else {
                    break;
                }
            }

            if (!result) {
                if (partial && expression.hasNext()) {
                    part = expression.peek();
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
                } else {
                    throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
                }
            } else if (expression.hasNext()) {
                part = expression.next();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            }
        }

    };
    /**
     * Type to use when a validation error occurs.
     * @class ValidationError
     * @namespace parserlib.util
     * @constructor
     * @param {String} message The error message.
     * @param {int} line The line at which the error occurred.
     * @param {int} col The column at which the error occurred.
     */
    function ValidationError(message, line, col) {

        /**
         * The column at which the error occurred.
         * @type int
         * @property col
         */
        this.col = col;

        /**
         * The line at which the error occurred.
         * @type int
         * @property line
         */
        this.line = line;

        /**
         * The text representation of the unit.
         * @type String
         * @property text
         */
        this.message = message;
    }

    //inherit from Error
    ValidationError.prototype = new Error();
    //This file will likely change a lot! Very experimental!
    var ValidationTypes = {

        isLiteral: function isLiteral(part, literals) {
            var text = part.text.toString().toLowerCase(),
                args = literals.split(" | "),
                i,
                len,
                found = false;

            for (i = 0, len = args.length; i < len && !found; i++) {
                if (text === args[i].toLowerCase()) {
                    found = true;
                }
            }

            return found;
        },

        isSimple: function isSimple(type) {
            return !!this.simple[type];
        },

        isComplex: function isComplex(type) {
            return !!this.complex[type];
        },

        /**
         * Determines if the next part(s) of the given expression
         * are any of the given types.
         */
        isAny: function isAny(expression, types) {
            var args = types.split(" | "),
                i,
                len,
                found = false;

            for (i = 0, len = args.length; i < len && !found && expression.hasNext(); i++) {
                found = this.isType(expression, args[i]);
            }

            return found;
        },

        /**
         * Determines if the next part(s) of the given expression
         * are one of a group.
         */
        isAnyOfGroup: function isAnyOfGroup(expression, types) {
            var args = types.split(" || "),
                i,
                len,
                found = false;

            for (i = 0, len = args.length; i < len && !found; i++) {
                found = this.isType(expression, args[i]);
            }

            return found ? args[i - 1] : false;
        },

        /**
         * Determines if the next part(s) of the given expression
         * are of a given type.
         */
        isType: function isType(expression, type) {
            var part = expression.peek(),
                result = false;

            if (type.charAt(0) !== "<") {
                result = this.isLiteral(part, type);
                if (result) {
                    expression.next();
                }
            } else if (this.simple[type]) {
                result = this.simple[type](part);
                if (result) {
                    expression.next();
                }
            } else {
                result = this.complex[type](expression);
            }

            return result;
        },

        simple: {
            __proto__: null,

            "<absolute-size>": function absoluteSize(part) {
                return ValidationTypes.isLiteral(part, "xx-small | x-small | small | medium | large | x-large | xx-large");
            },

            "<attachment>": function attachment(part) {
                return ValidationTypes.isLiteral(part, "scroll | fixed | local");
            },

            "<attr>": function attr(part) {
                return part.type === "function" && part.name === "attr";
            },

            "<bg-image>": function bgImage(part) {
                return this["<image>"](part) || this["<gradient>"](part) || String(part) === "none";
            },

            "<gradient>": function gradient(part) {
                return part.type === "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?(?:repeating\-)?(?:radial\-|linear\-)?gradient/i.test(part);
            },

            "<box>": function box(part) {
                return ValidationTypes.isLiteral(part, "padding-box | border-box | content-box");
            },

            "<content>": function content(part) {
                return part.type === "function" && part.name === "content";
            },

            "<relative-size>": function relativeSize(part) {
                return ValidationTypes.isLiteral(part, "smaller | larger");
            },

            //any identifier
            "<ident>": function ident(part) {
                return part.type === "identifier";
            },

            "<length>": function length(part) {
                if (part.type === "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?calc/i.test(part)) {
                    return true;
                } else {
                    return part.type === "length" || part.type === "number" || part.type === "integer" || String(part) === "0";
                }
            },

            "<color>": function color(part) {
                return part.type === "color" || String(part) === "transparent" || String(part) === "currentColor";
            },

            "<number>": function number(part) {
                return part.type === "number" || this["<integer>"](part);
            },

            "<integer>": function integer(part) {
                return part.type === "integer";
            },

            "<line>": function line(part) {
                return part.type === "integer";
            },

            "<angle>": function angle(part) {
                return part.type === "angle";
            },

            "<uri>": function uri(part) {
                return part.type === "uri";
            },

            "<image>": function image(part) {
                return this["<uri>"](part);
            },

            "<percentage>": function percentage(part) {
                return part.type === "percentage" || String(part) === "0";
            },

            "<border-width>": function borderWidth(part) {
                return this["<length>"](part) || ValidationTypes.isLiteral(part, "thin | medium | thick");
            },

            "<border-style>": function borderStyle(part) {
                return ValidationTypes.isLiteral(part, "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset");
            },

            "<content-sizing>": function contentSizing(part) {
                // http://www.w3.org/TR/css3-sizing/#width-height-keywords
                return ValidationTypes.isLiteral(part, "fill-available | -moz-available | -webkit-fill-available | max-content | -moz-max-content | -webkit-max-content | min-content | -moz-min-content | -webkit-min-content | fit-content | -moz-fit-content | -webkit-fit-content");
            },

            "<margin-width>": function marginWidth(part) {
                return this["<length>"](part) || this["<percentage>"](part) || ValidationTypes.isLiteral(part, "auto");
            },

            "<padding-width>": function paddingWidth(part) {
                return this["<length>"](part) || this["<percentage>"](part);
            },

            "<shape>": function shape(part) {
                return part.type === "function" && (part.name === "rect" || part.name === "inset-rect");
            },

            "<time>": function time(part) {
                return part.type === "time";
            },

            "<flex-grow>": function flexGrow(part) {
                return this["<number>"](part);
            },

            "<flex-shrink>": function flexShrink(part) {
                return this["<number>"](part);
            },

            "<width>": function width(part) {
                return this["<margin-width>"](part);
            },

            "<flex-basis>": function flexBasis(part) {
                return this["<width>"](part);
            },

            "<flex-direction>": function flexDirection(part) {
                return ValidationTypes.isLiteral(part, "row | row-reverse | column | column-reverse");
            },

            "<flex-wrap>": function flexWrap(part) {
                return ValidationTypes.isLiteral(part, "nowrap | wrap | wrap-reverse");
            },

            "<feature-tag-value>": function featureTagValue(part) {
                return part.type === "function" && /^[A-Z0-9]{4}$/i.test(part);
            }
        },

        complex: {
            __proto__: null,

            "<bg-position>": function bgPosition(expression) {
                var result = false,
                    numeric = "<percentage> | <length>",
                    xDir = "left | right",
                    yDir = "top | bottom",
                    count = 0;

                while (expression.peek(count) && expression.peek(count).text !== ",") {
                    count++;
                }

                /*
                <position> = [
                  [ left | center | right | top | bottom | <percentage> | <length> ]
                |
                  [ left | center | right | <percentage> | <length> ]
                  [ top | center | bottom | <percentage> | <length> ]
                |
                  [ center | [ left | right ] [ <percentage> | <length> ]? ] &&
                  [ center | [ top | bottom ] [ <percentage> | <length> ]? ]
                ]
                */

                if (count < 3) {
                    if (ValidationTypes.isAny(expression, xDir + " | center | " + numeric)) {
                        result = true;
                        ValidationTypes.isAny(expression, yDir + " | center | " + numeric);
                    } else if (ValidationTypes.isAny(expression, yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, xDir + " | center");
                    }
                } else {
                    if (ValidationTypes.isAny(expression, xDir)) {
                        if (ValidationTypes.isAny(expression, yDir)) {
                            result = true;
                            ValidationTypes.isAny(expression, numeric);
                        } else if (ValidationTypes.isAny(expression, numeric)) {
                            if (ValidationTypes.isAny(expression, yDir)) {
                                result = true;
                                ValidationTypes.isAny(expression, numeric);
                            } else if (ValidationTypes.isAny(expression, "center")) {
                                result = true;
                            }
                        }
                    } else if (ValidationTypes.isAny(expression, yDir)) {
                        if (ValidationTypes.isAny(expression, xDir)) {
                            result = true;
                            ValidationTypes.isAny(expression, numeric);
                        } else if (ValidationTypes.isAny(expression, numeric)) {
                            if (ValidationTypes.isAny(expression, xDir)) {
                                result = true;
                                ValidationTypes.isAny(expression, numeric);
                            } else if (ValidationTypes.isAny(expression, "center")) {
                                result = true;
                            }
                        }
                    } else if (ValidationTypes.isAny(expression, "center")) {
                        if (ValidationTypes.isAny(expression, xDir + " | " + yDir)) {
                            result = true;
                            ValidationTypes.isAny(expression, numeric);
                        }
                    }
                }

                return result;
            },

            "<bg-size>": function bgSize(expression) {
                //<bg-size> = [ <length> | <percentage> | auto ]{1,2} | cover | contain
                var result = false,
                    numeric = "<percentage> | <length> | auto";

                if (ValidationTypes.isAny(expression, "cover | contain")) {
                    result = true;
                } else if (ValidationTypes.isAny(expression, numeric)) {
                    result = true;
                    ValidationTypes.isAny(expression, numeric);
                }

                return result;
            },

            "<repeat-style>": function repeatStyle(expression) {
                //repeat-x | repeat-y | [repeat | space | round | no-repeat]{1,2}
                var result = false,
                    values = "repeat | space | round | no-repeat",
                    part;

                if (expression.hasNext()) {
                    part = expression.next();

                    if (ValidationTypes.isLiteral(part, "repeat-x | repeat-y")) {
                        result = true;
                    } else if (ValidationTypes.isLiteral(part, values)) {
                        result = true;

                        if (expression.hasNext() && ValidationTypes.isLiteral(expression.peek(), values)) {
                            expression.next();
                        }
                    }
                }

                return result;
            },

            "<shadow>": function shadow(expression) {
                //inset? && [ <length>{2,4} && <color>? ]
                var result = false,
                    count = 0,
                    inset = false,
                    color = false;

                if (expression.hasNext()) {

                    if (ValidationTypes.isAny(expression, "inset")) {
                        inset = true;
                    }

                    if (ValidationTypes.isAny(expression, "<color>")) {
                        color = true;
                    }

                    while (ValidationTypes.isAny(expression, "<length>") && count < 4) {
                        count++;
                    }

                    if (expression.hasNext()) {
                        if (!color) {
                            ValidationTypes.isAny(expression, "<color>");
                        }

                        if (!inset) {
                            ValidationTypes.isAny(expression, "inset");
                        }
                    }

                    result = count >= 2 && count <= 4;
                }

                return result;
            },

            "<x-one-radius>": function xOneRadius(expression) {
                //[ <length> | <percentage> ] [ <length> | <percentage> ]?
                var result = false,
                    simple = "<length> | <percentage> | inherit";

                if (ValidationTypes.isAny(expression, simple)) {
                    result = true;
                    ValidationTypes.isAny(expression, simple);
                }

                return result;
            },

            "<flex>": function flex(expression) {
                // http://www.w3.org/TR/2014/WD-css-flexbox-1-20140325/#flex-property
                // none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]
                // Valid syntaxes, according to https://developer.mozilla.org/en-US/docs/Web/CSS/flex#Syntax
                // * none
                // * <flex-grow>
                // * <flex-basis>
                // * <flex-grow> <flex-basis>
                // * <flex-grow> <flex-shrink>
                // * <flex-grow> <flex-shrink> <flex-basis>
                // * inherit
                var part,
                    result = false;
                if (ValidationTypes.isAny(expression, "none | inherit")) {
                    result = true;
                } else {
                    if (ValidationTypes.isType(expression, "<flex-grow>")) {
                        if (expression.peek()) {
                            if (ValidationTypes.isType(expression, "<flex-shrink>")) {
                                if (expression.peek()) {
                                    result = ValidationTypes.isType(expression, "<flex-basis>");
                                } else {
                                    result = true;
                                }
                            } else if (ValidationTypes.isType(expression, "<flex-basis>")) {
                                result = expression.peek() === null;
                            }
                        } else {
                            result = true;
                        }
                    } else if (ValidationTypes.isType(expression, "<flex-basis>")) {
                        result = true;
                    }
                }

                if (!result) {
                    // Generate a more verbose error than "Expected <flex>..."
                    part = expression.peek();
                    throw new ValidationError("Expected (none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]) but found '" + expression.value.text + "'.", part.line, part.col);
                }

                return result;
            }
        }
    };

    parserlib.css = {
        __proto__: null,
        Colors: Colors,
        Combinator: Combinator,
        Parser: Parser,
        PropertyName: PropertyName,
        PropertyValue: PropertyValue,
        PropertyValuePart: PropertyValuePart,
        MediaFeature: MediaFeature,
        MediaQuery: MediaQuery,
        Selector: Selector,
        SelectorPart: SelectorPart,
        SelectorSubPart: SelectorSubPart,
        Specificity: Specificity,
        TokenStream: TokenStream,
        Tokens: Tokens,
        ValidationError: ValidationError
    };
})();

(function () {
    /* jshint forin:false */
    for (var prop in parserlib) {
        exports[prop] = parserlib[prop];
    }
})();

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var URL = __webpack_require__(23);
var URLUtils = __webpack_require__(48);

module.exports = Location;

function Location(window, href) {
  this._window = window;
  this._href = href;
}

Location.prototype = Object.create(URLUtils.prototype, {
  constructor: { value: Location },

  // Special behavior when href is set
  href: {
    get: function get() {
      return this._href;
    },
    set: function set(v) {
      this.assign(v);
    }
  },

  assign: { value: function value(url) {
      // Resolve the new url against the current one
      // XXX:
      // This is not actually correct. It should be resolved against
      // the URL of the document of the script. For now, though, I only
      // support a single window and there is only one base url.
      // So this is good enough for now.
      var current = new URL(this._href);
      var newurl = current.resolve(url);

      // Save the new url
      this._href = newurl;

      // Start loading the new document!
      // XXX
      // This is just something hacked together.
      // The real algorithm is: http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html#navigate
    } },

  replace: { value: function value(url) {
      // XXX
      // Since we aren't tracking history yet, replace is the same as assign
      this.assign(url);
    } },

  reload: { value: function value() {
      // XXX:
      // Actually, the spec is a lot more complicated than this
      this.assign(this.href);
    } },

  toString: { value: function value() {
      return this.href;
    } }

});

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://html.spec.whatwg.org/multipage/webappapis.html#navigatorid

var NavigatorID = Object.create(null, {
  appCodeName: { value: "Mozilla" },
  appName: { value: "Netscape" },
  appVersion: { value: "4.0" },
  platform: { value: "" },
  product: { value: "Gecko" },
  productSub: { value: "20100101" },
  userAgent: { value: "" },
  vendor: { value: "" },
  vendorSub: { value: "" },
  taintEnabled: { value: function value() {
      return false;
    } }
});

module.exports = NavigatorID;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://html.spec.whatwg.org/multipage/webappapis.html#windowtimers

var WindowTimers = {
  setTimeout: setTimeout,
  clearTimeout: clearTimeout,
  setInterval: setInterval,
  clearInterval: clearInterval
};

module.exports = WindowTimers;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  VALUE: 1, // The value of a Text, Comment or PI node changed
  ATTR: 2, // A new attribute was added or an attribute value and/or prefix changed
  REMOVE_ATTR: 3, // An attribute was removed
  REMOVE: 4, // A node was removed
  MOVE: 5, // A node was moved
  INSERT: 6 // A node (or a subtree of nodes) was inserted
};

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint no-extend-native: 0 */

(function () {
  // Defining locale
  Date.shortMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  Date.longMonths = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  Date.shortDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  Date.longDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  // Defining patterns
  var replaceChars = {
    // Day
    d: function d() {
      var d = this.getDate();return (d < 10 ? '0' : '') + d;
    },
    D: function D() {
      return Date.shortDays[this.getDay()];
    },
    j: function j() {
      return this.getDate();
    },
    l: function l() {
      return Date.longDays[this.getDay()];
    },
    N: function N() {
      var N = this.getDay();return N === 0 ? 7 : N;
    },
    S: function S() {
      var S = this.getDate();return S % 10 === 1 && S !== 11 ? 'st' : S % 10 === 2 && S !== 12 ? 'nd' : S % 10 === 3 && S !== 13 ? 'rd' : 'th';
    },
    w: function w() {
      return this.getDay();
    },
    z: function z() {
      var d = new Date(this.getFullYear(), 0, 1);return Math.ceil((this - d) / 86400000);
    },
    // Week
    W: function W() {
      var target = new Date(this.valueOf());
      var dayNr = (this.getDay() + 6) % 7;
      target.setDate(target.getDate() - dayNr + 3);
      var firstThursday = target.valueOf();
      target.setMonth(0, 1);
      if (target.getDay() !== 4) {
        target.setMonth(0, 1 + (4 - target.getDay() + 7) % 7);
      }
      var retVal = 1 + Math.ceil((firstThursday - target) / 604800000);

      return retVal < 10 ? '0' + retVal : retVal;
    },
    // Month
    F: function F() {
      return Date.longMonths[this.getMonth()];
    },
    m: function m() {
      var m = this.getMonth();return (m < 9 ? '0' : '') + (m + 1);
    },
    M: function M() {
      return Date.shortMonths[this.getMonth()];
    },
    n: function n() {
      return this.getMonth() + 1;
    },
    t: function t() {
      var year = this.getFullYear();
      var nextMonth = this.getMonth() + 1;
      if (nextMonth === 12) {
        year = year++;
        nextMonth = 0;
      }
      return new Date(year, nextMonth, 0).getDate();
    },
    // Year
    L: function L() {
      var L = this.getFullYear();return L % 400 === 0 || L % 100 !== 0 && L % 4 === 0;
    },
    o: function o() {
      var d = new Date(this.valueOf());d.setDate(d.getDate() - (this.getDay() + 6) % 7 + 3);return d.getFullYear();
    },
    Y: function Y() {
      return this.getFullYear();
    },
    y: function y() {
      return ('' + this.getFullYear()).substr(2);
    },
    // Time
    a: function a() {
      return this.getHours() < 12 ? 'am' : 'pm';
    },
    A: function A() {
      return this.getHours() < 12 ? 'AM' : 'PM';
    },
    B: function B() {
      return Math.floor(((this.getUTCHours() + 1) % 24 + this.getUTCMinutes() / 60 + this.getUTCSeconds() / 3600) * 1000 / 24);
    },
    g: function g() {
      return this.getHours() % 12 || 12;
    },
    G: function G() {
      return this.getHours();
    },
    h: function h() {
      var h = this.getHours();return ((h % 12 || 12) < 10 ? '0' : '') + (h % 12 || 12);
    },
    H: function H() {
      var H = this.getHours();return (H < 10 ? '0' : '') + H;
    },
    i: function i() {
      var i = this.getMinutes();return (i < 10 ? '0' : '') + i;
    },
    s: function s() {
      var s = this.getSeconds();return (s < 10 ? '0' : '') + s;
    },
    v: function v() {
      var v = this.getMilliseconds();return (v < 10 ? '00' : v < 100 ? '0' : '') + v;
    },
    // Timezone
    e: function e() {
      return Intl.DateTimeFormat().resolvedOptions().timeZone;
    },
    I: function I() {
      var DST = null;
      for (var i = 0; i < 12; ++i) {
        var d = new Date(this.getFullYear(), i, 1);
        var offset = d.getTimezoneOffset();

        if (DST === null) DST = offset;else if (offset < DST) {
          DST = offset;break;
        } else if (offset > DST) break;
      }
      return this.getTimezoneOffset() === DST | 0;
    },
    O: function O() {
      var O = this.getTimezoneOffset();return (-O < 0 ? '-' : '+') + (Math.abs(O / 60) < 10 ? '0' : '') + Math.floor(Math.abs(O / 60)) + (Math.abs(O % 60) === 0 ? '00' : (Math.abs(O % 60) < 10 ? '0' : '') + Math.abs(O % 60));
    },
    P: function P() {
      var P = this.getTimezoneOffset();return (-P < 0 ? '-' : '+') + (Math.abs(P / 60) < 10 ? '0' : '') + Math.floor(Math.abs(P / 60)) + ':' + (Math.abs(P % 60) === 0 ? '00' : (Math.abs(P % 60) < 10 ? '0' : '') + Math.abs(P % 60));
    },
    T: function T() {
      var tz = this.toLocaleTimeString(navigator.language, { timeZoneName: 'short' }).split(' ');return tz[tz.length - 1];
    },
    Z: function Z() {
      return -this.getTimezoneOffset() * 60;
    },
    // Full Date/Time
    c: function c() {
      return this.format('Y-m-d\\TH:i:sP');
    },
    r: function r() {
      return this.toString();
    },
    U: function U() {
      return Math.floor(this.getTime() / 1000);
    }

    // Simulates PHP's date function
  };Date.prototype.format = function (format) {
    var date = this;
    return format.replace(/(\\?)(.)/g, function (_, esc, chr) {
      return esc === '' && replaceChars[chr] ? replaceChars[chr].call(date) : chr;
    });
  };
}).call(undefined);

/***/ }),
/* 84 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["wrapper"],
    staticStyle: {
      flexGrow: "1"
    }
  }, [_c('div', {
    staticStyle: {
      flex: "1",
      alignItems: "center",
      justifyContent: "center"
    }
  }, [_c('div', {
    staticStyle: {
      flexDirection: "column",
      alignItems: "center"
    }
  }, [_c('image', {
    staticClass: ["image"],
    staticStyle: {
      marginTop: "250px"
    },
    attrs: {
      "src": _vm.logo
    }
  }), _c('text', {
    staticStyle: {
      marginTop: "40px"
    }
  }, [_vm._v(_vm._s(_vm.text))])])]), _c('div', {
    staticClass: ["operations"]
  }, [(this.buttonEnable) ? _c('div', {
    staticClass: ["button"],
    on: {
      "click": _vm.onClick
    }
  }, [_c('text', {
    staticStyle: {
      color: "white",
      fontSize: "35px"
    }
  }, [_vm._v(_vm._s(_vm.buttonText))])]) : _vm._e()])])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(86)
)

/* script */
__vue_exports__ = __webpack_require__(87)

/* template */
var __vue_template__ = __webpack_require__(320)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\src\\login.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-38159d5a"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 86 */
/***/ (function(module, exports) {

module.exports = {
  "wrapper": {
    "justifyContent": "center",
    "alignItems": "center"
  },
  "success": {
    "flex": 1,
    "width": "750",
    "backgroundColor": "#FFFFFF",
    "justifyContent": "center",
    "alignItems": "center"
  },
  "webview": {
    "width": "750",
    "flex": 1
  }
}

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = __webpack_require__(7);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _gitee = __webpack_require__(10);

var _gitee2 = _interopRequireDefault(_gitee);

var _weexUi = __webpack_require__(3);

var _utils = __webpack_require__(15);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var modal = weex.requireModule('modal');
var ws = weex.requireModule('webSocket');
var stream = weex.requireModule('stream');

exports.default = {
    name: 'login',
    components: {
        WxcMinibar: _weexUi.WxcMinibar
    },
    methods: {
        test: function test(text) {},
        onLoad: function onLoad(event) {
            var _this = this;

            return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                var isLogin, router;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.next = 2;
                                return _gitee2.default.handleLogin(event.url);

                            case 2:
                                isLogin = _context.sent;

                                if (!isLogin) {
                                    _context.next = 8;
                                    break;
                                }

                                router = _this.$router;

                                _this.showWeb = false;
                                _context.next = 8;
                                return router.push("/home");

                            case 8:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, _this);
            }))();
        }
    },
    data: function data() {
        return {
            showWeb: true,
            title: '登录Gitee',
            webviewUrl: _gitee2.default.loginUrl
        };
    }
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bindEnv = __webpack_require__(5);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_bindEnv).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var required = __webpack_require__(90)
  , qs = __webpack_require__(91)
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
  , left = new RegExp('^'+ whitespace +'+');

/**
 * Trim a given string.
 *
 * @param {String} str String to trim.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(left, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof global !== 'undefined') globalVar = global;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  address = trimLeft(address);
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encodeURIComponent(key);
      value = encodeURIComponent(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(93);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(94)
)

/* script */
__vue_exports__ = __webpack_require__(95)

/* template */
var __vue_template__ = __webpack_require__(97)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-button\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-77c133fc"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 94 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-btn": {
    "alignItems": "center",
    "justifyContent": "center",
    "borderRadius": "12",
    "opacity": 1
  },
  "wxc-btn-highlight": {
    "opacity:active": 0.8
  },
  "btn-text": {
    "textOverflow": "ellipsis",
    "lines": 1,
    "color": "#ffffff"
  }
}

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _type = __webpack_require__(96);

exports.default = {
  props: {
    text: {
      type: String,
      default: '确认'
    },
    size: {
      type: String,
      default: 'full'
    },
    type: {
      type: String,
      default: 'red'
    },
    disabled: {
      type: Boolean,
      default: false
    },
    isHighlight: {
      type: Boolean,
      default: false
    },
    btnStyle: Object,
    textStyle: Object,
    disabledStyle: Object
  },
  computed: {
    mrBtnStyle: function mrBtnStyle() {
      var type = this.type,
          disabled = this.disabled,
          btnStyle = this.btnStyle,
          size = this.size,
          disabledStyle = this.disabledStyle;


      var mrBtnStyle = _extends({}, _type.STYLE_MAP[type], _type.BUTTON_STYLE_MAP[size], btnStyle);

      var disabledInStyle = { opacity: 0.2 };
      if (type === 'white') {
        disabledInStyle = { backgroundColor: 'rgba(0, 0, 0, 0.1)' };
      }

      return disabled ? _extends({}, mrBtnStyle, disabledInStyle, disabledStyle, {
        borderWidth: 0
      }) : mrBtnStyle;
    },
    mrTextStyle: function mrTextStyle() {
      var type = this.type,
          disabled = this.disabled,
          textStyle = this.textStyle,
          size = this.size;

      var mrTextStyle = _extends({}, _type.TEXT_STYLE_MAP[type], _type.TEXT_FONTSIZE_STYLE_MAP[size], textStyle);
      return disabled ? _extends({}, mrTextStyle, { color: '#FFFFFF' }) : mrTextStyle;
    }
  },
  methods: {
    onClicked: function onClicked(e) {
      var type = this.type,
          disabled = this.disabled;

      this.$emit('wxcButtonClicked', { e: e, type: type, disabled: disabled });
    }
  }
};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var STYLE_MAP = exports.STYLE_MAP = {
  red: {
    backgroundColor: '#FF5000'
  },
  yellow: {
    backgroundColor: '#FFC900'
  },
  white: {
    backgroundColor: '#FFFFFF',
    borderColor: '#A5A5A5',
    borderWidth: '1px'
  },
  blue: {
    backgroundColor: '#0F8DE8'
  },
  green: {
    backgroundColor: '#19be6b'
  }
};

var TEXT_STYLE_MAP = exports.TEXT_STYLE_MAP = {
  red: {
    color: '#FFFFFF'
  },
  yellow: {
    color: '#FFFFFF'
  },
  blue: {
    color: '#FFFFFF'
  },
  white: {
    color: '#3D3D3D'
  },
  green: {
    color: '#FFFFFF'
  }
};

var BUTTON_STYLE_MAP = exports.BUTTON_STYLE_MAP = {
  full: {
    width: '702px',
    height: '88px'
  },
  big: {
    width: '339px',
    height: '70px'
  },
  medium: {
    width: '218px',
    height: '60px'
  },
  small: {
    width: '157px',
    height: '44px'
  }
};

var TEXT_FONTSIZE_STYLE_MAP = exports.TEXT_FONTSIZE_STYLE_MAP = {
  full: {
    fontSize: '36px'
  },
  big: {
    fontSize: '32px'
  },
  medium: {
    fontSize: '28px'
  },
  small: {
    fontSize: '24px'
  }
};

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    class: ['wxc-btn', _vm.isHighlight && !_vm.disabled && 'wxc-btn-highlight'],
    style: _vm.mrBtnStyle,
    attrs: {
      "accessible": true,
      "ariaLabel": _vm.text
    },
    on: {
      "click": _vm.onClicked
    }
  }, [_c('text', {
    staticClass: ["btn-text"],
    style: _vm.mrTextStyle
  }, [_vm._v(_vm._s(_vm.text))])])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(99)
)

/* script */
__vue_exports__ = __webpack_require__(100)

/* template */
var __vue_template__ = __webpack_require__(101)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-cell\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-63bed4b2"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 99 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-cell": {
    "flexDirection": "row",
    "alignItems": "center",
    "paddingLeft": "24",
    "paddingRight": "24",
    "backgroundColor": "#ffffff"
  },
  "cell-margin": {
    "marginBottom": "24"
  },
  "cell-title": {
    "flex": 1
  },
  "cell-indent": {
    "paddingBottom": "30",
    "paddingTop": "30"
  },
  "has-desc": {
    "paddingBottom": "18",
    "paddingTop": "18"
  },
  "cell-top-border": {
    "borderTopColor": "#e2e2e2",
    "borderTopWidth": "1"
  },
  "cell-bottom-border": {
    "borderBottomColor": "#e2e2e2",
    "borderBottomWidth": "1"
  },
  "cell-label-text": {
    "fontSize": "30",
    "color": "#666666",
    "width": "188",
    "marginRight": "10"
  },
  "cell-arrow-icon": {
    "width": "22",
    "height": "22"
  },
  "cell-content": {
    "color": "#333333",
    "fontSize": "30",
    "lineHeight": "40"
  },
  "cell-desc-text": {
    "color": "#999999",
    "fontSize": "24",
    "lineHeight": "30",
    "marginTop": "4",
    "marginRight": "30"
  },
  "extra-content-text": {
    "fontSize": "28",
    "color": "#999999",
    "marginRight": "4"
  }
}

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  props: {
    label: {
      type: String,
      default: ''
    },
    title: {
      type: String,
      default: ''
    },
    extraContent: {
      type: String,
      default: ''
    },
    desc: {
      type: String,
      default: ''
    },
    link: {
      type: String,
      default: ''
    },
    hasTopBorder: {
      type: Boolean,
      default: false
    },
    hasMargin: {
      type: Boolean,
      default: false
    },
    hasBottomBorder: {
      type: Boolean,
      default: true
    },
    hasArrow: {
      type: Boolean,
      default: false
    },
    arrowIcon: {
      type: String,
      default: 'https://gw.alicdn.com/tfs/TB11zBUpwMPMeJjy1XbXXcwxVXa-22-22.png'
    },
    hasVerticalIndent: {
      type: Boolean,
      default: true
    },
    cellStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    autoAccessible: {
      type: Boolean,
      default: true
    }
  },
  methods: {
    cellClicked: function cellClicked(e) {
      var link = this.link;
      this.$emit('wxcCellClicked', { e: e });
      link && _utils2.default.goToH5Page(link, true);
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 101 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    class: ['wxc-cell', _vm.hasTopBorder && 'cell-top-border', _vm.hasBottomBorder && 'cell-bottom-border', _vm.hasMargin && 'cell-margin', _vm.hasVerticalIndent && 'cell-indent', _vm.desc && 'has-desc'],
    style: _vm.cellStyle,
    attrs: {
      "accessible": _vm.autoAccessible,
      "ariaLabel": (_vm.label + "," + _vm.title + "," + _vm.desc)
    },
    on: {
      "click": _vm.cellClicked
    }
  }, [_vm._t("label", [(_vm.label) ? _c('div', [_c('text', {
    staticClass: ["cell-label-text"]
  }, [_vm._v(_vm._s(_vm.label))])]) : _vm._e()]), _c('div', {
    staticClass: ["cell-title"]
  }, [_vm._t("title", [_c('text', {
    staticClass: ["cell-content"]
  }, [_vm._v(_vm._s(_vm.title))]), (_vm.desc) ? _c('text', {
    staticClass: ["cell-desc-text"]
  }, [_vm._v(_vm._s(_vm.desc))]) : _vm._e()])], 2), _vm._t("value"), _vm._t("default"), (_vm.extraContent) ? _c('text', {
    staticClass: ["extra-content-text"]
  }, [_vm._v(_vm._s(_vm.extraContent))]) : _vm._e(), (_vm.hasArrow) ? _c('image', {
    staticClass: ["cell-arrow-icon"],
    attrs: {
      "src": _vm.arrowIcon,
      "ariaHidden": true
    }
  }) : _vm._e()], 2)
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(54);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 103 */
/***/ (function(module, exports) {

module.exports = {
  "checkbox": {
    "width": "48",
    "height": "48"
  },
  "title-text": {
    "fontSize": "30"
  }
}

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _wxcCell = __webpack_require__(29);

var _wxcCell2 = _interopRequireDefault(_wxcCell);

var _type = __webpack_require__(105);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  components: { WxcCell: _wxcCell2.default },
  props: {
    hasTopBorder: {
      type: Boolean,
      default: false
    },
    hasBottomBorder: {
      type: Boolean,
      default: true
    },
    title: {
      type: String,
      require: true
    },
    value: {
      type: [String, Number, Object],
      require: true
    },
    disabled: {
      type: Boolean,
      default: false
    },
    checked: {
      type: Boolean,
      default: false
    },
    config: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  data: function data() {
    return {
      icon: [_type.CHECKED, _type.UNCHECKED, _type.CHECKED_DISABLED, _type.UNCHECKED_DISABLED],
      color: '#3D3D3D',
      innerChecked: false
    };
  },
  computed: {
    checkIcon: function checkIcon() {
      var icon = this.icon,
          disabled = this.disabled,
          innerChecked = this.innerChecked,
          config = this.config;

      var mergeIcon = [].concat(_toConsumableArray(icon));
      config.checkedIcon && (mergeIcon[0] = config.checkedIcon);
      config.unCheckedIcon && (mergeIcon[1] = config.unCheckedIcon);
      config.checkedDisabledIcon && (mergeIcon[2] = config.checkedDisabledIcon);
      config.unCheckedDisabledIcon && (mergeIcon[3] = config.unCheckedDisabledIcon);
      if (disabled) {
        return mergeIcon[innerChecked ? 2 : 3];
      } else {
        return mergeIcon[innerChecked ? 0 : 1];
      }
    },
    textColor: function textColor() {
      var innerChecked = this.innerChecked,
          disabled = this.disabled,
          config = this.config;

      var checkedColor = config.checkedColor ? config.checkedColor : '#EE9900';
      return innerChecked && !disabled ? checkedColor : '#3D3D3D';
    }
  },
  watch: {
    checked: function checked(newChecked) {
      this.innerChecked = newChecked;
    }
  },
  created: function created() {
    var checked = this.checked;

    this.innerChecked = checked;
  },

  methods: {
    wxcCellClicked: function wxcCellClicked() {
      var disabled = this.disabled,
          innerChecked = this.innerChecked,
          value = this.value;

      if (!disabled) {
        this.innerChecked = !innerChecked;
        this.$emit('wxcCheckBoxItemChecked', { value: value, checked: this.innerChecked });
      }
    }
  }
};

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

var CHECKED = exports.CHECKED = 'https://gw.alicdn.com/tfs/TB14fp2pwMPMeJjy1XbXXcwxVXa-72-72.png';
var UNCHECKED = exports.UNCHECKED = 'https://gw.alicdn.com/tfs/TB1U6SbpwMPMeJjy1XcXXXpppXa-72-72.png';
var CHECKED_DISABLED = exports.CHECKED_DISABLED = 'https://gw.alicdn.com/tfs/TB1aPabpwMPMeJjy1XcXXXpppXa-72-72.png';
var UNCHECKED_DISABLED = exports.UNCHECKED_DISABLED = 'https://gw.alicdn.com/tfs/TB1lTuzpwoQMeJjy0FoXXcShVXa-72-72.png';

/***/ }),
/* 106 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('wxc-cell', {
    attrs: {
      "hasTopBorder": _vm.hasTopBorder,
      "hasBottomBorder": _vm.hasBottomBorder,
      "accessible": true,
      "ariaLabel": (_vm.title + ",状态为" + (_vm.checked ? '已选中' : '未选中') + "," + (_vm.disabled ? '不可更改' : '点击可切换'))
    },
    on: {
      "wxcCellClicked": _vm.wxcCellClicked
    }
  }, [_c('text', {
    staticClass: ["title-text"],
    style: {
      color: _vm.textColor
    },
    attrs: {
      "slot": "title"
    },
    slot: "title"
  }, [_vm._v(_vm._s(_vm.title))]), _c('image', {
    staticClass: ["checkbox"],
    attrs: {
      "slot": "value",
      "src": _vm.checkIcon
    },
    slot: "value"
  })])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(108);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* script */
__vue_exports__ = __webpack_require__(109)

/* template */
var __vue_template__ = __webpack_require__(110)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-checkbox-list\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(54);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  components: { WxcCheckbox: _index2.default },
  props: {
    list: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    config: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  data: function data() {
    return {
      checkedList: []
    };
  },
  created: function created() {
    var _this = this;

    var list = this.list;

    if (list && list.length > 0) {
      list.forEach(function (item, i) {
        item.checked && _this.checkedList.push(item.value);
      });
    }
  },

  methods: {
    wxcCheckBoxItemChecked: function wxcCheckBoxItemChecked(e) {
      if (e.checked) {
        this.checkedList.push(e.value);
      } else {
        var index = this.checkedList.indexOf(e.value);
        this.checkedList.splice(index, 1);
      }
      this.$emit('wxcCheckBoxListChecked', { checkedList: this.checkedList });
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', _vm._l((_vm.list), function(item, i) {
    return _c('wxc-checkbox', _vm._b({
      key: i,
      attrs: {
        "config": _vm.config
      },
      on: {
        "wxcCheckBoxItemChecked": _vm.wxcCheckBoxItemChecked
      }
    }, 'wxc-checkbox', item, false))
  }))
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(112);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(113)
)

/* script */
__vue_exports__ = __webpack_require__(114)

/* template */
var __vue_template__ = __webpack_require__(136)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-city\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-2a15a50a"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 113 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-city": {
    "position": "fixed",
    "width": "750",
    "backgroundColor": "#F2F3F4"
  }
}

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _defaultData = __webpack_require__(115);

var _defaultData2 = _interopRequireDefault(_defaultData);

var _util = __webpack_require__(116);

var Util = _interopRequireWildcard(_util);

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

var _tab = __webpack_require__(117);

var _tab2 = _interopRequireDefault(_tab);

var _wxcSearchbar = __webpack_require__(55);

var _wxcSearchbar2 = _interopRequireDefault(_wxcSearchbar);

var _wxcResult = __webpack_require__(56);

var _wxcResult2 = _interopRequireDefault(_wxcResult);

var _wxcIndexlist = __webpack_require__(57);

var _wxcIndexlist2 = _interopRequireDefault(_wxcIndexlist);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  components: { wxcTab: _tab2.default, WxcSearchbar: _wxcSearchbar2.default, WxcResult: _wxcResult2.default, WxcIndexlist: _wxcIndexlist2.default },
  props: {
    animationType: {
      type: String,
      default: 'push'
    },
    inputConfig: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    sourceData: {
      type: Object,
      default: function _default() {
        return _defaultData2.default;
      }
    },
    cityStyleType: {
      type: String,
      default: 'list'
    },
    currentLocation: String,
    cityHeight: {
      type: Number,
      default: 0
    },
    showTab: {
      type: Boolean,
      default: false
    },
    showIndex: {
      type: Boolean,
      default: true
    },
    showNavHeader: {
      type: Boolean,
      default: true
    }
  },
  data: function data() {
    return {
      tId: null,
      saveDefaultSourceData: {},
      cityData: {},
      onlyShowList: false,
      result: {
        noGoods: {
          pic: 'https://img.alicdn.com/tfs/TB1SpPHkf2H8KJjy0FcXXaDlFXa-200-200.png',
          button: '',
          content: '搜索无结果'
        }
      }
    };
  },
  created: function created() {
    this.cityData = this.sourceData;
    this.saveDefaultSourceData = this.sourceData;
  },

  computed: {
    cityExtendStyle: function cityExtendStyle() {
      return _utils2.default.uiStyle.pageTransitionAnimationStyle(this.animationType);
    },
    currentCityLocationConfig: function currentCityLocationConfig() {
      if (this.currentLocation) {
        return {
          type: this.cityStyleType,
          title: '定位',
          list: [{ name: this.currentLocation, isLocation: true }]
        };
      } else {
        return {};
      }
    },
    normalList: function normalList() {
      return Util.getCities(this.cityData.cities);
    },
    hotListConfig: function hotListConfig() {
      return {
        type: this.cityStyleType,
        title: '热门',
        list: Util.getCities(this.cityData.hotCity)
      };
    },
    showError: function showError() {
      var normalList = this.normalList,
          hotListConfig = this.hotListConfig;

      return normalList && normalList.length < 1 && hotListConfig && hotListConfig.list && hotListConfig.list.length < 1;
    },
    listHeight: function listHeight() {
      // 兼容去头逻辑
      var pageHeight = _utils2.default.env.getPageHeight();

      var cityHeight = this.cityHeight;

      if (cityHeight && !isNaN(cityHeight) && cityHeight > 0) {
        pageHeight = cityHeight;
      }
      // searchInput 84
      var tabHeight = this.showTab ? 90 : 0;
      return pageHeight - 84 - tabHeight;
    },
    mergeInputConfig: function mergeInputConfig() {
      return _extends({
        autofocus: false,
        alwaysShowCancel: true,
        placeholder: '中文/拼音/首字母'
      }, this.inputConfig);
    }
  },
  methods: {
    onTabSwitch: function onTabSwitch(e) {
      this.$emit('wxcTabSwitch', e);
    },
    switchTab: function switchTab() {
      var _this = this;

      var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      setTimeout(function () {
        _this.$refs['wxc-tab'].switchTab(i);
      }, 100);
    },
    onItemClick: function onItemClick(e) {
      this.$refs['wxc-searchbar'].autoBlur();
      this.show(false);
      this.$emit('wxcCityItemSelected', { item: e.item });
    },
    onInput: function onInput(e) {
      var _this2 = this;

      clearTimeout(this.tId);
      var cities = this.cityData.cities;
      var value = e.value;

      if (value !== '' && cities && cities.length > 0) {
        var queryData = Util.query(cities, String(value).trim());
        this.cityData = {
          cities: queryData,
          hotCity: []
        };
        this.onlyShowList = true;
      } else {
        this.cityData = this.saveDefaultSourceData;
        this.onlyShowList = false;
      }
      this.tId = setTimeout(function () {
        _this2.$emit('wxcCityOnInput', {
          value: e.value
        });
      }, 300);
    },
    onCancel: function onCancel() {
      this.autoBlur();
      this.show(false);
      this.$emit('wxcCityCanceled', {});
    },
    onSubmit: function onSubmit(e) {
      this.autoBlur();
      this.$emit('wxcCityOnKeyUpEnter', { value: e.value });
    },
    autoBlur: function autoBlur() {
      var inputRef = this.$refs['wxc-searchbar'];
      inputRef && inputRef.autoBlur();
    },
    show: function show() {
      var status = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var ref = this.$refs.city;
      if (this.animationType === 'push') {
        _utils2.default.animation.pageTransitionAnimation(ref, 'translateX(' + (status ? -750 : 750) + 'px)', status, callback);
      } else if (this.animationType === 'model') {
        _utils2.default.animation.pageTransitionAnimation(ref, 'translateY(' + (status ? -_utils2.default.env.getScreenHeight() : _utils2.default.env.getScreenHeight()) + 'px)', status, callback);
      }
    }
  }
};

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Created by dianwoda on 2018/1/31.
 */
exports.default = {
  hotCity: [{ cityName: '北京', pinYin: 'beijing', py: 'bj' }, { cityName: '上海', pinYin: 'shanghai', py: 'sh' }, { cityName: '天津', pinYin: 'tianjin', py: 'tj' }, { cityName: '青岛', pinYin: 'qingdao', py: 'qd' }, { cityName: '南京', pinYin: 'nanjing', py: 'nj' }, { cityName: '杭州', pinYin: 'hangzhou', py: 'hz' }, { cityName: '厦门', pinYin: 'xiamen', py: 'xm' }, { cityName: '成都', pinYin: 'chengdu', py: 'cd' }, { cityName: '深圳', pinYin: 'shenzhen', py: 'sz' }, { cityName: '广州', pinYin: 'guangzhou', py: 'gz' }, { cityName: '沈阳', pinYin: 'shenyang', py: 'sy' }, { cityName: '武汉', pinYin: 'wuhan', py: 'wh' }],
  cities: [{ cityName: '北京', pinYin: 'beijing', py: 'bj' }, { cityName: '包头', pinYin: 'baotou', py: 'bt' }, { cityName: '北海', pinYin: 'beihai', py: 'bh' }, { cityName: '宝鸡', pinYin: 'baoji', py: 'bj' }, { cityName: '成都', pinYin: 'chengdu', py: 'cd' }, { cityName: '重庆', pinYin: 'chongqing', py: 'cq' }, { cityName: '长沙', pinYin: 'changsha', py: 'cs' }, { cityName: '长春', pinYin: 'changchun', py: 'cc' }, { cityName: '常州', pinYin: 'changzhou', py: 'cz' }, { cityName: '常德', pinYin: 'changde', py: 'cd' }, { cityName: '沧州', pinYin: 'cangzhou', py: 'cz' }, { cityName: '承德', pinYin: 'chengde', py: 'cd' }, { cityName: '长治', pinYin: 'changzhi', py: 'cz' }, { cityName: '滁州', pinYin: 'chuzhou', py: 'cz' }, { cityName: '大连', pinYin: 'dalian', py: 'dl' }, { cityName: '东莞', pinYin: 'dongguan', py: 'dg' }, { cityName: '大同', pinYin: 'datong', py: 'dt' }, { cityName: '达州', pinYin: 'dazhou', py: 'dz' }, { cityName: '鄂尔多斯', pinYin: 'eerduosi', py: 'eeds' }, { cityName: '恩施', pinYin: 'enshi', py: 'es' }, { cityName: '福州', pinYin: 'fuzhou', py: 'fz' }, { cityName: '佛山', pinYin: 'foshan', py: 'fs' }, { cityName: '抚顺', pinYin: 'fushun', py: 'fs' }, { cityName: '抚州', pinYin: 'fuzhou', py: 'fz' }, { cityName: '防城港', pinYin: 'fangchenggang', py: 'fcg' }, { cityName: '广州', pinYin: 'guangzhou', py: 'gz' }, { cityName: '贵阳', pinYin: 'guiyang', py: 'gy' }, { cityName: '桂林', pinYin: 'guilin', py: 'gl' }, { cityName: '广元', pinYin: 'guangyuan', py: 'gy' }, { cityName: '广安', pinYin: 'guangan', py: 'ga' }, { cityName: '杭州', pinYin: 'hangzhou', py: 'hz' }, { cityName: '哈尔滨', pinYin: 'haerbin', py: 'heb' }, { cityName: '合肥', pinYin: 'hefei', py: 'hf' }, { cityName: '呼和浩特', pinYin: 'huhehaote', py: 'hhht' }, { cityName: '海口', pinYin: 'haikou', py: 'hk' }, { cityName: '黄山', pinYin: 'huangshan', py: 'hs' }, { cityName: '呼伦贝尔', pinYin: 'hulunbeier', py: 'hlbe' }, { cityName: '邯郸', pinYin: 'handan', py: 'hd' }, { cityName: '衡阳', pinYin: 'hengyang', py: 'hy' }, { cityName: '汉中', pinYin: 'hanzhong', py: 'hz' }, { cityName: '济南', pinYin: 'jinan', py: 'jn' }, { cityName: '济宁', pinYin: 'jining', py: 'jn' }, { cityName: '九江', pinYin: 'jiujiang', py: 'jj' }, { cityName: '景德镇', pinYin: 'jingdezhen', py: 'jdz' }, { cityName: '吉林', pinYin: 'jilin', py: 'jl' }, { cityName: '江门', pinYin: 'jiangmen', py: 'jm' }, { cityName: '晋城', pinYin: 'jincheng', py: 'jc' }, { cityName: '嘉峪关', pinYin: 'jiayuguan', py: 'jyg' }, { cityName: '酒泉', pinYin: 'jiuquan', py: 'jq' }, { cityName: '昆明', pinYin: 'kunming', py: 'km' }, { cityName: '克拉玛依', pinYin: 'kelamayi', py: 'klmy' }, { cityName: '兰州', pinYin: 'lanzhou', py: 'lz' }, { cityName: '丽江', pinYin: 'lijiang', py: 'lj' }, { cityName: '洛阳', pinYin: 'luoyang', py: 'ly' }, { cityName: '柳州', pinYin: 'liuzhou', py: 'lz' }, { cityName: '泸州', pinYin: 'luzhou', py: 'lz' }, { cityName: '拉萨', pinYin: 'lasa', py: 'ls' }, { cityName: '临汾', pinYin: 'linfen', py: 'lf' }, { cityName: '乐山', pinYin: 'leshan', py: 'ls' }, { cityName: '聊城', pinYin: 'liaocheng', py: 'lc' }, { cityName: '丽水', pinYin: 'lishui', py: 'ls' }, { cityName: '绵阳', pinYin: 'mianyang', py: 'my' }, { cityName: '梅州', pinYin: 'meizhou', py: 'mz' }, { cityName: '眉山', pinYin: 'meishan', py: 'ms' }, { cityName: '南昌', pinYin: 'nanchang', py: 'nc' }, { cityName: '南京', pinYin: 'nanjing', py: 'nj' }, { cityName: '南宁', pinYin: 'nanning', py: 'nn' }, { cityName: '宁波', pinYin: 'ningbo', py: 'nb' }, { cityName: '南通', pinYin: 'nantong', py: 'nt' }, { cityName: '南充', pinYin: 'nanchong', py: 'nc' }, { cityName: '内江', pinYin: 'neijiang', py: 'nj' }, { cityName: '萍乡', pinYin: 'pingxiang', py: 'px' }, { cityName: '攀枝花', pinYin: 'panzhihua', py: 'pzh' }, { cityName: '青岛', pinYin: 'qingdao', py: 'qd' }, { cityName: '泉州', pinYin: 'quanzhou', py: 'qz' }, { cityName: '上海', pinYin: 'shanghai', py: 'sh' }, { cityName: '深圳', pinYin: 'shenzhen', py: 'sz' }, { cityName: '沈阳', pinYin: 'shenyang', py: 'sy' }, { cityName: '石家庄', pinYin: 'shijiazhuang', py: 'sjz' }, { cityName: '苏州', pinYin: 'suzhou', py: 'sz' }, { cityName: '三亚', pinYin: 'sanya', py: 'sy' }, { cityName: '汕头', pinYin: 'shantou', py: 'st' }, { cityName: '上饶', pinYin: 'shangrao', py: 'sr' }, { cityName: '遂宁', pinYin: 'suining', py: 'sn' }, { cityName: '宿迁', pinYin: 'suqian', py: 'sq' }, { cityName: '天津', pinYin: 'tianjin', py: 'tj' }, { cityName: '太原', pinYin: 'taiyuan', py: 'ty' }, { cityName: '台州', pinYin: 'taizhou', py: 'tz' }, { cityName: '唐山', pinYin: 'tangshan', py: 'ts' }, { cityName: '铁岭', pinYin: 'tieling', py: 'tl' }, { cityName: '武汉', pinYin: 'wuhan', py: 'wh' }, { cityName: '无锡', pinYin: 'wuxi', py: 'wx' }, { cityName: '温州', pinYin: 'wenzhou', py: 'wz' }, { cityName: '乌鲁木齐', pinYin: 'wulumuqi', py: 'wlmq' }, { cityName: '威海', pinYin: 'weihai', py: 'wh' }, { cityName: '渭南', pinYin: 'weinan', py: 'wn' }, { cityName: '西安', pinYin: 'xian', py: 'xa' }, { cityName: '厦门', pinYin: 'xiamen', py: 'xm' }, { cityName: '香港', pinYin: 'xianggang', py: 'xg' }, { cityName: '徐州', pinYin: 'xuzhou', py: 'xz' }, { cityName: '西宁', pinYin: 'xining', py: 'xn' }, { cityName: '襄阳', pinYin: 'xiangyang', py: 'xy' }, { cityName: '新余', pinYin: 'xinyu', py: 'xy' }, { cityName: '许昌', pinYin: 'xuchang', py: 'xc' }, { cityName: '信阳', pinYin: 'xinyang', py: 'xy' }, { cityName: '银川', pinYin: 'yinchuan', py: 'yc' }, { cityName: '宜昌', pinYin: 'yichang', py: 'yc' }, { cityName: '烟台', pinYin: 'yantai', py: 'yt' }, { cityName: '扬州', pinYin: 'yangzhou', py: 'yz' }, { cityName: '宜宾', pinYin: 'yibin', py: 'yb' }, { cityName: '运城', pinYin: 'yuncheng', py: 'yc' }, { cityName: '榆林', pinYin: 'yulin', py: 'yl' }, { cityName: '盐城', pinYin: 'yancheng', py: 'yc' }, { cityName: '岳阳', pinYin: 'yueyang', py: 'yy' }, { cityName: '延安', pinYin: 'yanan', py: 'ya' }, { cityName: '鹰潭', pinYin: 'yingtan', py: 'yt' }, { cityName: '永州', pinYin: 'yongzhou', py: 'yz' }, { cityName: '郑州', pinYin: 'zhengzhou', py: 'zz' }, { cityName: '珠海', pinYin: 'zhuhai', py: 'zh' }, { cityName: '张家界', pinYin: 'zhangjiajie', py: 'zzj' }, { cityName: '中山', pinYin: 'zhongshan', py: 'zs' }, { cityName: '遵义', pinYin: 'zunyi', py: 'zy' }, { cityName: '湛江', pinYin: 'zhanjiang', py: 'zj' }, { cityName: '株洲', pinYin: 'zhuzhou', py: 'zz' }, { cityName: '肇庆', pinYin: 'zhaoqing', py: 'zq' }, { cityName: '枣庄', pinYin: 'zaozhuang', py: 'zz' }, { cityName: '舟山', pinYin: 'zhoushan', py: 'zs' }, { cityName: '自贡', pinYin: 'zigong', py: 'zg' }, { cityName: '资阳', pinYin: 'ziyang', py: 'zy' }, { cityName: '张掖', pinYin: 'zhangye', py: 'zy' }]
};

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCities = getCities;
exports.query = query;

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getCities(list) {
  var showDesc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (list && list.length > 0) {
    var result = list.map(function (v) {
      var o = Object.assign({}, v);

      if (o.suggestName) {
        o.name = o.suggestName;
      }

      if (o.stationName && !o.name) {
        o.name = o.stationName;
      }

      if (o.cityName && !o.name) {
        o.name = o.cityName;
      }

      if (o.code && showDesc) {
        o.desc = o.code;
      }
      return o;
    });
    return result;
  } else {
    return [];
  }
}

function query(source, text) {
  var res = [];
  res = source.filter(function (item) {
    var arr = [];
    var isHave = false;
    Object.keys(item).forEach(function (prop) {
      var itemStr = item[prop];
      _utils2.default.isString(itemStr) && itemStr.split(',').forEach(function (val) {
        arr.push(val);
      });
    });
    arr.some(function (val) {
      isHave = new RegExp('^' + text).test(val);
      return isHave;
    });
    return isHave;
  });
  return res;
}

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(118)
)

/* script */
__vue_exports__ = __webpack_require__(119)

/* template */
var __vue_template__ = __webpack_require__(120)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-city\\tab.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-ff138a04"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 118 */
/***/ (function(module, exports) {

module.exports = {
  "tab-box": {
    "width": "750",
    "flexDirection": "row",
    "justifyContent": "center"
  },
  "tab-item": {
    "flex": 1,
    "height": "90",
    "backgroundColor": "#ffffff",
    "alignItems": "center",
    "justifyContent": "center"
  },
  "tab-item-text": {
    "textAlign": "center",
    "color": "#000000",
    "fontSize": "28"
  },
  "text-selected": {
    "fontWeight": "bold"
  },
  "tab-item-selected-bar": {
    "width": "750",
    "backgroundColor": "#f2f3f4"
  },
  "tab-item-selected-bar-in": {
    "width": "375",
    "justifyContent": "center",
    "alignItems": "center",
    "flexDirection": "row",
    "height": "6"
  },
  "tab-item-active": {
    "backgroundColor": "#ffb200",
    "width": "92",
    "height": "6"
  }
}

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  props: {},
  data: function data() {
    return {
      checkedIndex: 0
    };
  },
  methods: {
    switchTab: function switchTab(index) {
      var animation = weex.requireModule('animation');
      this.checkedIndex = index;
      this.$emit('wxcTabSwitch', {
        index: index
      });
      animation.transition(this.$refs['tab-bar'], {
        styles: {
          transform: 'translateX(' + index * 375 + 'px)'
        },
        duration: 150, // ms
        timingFunction: 'ease',
        delay: 0 // ms
      }, function () {});
    }
  }
};

/***/ }),
/* 120 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_c('div', {
    staticClass: ["tab-box"]
  }, _vm._l((['国内', '国际']), function(name, i) {
    return _c('div', {
      key: i,
      staticClass: ["tab-item"],
      on: {
        "click": function($event) {
          _vm.switchTab(i)
        }
      }
    }, [_c('text', {
      staticClass: ["['tab-item-text',", "i===checkedIndex", "&&", "'text-selected']"]
    }, [_vm._v(_vm._s(name))])])
  })), _c('div', {
    staticClass: ["tab-item-selected-bar"]
  }, [_c('div', {
    ref: "tab-bar",
    staticClass: ["tab-item-selected-bar-in"]
  }, [_c('div', {
    staticClass: ["tab-item-active"]
  })])])])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(122)
)

/* script */
__vue_exports__ = __webpack_require__(123)

/* template */
var __vue_template__ = __webpack_require__(125)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-searchbar\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-788a9a37"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 122 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-search-bar": {
    "paddingLeft": "20",
    "paddingRight": "20",
    "backgroundColor": "#ffffff",
    "width": "750",
    "height": "84",
    "flexDirection": "row"
  },
  "wxc-search-bar-yellow": {
    "backgroundColor": "#ffc900"
  },
  "search-bar-input": {
    "position": "absolute",
    "top": "10",
    "paddingTop": 0,
    "paddingBottom": 0,
    "paddingRight": "40",
    "paddingLeft": "60",
    "fontSize": "26",
    "width": "624",
    "height": "64",
    "lineHeight": "64",
    "backgroundColor": "#E5E5E5",
    "borderRadius": "6"
  },
  "search-bar-input-yellow": {
    "backgroundColor": "#fff6d6"
  },
  "search-bar-icon": {
    "position": "absolute",
    "width": "30",
    "height": "30",
    "left": "34",
    "top": "28"
  },
  "search-bar-close": {
    "position": "absolute",
    "width": "30",
    "height": "30",
    "right": "120",
    "top": "28"
  },
  "search-bar-button": {
    "width": "94",
    "height": "36",
    "fontSize": "30",
    "textAlign": "center",
    "backgroundColor": "#ffffff",
    "marginTop": "16",
    "marginRight": 0,
    "color": "#333333",
    "position": "absolute",
    "right": "8",
    "top": "9"
  },
  "search-bar-button-yellow": {
    "backgroundColor": "#FFC900"
  },
  "input-has-dep": {
    "paddingLeft": "240",
    "width": "710"
  },
  "bar-dep": {
    "width": "170",
    "paddingRight": "12",
    "paddingLeft": "12",
    "height": "42",
    "alignItems": "center",
    "flexDirection": "row",
    "position": "absolute",
    "left": "24",
    "top": "22",
    "borderRightStyle": "solid",
    "borderRightWidth": "1",
    "borderRightColor": "#C7C7C7"
  },
  "bar-dep-yellow": {
    "borderRightColor": "#C7C7C7"
  },
  "dep-text": {
    "flex": 1,
    "textAlign": "center",
    "fontSize": "26",
    "color": "#666666",
    "marginRight": "6",
    "lines": 1,
    "textOverflow": "ellipsis"
  },
  "dep-arrow": {
    "width": "24",
    "height": "24"
  },
  "icon-has-dep": {
    "left": "214"
  },
  "disabled-input": {
    "width": "750",
    "height": "64",
    "position": "absolute",
    "left": 0,
    "backgroundColor": "rgba(0,0,0,0)"
  },
  "has-dep-disabled": {
    "width": "550",
    "left": "200"
  }
}

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _type = __webpack_require__(124);

exports.default = {
  props: {
    disabled: {
      type: Boolean,
      default: false
    },
    alwaysShowCancel: {
      type: Boolean,
      default: false
    },
    inputType: {
      type: String,
      default: 'text'
    },
    returnKeyType: {
      type: String,
      default: 'default'
    },
    mod: {
      type: String,
      default: 'default'
    },
    autofocus: {
      type: Boolean,
      default: false
    },
    theme: {
      type: String,
      default: 'gray'
    },
    barStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    defaultValue: {
      type: String,
      default: ''
    },
    placeholder: {
      type: String,
      default: '搜索'
    },
    cancelLabel: {
      type: String,
      default: '取消 '
    },
    depName: {
      type: String,
      default: '杭州'
    }
  },
  computed: {
    needShowCancel: function needShowCancel() {
      return this.alwaysShowCancel || this.showCancel;
    },
    buttonStyle: function buttonStyle() {
      var barStyle = this.barStyle;

      if (barStyle.backgroundColor) {
        return { backgroundColor: barStyle.backgroundColor };
      }
      return {};
    }
  },
  data: function data() {
    return {
      inputIcon: _type.INPUT_ICON,
      closeIcon: _type.CLOSE_ICON,
      arrowIcon: _type.ARROW_ICON,
      showCancel: false,
      showClose: false,
      value: ''

    };
  },
  created: function created() {
    this.defaultValue && (this.value = this.defaultValue);
    if (this.disabled) {
      this.showCancel = false;
      this.showClose = false;
    }
  },

  methods: {
    onBlur: function onBlur() {
      var self = this;
      setTimeout(function () {
        self.showCancel = false;
        self.detectShowClose();
        self.$emit('wxcSearchbarInputOnBlur', { value: self.value });
      }, 10);
    },
    autoBlur: function autoBlur() {
      this.$refs['search-input'].blur();
    },
    onFocus: function onFocus() {
      if (this.isDisabled) {
        return;
      }
      this.showCancel = true;
      this.detectShowClose();
      this.$emit('wxcSearchbarInputOnFocus', { value: this.value });
    },
    closeClicked: function closeClicked() {
      this.value = '';
      this.showCancel && (this.showCancel = false);
      this.showClose && (this.showClose = false);
      this.$emit('wxcSearchbarCloseClicked', { value: this.value });
      this.$emit('wxcSearchbarInputOnInput', { value: this.value });
    },
    onInput: function onInput(e) {
      this.value = e.value;
      this.showCancel = true;
      this.detectShowClose();
      this.$emit('wxcSearchbarInputOnInput', { value: this.value });
    },
    onSubmit: function onSubmit(e) {
      this.onBlur();
      this.value = e.value;
      this.showCancel = true;
      this.detectShowClose();
      this.$emit('wxcSearchbarInputReturned', { value: this.value });
    },
    cancelClicked: function cancelClicked() {
      this.showCancel && (this.showCancel = false);
      this.showClose && (this.showClose = false);
      this.$emit('wxcSearchbarCancelClicked', { value: this.value });
    },
    detectShowClose: function detectShowClose() {
      this.showClose = this.value.length > 0 && this.showCancel;
    },
    depClicked: function depClicked() {
      this.$emit('wxcSearchbarDepChooseClicked', {});
    },
    inputDisabledClicked: function inputDisabledClicked() {
      this.$emit('wxcSearchbarInputDisabledClicked', {});
    },
    setValue: function setValue(value) {
      this.value = value;
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var INPUT_ICON = exports.INPUT_ICON = 'https://gw.alicdn.com/tfs/TB1FZB.pwMPMeJjy1XdXXasrXXa-30-30.png';
var CLOSE_ICON = exports.CLOSE_ICON = 'https://gw.alicdn.com/tfs/TB1sZB.pwMPMeJjy1XdXXasrXXa-24-24.png';
var ARROW_ICON = exports.ARROW_ICON = 'https://gw.alicdn.com/tfs/TB1vZB.pwMPMeJjy1XdXXasrXXa-24-24.png';

/***/ }),
/* 125 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [(_vm.mod === 'default') ? _c('div', {
    class: ['wxc-search-bar', 'wxc-search-bar-' + _vm.theme],
    style: _vm.barStyle
  }, [_c('input', {
    ref: "search-input",
    class: ['search-bar-input', 'search-bar-input-' + _vm.theme],
    style: {
      width: _vm.needShowCancel ? '624px' : '710px'
    },
    attrs: {
      "returnKeyType": _vm.returnKeyType,
      "autofocus": _vm.autofocus,
      "disabled": _vm.disabled,
      "value": _vm.value,
      "type": _vm.inputType,
      "placeholder": _vm.placeholder
    },
    on: {
      "blur": _vm.onBlur,
      "focus": _vm.onFocus,
      "input": _vm.onInput,
      "return": _vm.onSubmit
    }
  }), (_vm.disabled) ? _c('div', {
    staticClass: ["disabled-input"],
    on: {
      "click": _vm.inputDisabledClicked
    }
  }) : _vm._e(), _c('image', {
    staticClass: ["search-bar-icon"],
    attrs: {
      "ariaHidden": true,
      "src": _vm.inputIcon
    }
  }), (_vm.showClose) ? _c('image', {
    staticClass: ["search-bar-close"],
    attrs: {
      "ariaHidden": true,
      "src": _vm.closeIcon
    },
    on: {
      "click": _vm.closeClicked
    }
  }) : _vm._e(), (_vm.needShowCancel) ? _c('text', {
    class: ['search-bar-button', 'search-bar-button-' + _vm.theme],
    style: _vm.buttonStyle,
    on: {
      "click": _vm.cancelClicked
    }
  }, [_vm._v(_vm._s(_vm.cancelLabel))]) : _vm._e()]) : _vm._e(), (_vm.mod === 'hasDep') ? _c('div', {
    class: ['wxc-search-bar', 'wxc-search-bar-' + _vm.theme],
    style: _vm.barStyle
  }, [_c('input', {
    class: ['search-bar-input', 'input-has-dep', 'search-bar-input-' + _vm.theme],
    attrs: {
      "disabled": _vm.disabled,
      "autofocus": _vm.autofocus,
      "returnKeyType": _vm.returnKeyType,
      "value": _vm.value,
      "type": _vm.inputType,
      "placeholder": _vm.placeholder
    },
    on: {
      "blur": _vm.onBlur,
      "focus": _vm.onFocus,
      "input": _vm.onInput,
      "return": _vm.onSubmit
    }
  }), (_vm.disabled) ? _c('div', {
    staticClass: ["disabled-input", "has-dep-disabled"],
    on: {
      "click": _vm.inputDisabledClicked
    }
  }) : _vm._e(), _c('div', {
    class: ['bar-dep', '.bar-dep-' + _vm.theme],
    on: {
      "click": _vm.depClicked
    }
  }, [_c('text', {
    staticClass: ["dep-text"]
  }, [_vm._v(_vm._s(_vm.depName))]), _c('image', {
    staticClass: ["dep-arrow"],
    attrs: {
      "src": _vm.arrowIcon,
      "ariaHidden": true
    }
  })]), _c('image', {
    staticClass: ["search-bar-icon", "icon-has-dep"],
    attrs: {
      "ariaHidden": true,
      "src": _vm.inputIcon
    }
  })]) : _vm._e()])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(127)
)

/* script */
__vue_exports__ = __webpack_require__(128)

/* template */
var __vue_template__ = __webpack_require__(130)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-result\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-9b19c5a6"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 127 */
/***/ (function(module, exports) {

module.exports = {
  "wrap": {
    "position": "absolute",
    "top": 0,
    "left": 0,
    "right": 0,
    "bottom": 0
  },
  "wxc-result": {
    "width": "750",
    "flex": 1,
    "alignItems": "center",
    "backgroundColor": "#f2f3f4"
  },
  "result-image": {
    "width": "320",
    "height": "320"
  },
  "result-content": {
    "marginTop": "36",
    "alignItems": "center"
  },
  "content-text": {
    "fontSize": "30",
    "color": "#A5A5A5",
    "height": "42",
    "lineHeight": "42",
    "textAlign": "center"
  },
  "content-desc": {
    "marginTop": "10"
  },
  "result-button": {
    "marginTop": "60",
    "borderWidth": "1",
    "borderColor": "#979797",
    "backgroundColor": "#FFFFFF",
    "borderRadius": "6",
    "width": "240",
    "height": "72",
    "flexDirection": "row",
    "alignItems": "center",
    "justifyContent": "center"
  },
  "button-text": {
    "color": "#666666",
    "fontSize": "30"
  }
}

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _type = __webpack_require__(129);

var _type2 = _interopRequireDefault(_type);

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  props: {
    type: {
      type: String,
      default: 'errorPage'
    },
    show: {
      type: Boolean,
      default: true
    },
    wrapStyle: Object,
    paddingTop: {
      type: [Number, String],
      default: 232
    },
    customSet: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  computed: {
    resultType: function resultType() {
      var type = this.type,
          customSet = this.customSet;

      var allTypes = _utils2.default.isEmptyObject(customSet) ? _type2.default : _utils2.default.mergeDeep(_type2.default, customSet);
      var types = allTypes['errorPage'];
      if (Object.keys(allTypes).indexOf(type) > -1) {
        types = allTypes[type];
      }
      return types;
    },
    setPaddingTop: function setPaddingTop() {
      var paddingTop = this.paddingTop;
      return paddingTop + 'px';
    }
  },
  methods: {
    handleTouchEnd: function handleTouchEnd(e) {
      // web上面有点击穿透问题
      var platform = weex.config.env.platform;

      platform === 'Web' && e.preventDefault && e.preventDefault();
    },
    onClick: function onClick() {
      var type = this.type;
      this.$emit('wxcResultButtonClicked', { type: type });
    }
  }
};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

exports.default = {
  errorPage: {
    pic: 'https://img.alicdn.com/tfs/TB17blphfDH8KJjy1XcXXcpdXXa-320-320.png',
    content: '抱歉出错了，我们正在全力解决中',
    button: '再试一次',
    title: '出错啦'
  },
  noGoods: {
    pic: 'https://img.alicdn.com/tfs/TB1mPWEeOqAXuNjy1XdXXaYcVXa-320-320.png',
    content: '主人，这里什么都没有找到',
    button: '再试一次',
    title: '暂无商品'
  },
  noNetwork: {
    pic: 'https://img.alicdn.com/tfs/TB1jkA5g9_I8KJjy0FoXXaFnVXa-320-320.png',
    content: '哎呀，没有网络了......',
    button: '刷新一下',
    title: '无网络'
  },
  errorLocation: {
    pic: 'https://img.alicdn.com/tfs/TB1zXXahhrI8KJjy0FpXXb5hVXa-320-320.png',
    content: '哎呀，定位失败了......',
    button: '刷新一下',
    title: '定位失败'
  }
};

/***/ }),
/* 130 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return (_vm.show) ? _c('div', {
    staticClass: ["wrap"],
    style: _vm.wrapStyle
  }, [_c('div', {
    staticClass: ["wxc-result"],
    style: {
      paddingTop: _vm.setPaddingTop
    }
  }, [_c('image', {
    staticClass: ["result-image"],
    attrs: {
      "ariaHidden": true,
      "src": _vm.resultType.pic
    }
  }), (_vm.resultType.content) ? _c('div', {
    staticClass: ["result-content"]
  }, [_c('text', {
    staticClass: ["content-text"]
  }, [_vm._v(_vm._s(_vm.resultType.content))]), (_vm.resultType.desc) ? _c('text', {
    staticClass: ["content-text", "content-desc"]
  }, [_vm._v(_vm._s(_vm.resultType.desc))]) : _vm._e()]) : _vm._e(), (_vm.resultType.button) ? _c('div', {
    staticClass: ["result-button"],
    on: {
      "touchend": _vm.handleTouchEnd,
      "click": _vm.onClick
    }
  }, [_c('text', {
    staticClass: ["button-text"]
  }, [_vm._v(_vm._s(_vm.resultType.button))])]) : _vm._e()])]) : _vm._e()
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(132)
)

/* script */
__vue_exports__ = __webpack_require__(133)

/* template */
var __vue_template__ = __webpack_require__(135)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-indexlist\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-1227ba08"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 132 */
/***/ (function(module, exports) {

module.exports = {
  "index-list": {
    "width": "750",
    "height": "1334"
  },
  "index-list-title": {
    "borderBottomWidth": "1",
    "borderBottomColor": "rgba(32,35,37,0.15)",
    "backgroundColor": "#FBFBFB",
    "fontSize": "24",
    "color": "#666666",
    "height": "48",
    "lineHeight": "48",
    "paddingLeft": "24",
    "width": "750"
  },
  "group-title": {
    "borderBottomWidth": 0,
    "paddingBottom": 0,
    "height": "60",
    "paddingTop": "24"
  },
  "index-list-item": {
    "width": "750",
    "flexDirection": "row",
    "alignItems": "center",
    "borderBottomWidth": "1",
    "borderBottomColor": "#e0e0e0",
    "height": "92",
    "paddingLeft": "24",
    "paddingRight": "24",
    "backgroundColor": "#FFFFFF"
  },
  "iphone-x": {
    "height": "68"
  },
  "title": {
    "fontSize": "32",
    "color": "#3D3D3D"
  },
  "desc": {
    "fontSize": "24",
    "color": "#A5A5A5",
    "marginLeft": "30"
  },
  "index-list-nav": {
    "position": "absolute",
    "top": 0,
    "right": 0,
    "marginBottom": "60",
    "marginTop": "60",
    "paddingBottom": "20",
    "paddingTop": "20",
    "width": "70"
  },
  "list-nav-key": {
    "textAlign": "center",
    "fontSize": "24",
    "height": "40",
    "color": "#666666"
  },
  "index-list-pop": {
    "position": "fixed",
    "top": "550",
    "left": "316",
    "width": "120",
    "height": "120",
    "textAlign": "center",
    "justifyContent": "center",
    "backgroundColor": "rgba(32,35,37,0.6)",
    "borderBottomLeftRadius": "60",
    "borderBottomRightRadius": "60",
    "borderTopLeftRadius": "60",
    "borderTopRightRadius": "60",
    "paddingLeft": 0,
    "paddingRight": 0,
    "paddingTop": "35",
    "paddingBottom": "35",
    "color": "#ffffff"
  },
  "list-pop-text": {
    "fontSize": "40",
    "textAlign": "center",
    "color": "#ffffff"
  },
  "group": {
    "paddingBottom": "18",
    "paddingRight": "70",
    "backgroundColor": "#FBFBFB"
  },
  "group-list": {
    "flexDirection": "row",
    "marginLeft": "18",
    "marginTop": "18"
  },
  "group-item": {
    "width": "146",
    "height": "64",
    "borderWidth": "1",
    "borderColor": "#e0e0e0",
    "marginRight": "18",
    "flexDirection": "row",
    "alignItems": "center",
    "justifyContent": "center",
    "backgroundColor": "#ffffff"
  },
  "item-name": {
    "fontSize": "24",
    "lineHeight": "26",
    "color": "#333333"
  },
  "item-desc": {
    "marginTop": "2",
    "color": "#999999",
    "fontSize": "20",
    "textAlign": "center"
  },
  "location-icon": {
    "width": "32",
    "height": "32",
    "marginRight": "8"
  }
}

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _format = __webpack_require__(134);

var Format = _interopRequireWildcard(_format);

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var dom = weex.requireModule('dom');
exports.default = {
  props: {
    height: {
      type: [Number, String],
      default: _utils2.default.env.getPageHeight()
    },
    normalList: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    onlyShowList: {
      type: Boolean,
      default: false
    },
    showIndex: {
      type: Boolean,
      default: true
    },
    needAnimation: {
      type: Boolean,
      default: true
    },
    hotListConfig: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    // 城市选择子组件 特殊情况支持
    cityLocationConfig: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    headerStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    navStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    navTextStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    popStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    popTextStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    itemStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    itemTextStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    itemDescStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    groupWrapStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    groupItemStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    groupItemTextStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    groupItemDescStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  created: function created() {
    this.isIPhoneX = _utils2.default.env.isIPhoneX();
  },

  computed: {
    formatList: function formatList() {
      var normalList = this.normalList,
          hotListConfig = this.hotListConfig,
          cityLocationConfig = this.cityLocationConfig;

      return Format.totalList(normalList, hotListConfig, cityLocationConfig);
    }
  },
  data: function data() {
    return {
      popKeyShow: false,
      popKey: '',
      navOffsetY: 0,
      timer: null
    };
  },
  methods: {
    itemClicked: function itemClicked(item) {
      this.$emit('wxcIndexlistItemClicked', {
        item: item
      });
    },
    go2Key: function go2Key(key) {
      var _this = this;

      var keyEl = this.$refs['index-item-title-' + key][0];
      keyEl && dom.scrollToElement(keyEl, {
        offset: 0,
        animated: this.needAnimation
      });
      this.popKey = key;
      this.popKeyShow = true;
      this.timer && clearTimeout(this.timer);
      this.timer = setTimeout(function () {
        _this.popKeyShow = false;
      }, 600);
    }
  }
};

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.totalList = totalList;
exports.getSpecialData = getSpecialData;

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 根据26个字母取每一项首字母对数据进行排序,处理数据变换
 * @return {[array]}
 */
function totalList(source, hotListConfig, cityLocationConfig) {
  var LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  var res = [];
  LETTERS.split('').forEach(function (letter) {
    var _data = source.filter(function (item) {
      if (item.pinYin) {
        return item.pinYin.slice(0, 1).toLowerCase() === letter.toLowerCase();
      } else if (item.py) {
        return item.py.slice(0, 1).toLowerCase() === letter.toLowerCase();
      } else {
        return false;
      }
    });
    if (_data.length) {
      res.push({
        title: letter,
        data: _data,
        type: 'list'
      });
    }
  });

  // 处理热门数据
  var hotList = getSpecialData(hotListConfig);
  hotList && res.unshift(hotList);

  // 处理特殊定位数据
  var cityLocation = getSpecialData(cityLocationConfig);
  cityLocation && res.unshift(cityLocation);

  return res;
} /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

function getSpecialData(data) {
  if (data && data.type && data.list && data.list.length > 0) {
    var type = data.type,
        title = data.title,
        list = data.list;

    return {
      title: title,
      type: type,
      data: type === 'group' ? _utils2.default.arrayChunk(list) : list
    };
  } else {
    return null;
  }
}

/***/ }),
/* 135 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_c('list', {
    staticClass: ["index-list"],
    style: {
      height: _vm.height + 'px'
    }
  }, [_c('cell', {
    appendAsTree: true,
    attrs: {
      "append": "tree"
    }
  }, [_vm._t("head")], 2), _vm._l((_vm.formatList), function(v, i) {
    return _c('cell', {
      key: i,
      ref: 'index-item-title-' + v.title,
      refInFor: true,
      appendAsTree: true,
      attrs: {
        "append": "tree"
      }
    }, [(!_vm.onlyShowList) ? _c('text', {
      class: ['index-list-title', v.type && v.type == 'group' && 'group-title'],
      style: _vm.headerStyle
    }, [_vm._v(_vm._s(v.title))]) : _vm._e(), (v.type && v.type === 'group' && !_vm.onlyShowList) ? _c('div', {
      staticClass: ["group"],
      style: _vm.groupWrapStyle
    }, _vm._l((v.data), function(group, index) {
      return _c('div', {
        key: index,
        staticClass: ["group-list"]
      }, _vm._l((group), function(item, i) {
        return _c('div', {
          key: i,
          staticClass: ["group-item"],
          style: _vm.groupItemStyle,
          attrs: {
            "accessible": true,
            "ariaLabel": ((item.name) + "," + (item.desc?item.desc:''))
          },
          on: {
            "click": function($event) {
              _vm.itemClicked(item)
            }
          }
        }, [(item.isLocation) ? _c('image', {
          staticClass: ["location-icon"],
          attrs: {
            "src": "https://gw.alicdn.com/tfs/TB1JUiUPFXXXXXUXXXXXXXXXXXX-32-32.png"
          }
        }) : _vm._e(), _c('div', [_c('text', {
          staticClass: ["item-name"],
          style: _vm.groupItemTextStyle
        }, [_vm._v(_vm._s(item.name))]), (item.desc) ? _c('text', {
          staticClass: ["item-desc"],
          style: _vm.groupItemDescStyle
        }, [_vm._v(_vm._s(item.desc))]) : _vm._e()])])
      }))
    })) : _vm._e(), (v.type === 'list') ? _c('div', _vm._l((v.data), function(item, index) {
      return _c('div', {
        key: index,
        staticClass: ["index-list-item"],
        style: _vm.itemStyle,
        attrs: {
          "accessible": true,
          "ariaLabel": ((item.name) + "," + (item.desc?item.desc:''))
        },
        on: {
          "click": function($event) {
            _vm.itemClicked(item)
          }
        }
      }, [_c('text', {
        staticClass: ["title"],
        style: _vm.itemTextStyle
      }, [_vm._v(_vm._s(item.name))]), _c('text', {
        staticClass: ["desc"],
        style: _vm.itemDescStyle
      }, [_vm._v(_vm._s(item.desc))])])
    })) : _vm._e()])
  }), (_vm.isIPhoneX) ? _c('cell', {
    staticClass: ["iphone-x"],
    appendAsTree: true,
    attrs: {
      "append": "tree"
    }
  }) : _vm._e()], 2), (_vm.showIndex && !_vm.onlyShowList) ? _c('div', {
    staticClass: ["index-list-nav"],
    style: _vm.navStyle
  }, _vm._l((_vm.formatList), function(item, index) {
    return _c('text', {
      key: index,
      staticClass: ["list-nav-key"],
      style: _vm.navTextStyle,
      attrs: {
        "title": item.title
      },
      on: {
        "click": function($event) {
          _vm.go2Key(item.title)
        }
      }
    }, [_vm._v(_vm._s(item.title))])
  })) : _vm._e(), (_vm.popKeyShow) ? _c('div', {
    staticClass: ["index-list-pop"],
    style: _vm.popStyle
  }, [_c('text', {
    staticClass: ["list-pop-text"],
    style: _vm.popTextStyle
  }, [_vm._v(_vm._s(_vm.popKey))])]) : _vm._e()])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 136 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    ref: "city",
    staticClass: ["wxc-city"],
    style: _vm.cityExtendStyle
  }, [_c('wxc-searchbar', _vm._b({
    ref: "wxc-searchbar",
    on: {
      "wxcSearchbarInputOnInput": _vm.onInput,
      "wxcSearchbarInputReturned": _vm.onSubmit,
      "wxcSearchbarCancelClicked": _vm.onCancel
    }
  }, 'wxc-searchbar', _vm.mergeInputConfig, false)), (_vm.showTab) ? _c('wxc-tab', {
    ref: "wxc-tab",
    on: {
      "wxcTabSwitch": _vm.onTabSwitch
    }
  }) : _vm._e(), _c('wxc-indexlist', {
    attrs: {
      "normalList": _vm.normalList,
      "hotListConfig": _vm.hotListConfig,
      "navStyle": {
        top: '24px'
      },
      "height": _vm.listHeight,
      "showIndex": _vm.showIndex,
      "onlyShowList": !_vm.showNavHeader || _vm.onlyShowList,
      "cityLocationConfig": _vm.currentCityLocationConfig
    },
    on: {
      "wxcIndexlistItemClicked": _vm.onItemClick
    }
  }), (_vm.showError) ? _c('wxc-result', {
    attrs: {
      "type": "noGoods",
      "wrapStyle": {
        top: '84px'
      },
      "show": true,
      "customSet": _vm.result
    }
  }) : _vm._e()], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(138);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(139)
)

/* script */
__vue_exports__ = __webpack_require__(140)

/* template */
var __vue_template__ = __webpack_require__(141)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-countdown\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-15ee4906"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 139 */
/***/ (function(module, exports) {

module.exports = {
  "time-dot-wrap": {
    "flexDirection": "row",
    "alignItems": "center"
  }
}

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  props: {
    // 时间戳
    time: {
      type: Number,
      default: 1501200000000
    },
    // 倒计时的间隔,单位为"毫秒"
    interval: {
      type: Number,
      default: 1000
    },
    tpl: {
      type: String,
      default: '{h}:{m}:{s}'
    },
    // 最外层包裹 style
    timeWrapStyle: Object,
    // 数字盒子 style
    timeBoxStyle: Object,
    // : 盒子Style
    dotBoxStyle: Object,
    // 数字文字 Style
    timeTextStyle: Object,
    // : 文字Style
    dotTextStyle: Object
  },
  data: function data() {
    return {
      NOW_DATE: new Date().getTime(),
      completed: false,
      tplIndexOfDays: -1,
      tplIndexOfHours: -1,
      tplIndexOfMinutes: -1,
      tplIndexOfSeconds: -1,
      TIME_WRAP_STYLE: {
        flexDirection: 'row',
        alignItems: 'center',
        marginLeft: '12px',
        marginRight: '12px'
      },
      TIME_BOX_STYLE: {
        flexDirection: 'row',
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: '#333333',
        height: '30px',
        width: '30px'
      },
      DOT_BOX_STYLE: {
        width: '18px',
        flexDirection: 'row',
        justifyContent: 'center',
        alignItems: 'center'
      },
      TIME_TEXT_STYLE: {
        color: '#FFCC80',
        fontSize: '18px'
      },
      DOT_TEXT_STYLE: {
        color: '#333333',
        fontSize: '18px',
        fontWeight: 'bold'
      }
    };
  },
  mounted: function mounted() {
    var _this = this;

    setInterval(function () {
      _this.NOW_DATE = new Date().getTime();
    }, this.interval);

    this.tplIndexOfDays = this.tpl.indexOf('d');
    this.tplIndexOfHours = this.tpl.indexOf('h');
    this.tplIndexOfMinutes = this.tpl.indexOf('m');
    this.tplIndexOfSeconds = this.tpl.indexOf('s');
  },

  computed: {
    mrTimeWrapStyle: function mrTimeWrapStyle() {
      return _extends({}, this.TIME_WRAP_STYLE, this.timeWrapStyle);
    },
    mrTimeBoxStyle: function mrTimeBoxStyle() {
      return _extends({}, this.TIME_BOX_STYLE, this.timeBoxStyle);
    },
    mrDotBoxStyle: function mrDotBoxStyle() {
      return _extends({}, this.DOT_BOX_STYLE, this.dotBoxStyle);
    },
    mrTimeTextStyle: function mrTimeTextStyle() {
      return _extends({}, this.TIME_TEXT_STYLE, this.timeTextStyle);
    },
    mrDotTextStyle: function mrDotTextStyle() {
      return _extends({}, this.DOT_TEXT_STYLE, this.dotTextStyle);
    },
    countDownData: function countDownData() {
      var timeSpacing = this.time - this.NOW_DATE;

      // 倒计时结束了
      if (timeSpacing < 0) {
        if (this.completed === false) {
          this.$emit('wxcOnComplete');
        }
        this.completed = true;
        return {
          day: '00',
          hour: '00',
          minute: '00',
          second: '00'
        };
      }

      var day = 0;
      var hour = 0;
      var minute = 0;
      var second = 0;

      if (this.tplIndexOfDays !== -1) {
        day = Math.floor(timeSpacing / (24 * 60 * 60 * 1000));
        hour = Math.floor(timeSpacing % (24 * 60 * 60 * 1000) / (60 * 60 * 1000));
      } else {
        day = 0;
        hour = Math.floor(timeSpacing / (60 * 60 * 1000));
      }

      if (this.tplIndexOfHours !== -1) {
        hour = Math.floor((timeSpacing - day * 24 * 60 * 60 * 1000) / (60 * 60 * 1000));
        minute = Math.floor((timeSpacing - day * 24 * 60 * 60 * 1000) % (60 * 60 * 1000) / (60 * 1000));
      } else {
        hour = 0;
        minute = Math.floor((timeSpacing - day * 24 * 60 * 60 * 1000) / (60 * 1000));
      }

      if (this.tplIndexOfMinutes !== -1) {
        minute = Math.floor((timeSpacing - day * 24 * 60 * 60 * 1000 - hour * 60 * 60 * 1000) / (60 * 1000));
        second = Math.floor((timeSpacing - day * 24 * 60 * 60 * 1000 - hour * 60 * 60 * 1000) % (60 * 1000) / 1000);
      } else {
        minute = 0;
        second = Math.floor((timeSpacing - day * 24 * 60 * 60 * 1000 - hour * 60 * 60 * 1000) / 1000);
      }

      return {
        day: day < 10 ? '0' + day : '' + day,
        hour: hour < 10 ? '0' + hour : '' + hour,
        minute: minute < 10 ? '0' + minute : '' + minute,
        second: second < 10 ? '0' + second : '' + second
      };
    }
  },

  methods: {
    getDot: function getDot(prevTagIndex) {
      var nextTagIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

      if (nextTagIndex === -1) {
        return this.tpl.slice(prevTagIndex + 2);
      }
      return this.tpl.slice(prevTagIndex + 2, nextTagIndex - 1);
    }
  }
};

/***/ }),
/* 141 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    style: _vm.mrTimeWrapStyle
  }, [_c('div', {
    staticClass: ["time-dot-wrap"]
  }, [(_vm.tplIndexOfDays !== -1) ? _c('div', {
    style: _vm.mrTimeBoxStyle,
    attrs: {
      "accessible": true,
      "ariaLabel": ((_vm.countDownData.day) + "天")
    }
  }, [_c('text', {
    style: _vm.mrTimeTextStyle
  }, [_vm._v(_vm._s(_vm.countDownData.day))])]) : _vm._e(), (_vm.tplIndexOfDays !== -1) ? _c('div', {
    style: _vm.mrDotBoxStyle,
    attrs: {
      "ariaHidden": true
    }
  }, [_c('text', {
    style: _vm.mrDotTextStyle
  }, [_vm._v(_vm._s(_vm.getDot(_vm.tplIndexOfDays, _vm.tplIndexOfHours)))])]) : _vm._e(), (_vm.tplIndexOfHours !== -1) ? _c('div', {
    style: _vm.mrTimeBoxStyle,
    attrs: {
      "accessible": true,
      "ariaLabel": ((_vm.countDownData.hour) + "时")
    }
  }, [_c('text', {
    style: _vm.mrTimeTextStyle
  }, [_vm._v(_vm._s(_vm.countDownData.hour))])]) : _vm._e(), (_vm.tplIndexOfHours !== -1) ? _c('div', {
    style: _vm.mrDotBoxStyle,
    attrs: {
      "ariaHidden": true
    }
  }, [_c('text', {
    style: _vm.mrDotTextStyle
  }, [_vm._v(_vm._s(_vm.getDot(_vm.tplIndexOfHours, _vm.tplIndexOfMinutes)))])]) : _vm._e(), (_vm.tplIndexOfMinutes !== -1) ? _c('div', {
    style: _vm.mrTimeBoxStyle,
    attrs: {
      "accessible": true,
      "ariaLabel": ((_vm.countDownData.minute) + "分")
    }
  }, [_c('text', {
    style: _vm.mrTimeTextStyle
  }, [_vm._v(_vm._s(_vm.countDownData.minute))])]) : _vm._e(), (_vm.tplIndexOfMinutes !== -1) ? _c('div', {
    style: _vm.mrDotBoxStyle,
    attrs: {
      "ariaHidden": true
    }
  }, [_c('text', {
    style: _vm.mrDotTextStyle
  }, [_vm._v(_vm._s(_vm.getDot(_vm.tplIndexOfMinutes, _vm.tplIndexOfSeconds)))])]) : _vm._e(), (_vm.tplIndexOfSeconds !== -1) ? _c('div', {
    style: _vm.mrTimeBoxStyle,
    attrs: {
      "accessible": true,
      "ariaLabel": ((_vm.countDownData.second) + "秒")
    }
  }, [_c('text', {
    style: _vm.mrTimeTextStyle
  }, [_vm._v(_vm._s(_vm.countDownData.second))])]) : _vm._e(), (_vm.tplIndexOfSeconds !== -1) ? _c('div', {
    style: _vm.mrDotBoxStyle,
    attrs: {
      "ariaHidden": true
    }
  }, [_c('text', {
    style: _vm.mrDotTextStyle
  }, [_vm._v(_vm._s(_vm.getDot(_vm.tplIndexOfSeconds, -1)))])]) : _vm._e()])])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(143);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(144)
)

/* script */
__vue_exports__ = __webpack_require__(145)

/* template */
var __vue_template__ = __webpack_require__(151)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-dialog\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-072b1898"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 144 */
/***/ (function(module, exports) {

module.exports = {
  "container": {
    "position": "fixed",
    "width": "750",
    "zIndex": 99999
  },
  "dialog-box": {
    "position": "fixed",
    "left": "96",
    "width": "558",
    "backgroundColor": "#FFFFFF"
  },
  "dialog-content": {
    "paddingTop": "36",
    "paddingBottom": "36",
    "paddingLeft": "36",
    "paddingRight": "36"
  },
  "content-title": {
    "color": "#333333",
    "fontSize": "36",
    "textAlign": "center",
    "marginBottom": "24"
  },
  "content-subtext": {
    "color": "#666666",
    "fontSize": "26",
    "lineHeight": "36",
    "textAlign": "center"
  },
  "dialog-footer": {
    "flexDirection": "row",
    "alignItems": "center",
    "borderTopColor": "#F3F3F3",
    "borderTopWidth": "1"
  },
  "footer-btn": {
    "flexDirection": "row",
    "alignItems": "center",
    "justifyContent": "center",
    "flex": 1,
    "height": "90"
  },
  "cancel": {
    "borderRightColor": "#F3F3F3",
    "borderRightWidth": "1"
  },
  "btn-text": {
    "fontSize": "36",
    "color": "#666666"
  },
  "no-prompt": {
    "width": "486",
    "alignItems": "center",
    "justifyContent": "center",
    "flexDirection": "row",
    "marginTop": "24"
  },
  "no-prompt-icon": {
    "width": "24",
    "height": "24",
    "marginRight": "12"
  },
  "no-prompt-text": {
    "fontSize": "24",
    "color": "#A5A5A5"
  }
}

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _wxcOverlay = __webpack_require__(14);

var _wxcOverlay2 = _interopRequireDefault(_wxcOverlay);

var _type = __webpack_require__(150);

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  components: { WxcOverlay: _wxcOverlay2.default },
  props: {
    show: {
      type: Boolean,
      default: false
    },
    single: {
      type: Boolean,
      default: false
    },
    title: {
      type: String,
      default: ''
    },
    content: {
      type: String,
      default: ''
    },
    top: {
      type: Number,
      default: 400
    },
    cancelText: {
      type: String,
      default: '取消'
    },
    confirmText: {
      type: String,
      default: '确定'
    },
    mainBtnColor: {
      type: String,
      default: '#EE9900'
    },
    secondBtnColor: {
      type: String,
      default: '#666666'
    },
    showNoPrompt: {
      type: Boolean,
      default: false
    },
    noPromptText: {
      type: String,
      default: '不再提示'
    },
    isChecked: {
      type: Boolean,
      default: false
    },
    left: {
      type: Number,
      default: 0
    }
  },
  data: function data() {
    return {
      noPromptIcon: _type.UN_CHECKED,
      pageHeight: 1334,
      isWeb: _utils2.default.env.isWeb()
    };
  },
  created: function created() {
    var _weex$config$env = weex.config.env,
        deviceHeight = _weex$config$env.deviceHeight,
        deviceWidth = _weex$config$env.deviceWidth;

    this.pageHeight = deviceHeight / deviceWidth * 750;
  },

  methods: {
    secondaryClicked: function secondaryClicked() {
      this.$emit('wxcDialogCancelBtnClicked', {
        type: 'cancel'
      });
    },
    primaryClicked: function primaryClicked(e) {
      this.$emit('wxcDialogConfirmBtnClicked', {
        type: 'confirm'
      });
    },
    noPromptClicked: function noPromptClicked(e) {
      var isChecked = !this.isChecked;
      this.noPromptIcon = isChecked ? _type.CHECKED : _type.UN_CHECKED;
      this.$emit('wxcDialogNoPromptClicked', { isChecked: isChecked });
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(147)
)

/* script */
__vue_exports__ = __webpack_require__(148)

/* template */
var __vue_template__ = __webpack_require__(149)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-overlay\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-5dc5d348"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 147 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-overlay": {
    "width": "750",
    "position": "fixed",
    "bottom": 0,
    "right": 0
  }
}

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var animation = weex.requireModule('animation');
exports.default = {
  props: {
    show: {
      type: Boolean,
      default: true
    },
    top: {
      type: Number,
      default: 0
    },
    left: {
      type: Number,
      default: 0
    },
    hasAnimation: {
      type: Boolean,
      default: true
    },
    duration: {
      type: [Number, String],
      default: 300
    },
    timingFunction: {
      type: Array,
      default: function _default() {
        return ['ease-in', 'ease-out'];
      }
    },
    opacity: {
      type: [Number, String],
      default: 0.6
    },
    canAutoClose: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    overlayStyle: function overlayStyle() {
      return {
        opacity: this.hasAnimation ? 0 : 1,
        backgroundColor: 'rgba(0, 0, 0,' + this.opacity + ')',
        left: _utils2.default.env.isWeb() ? this.left + 'px' : 0,
        top: this.top + 'px'
      };
    },
    shouldShow: function shouldShow() {
      var _this = this;

      var show = this.show,
          hasAnimation = this.hasAnimation;

      hasAnimation && setTimeout(function () {
        _this.appearOverlay(show);
      }, 50);
      return show;
    }
  },
  methods: {
    overlayClicked: function overlayClicked(e) {
      this.canAutoClose ? this.appearOverlay(false) : this.$emit('wxcOverlayBodyClicked', {});
    },
    appearOverlay: function appearOverlay(bool) {
      var _this2 = this;

      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.duration;
      var hasAnimation = this.hasAnimation,
          timingFunction = this.timingFunction,
          canAutoClose = this.canAutoClose;

      var needEmit = !bool && canAutoClose;
      needEmit && this.$emit('wxcOverlayBodyClicking', {});
      var overlayEl = this.$refs['wxc-overlay'];
      if (hasAnimation && overlayEl) {
        animation.transition(overlayEl, {
          styles: {
            opacity: bool ? 1 : 0
          },
          duration: duration,
          timingFunction: timingFunction[bool ? 0 : 1],
          delay: 0
        }, function () {
          needEmit && _this2.$emit('wxcOverlayBodyClicked', {});
        });
      } else {
        needEmit && this.$emit('wxcOverlayBodyClicked', {});
      }
    }
  }
};

/***/ }),
/* 149 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [(_vm.show) ? _c('div', {
    ref: "wxc-overlay",
    staticClass: ["wxc-overlay"],
    style: _vm.overlayStyle,
    attrs: {
      "hack": _vm.shouldShow
    },
    on: {
      "click": _vm.overlayClicked
    }
  }) : _vm._e()])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var CHECKED = exports.CHECKED = 'https://gw.alicdn.com/tfs/TB1UT3VpgMPMeJjy1XdXXasrXXa-42-42.png';
var UN_CHECKED = exports.UN_CHECKED = 'https://gw.alicdn.com/tfs/TB1hE3VpgMPMeJjy1XdXXasrXXa-42-42.png';

/***/ }),
/* 151 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["container"]
  }, [(_vm.show) ? _c('wxc-overlay', {
    attrs: {
      "left": _vm.left,
      "show": true,
      "hasAnimation": false
    }
  }) : _vm._e(), (_vm.show) ? _c('div', {
    staticClass: ["dialog-box"],
    style: {
      top: _vm.top + 'px',
      left: ((_vm.isWeb ? _vm.left : 0) + 96) + 'px'
    }
  }, [_c('div', {
    staticClass: ["dialog-content"]
  }, [_vm._t("title", [_c('text', {
    staticClass: ["content-title"]
  }, [_vm._v(_vm._s(_vm.title))])]), _vm._t("content", [_c('text', {
    staticClass: ["content-subtext"]
  }, [_vm._v(_vm._s(_vm.content))])]), (_vm.showNoPrompt) ? _c('div', {
    staticClass: ["no-prompt"],
    on: {
      "click": _vm.noPromptClicked
    }
  }, [_c('image', {
    staticClass: ["no-prompt-icon"],
    attrs: {
      "src": _vm.noPromptIcon
    }
  }), _c('text', {
    staticClass: ["no-prompt-text"]
  }, [_vm._v(_vm._s(_vm.noPromptText))])]) : _vm._e()], 2), _c('div', {
    staticClass: ["dialog-footer"]
  }, [(!_vm.single) ? _c('div', {
    staticClass: ["footer-btn", "cancel"],
    on: {
      "click": _vm.secondaryClicked
    }
  }, [_c('text', {
    staticClass: ["btn-text"],
    style: {
      color: _vm.secondBtnColor
    }
  }, [_vm._v(_vm._s(_vm.cancelText))])]) : _vm._e(), _c('div', {
    staticClass: ["footer-btn", "confirm"],
    on: {
      "click": _vm.primaryClicked
    }
  }, [_c('text', {
    staticClass: ["btn-text"],
    style: {
      color: _vm.mainBtnColor
    }
  }, [_vm._v(_vm._s(_vm.confirmText))])])])]) : _vm._e()], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(153);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(154)
)

/* script */
__vue_exports__ = __webpack_require__(155)

/* template */
var __vue_template__ = __webpack_require__(156)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-ep-slider\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-30efe70f"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 154 */
/***/ (function(module, exports) {

module.exports = {
  "slider": {
    "position": "absolute",
    "top": 0
  }
}

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

var _bindEnv = __webpack_require__(5);

var _bindEnv2 = _interopRequireDefault(_bindEnv);

var _indexWeex = __webpack_require__(4);

var _indexWeex2 = _interopRequireDefault(_indexWeex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var swipeBack = weex.requireModule('swipeBack');
var animation = weex.requireModule('animation');
exports.default = {
  props: {
    sliderId: {
      type: [String, Number],
      default: 1
    },
    panOffset: {
      type: Number,
      default: 80
    },
    cardLength: {
      type: Number,
      default: 1
    },
    selectIndex: {
      type: Number,
      default: 0
    },
    enableSwipe: {
      type: Boolean,
      default: true
    },
    containerS: {
      type: Object,
      default: function _default() {
        return {
          position: 'relative',
          width: 750,
          height: 352
        };
      }
    },
    cardS: {
      type: Object,
      default: function _default() {
        return {
          width: 360,
          height: 300,
          spacing: 0,
          scale: 0.75
        };
      }
    },
    autoPlay: {
      type: Boolean,
      default: false
    },
    interval: {
      type: [Number, String],
      default: 1200
    }
  },
  data: function data() {
    return {
      isMoving: false,
      gesToken: 0,
      startX: 0,
      startTime: 0,
      currentIndex: 0,
      autoPlayTimer: null
    };
  },
  computed: {
    cardList: function cardList() {
      return new Array(this.cardLength + 1).join().split('');
    },
    cardWidth: function cardWidth() {
      return (this.cardLength - 1) * this.cardS.width + this.containerS.width + 235;
    }
  },
  created: function created() {
    this.currentIndex = this.selectIndex;
  },
  mounted: function mounted() {
    var _this = this;

    // ios和页面返回冲突，组件里面将ios系统横滑返回禁止
    if (swipeBack && swipeBack.forbidSwipeBack) {
      swipeBack.forbidSwipeBack(true);
    }

    setTimeout(function () {
      var sliderCtn = _this.$refs['sliderCtn_' + _this.sliderId];
      if (_bindEnv2.default.supportsEB() && sliderCtn && sliderCtn.ref) {
        _indexWeex2.default.prepare && _indexWeex2.default.prepare({
          anchor: sliderCtn.ref,
          eventType: 'pan'
        });
      }
    }, 20);
    this.checkNeedAutoPlay();
  },

  methods: {
    onPanStart: function onPanStart(e) {
      if (_bindEnv2.default.supportsEB()) {
        return;
      }
      this.clearAutoPlay();
      this.startX = e.changedTouches[0].clientX;
      this.startTime = Date.now();
    },
    onPanMove: function onPanMove(e) {
      if (_bindEnv2.default.supportsEB()) {
        return;
      }
      var moveX = e.changedTouches[0].clientX - this.startX;
      var index = this.loopedIndex(this.currentIndex, this.cardLength);
      var cardLength = this.cardLength;
      var currentCardLeft = this.currentIndex * (this.cardS.width + this.cardS.spacing);

      var sliderCtn = this.$refs['sliderCtn_' + this.sliderId];
      sliderCtn && animation.transition(sliderCtn, {
        styles: {
          transform: 'translateX(' + (moveX - currentCardLeft) + 'px)'
        },
        timingFunction: 'ease',
        delay: 0,
        duration: 0
      }, function () {});

      if (this.cardS.scale !== 1) {
        var currentCard = this.$refs['card' + this.loopedIndex(index, cardLength) + '_' + this.sliderId][0];
        currentCard && animation.transition(currentCard, {
          styles: {
            transform: 'scale(' + (1 - Math.abs(moveX) / this.cardS.width * (1 - this.cardS.scale)) + ')'
          },
          timingFunction: 'ease',
          delay: 0,
          duration: 0
        }, function () {});
        // 左边的卡片
        var leftCard = this.$refs['card' + this.loopedIndex(index - 1, cardLength) + '_' + this.sliderId][0];
        // loop 函数负数返回 0，这里有点冲突
        if (leftCard && index !== 0) {
          animation.transition(leftCard, {
            styles: {
              transform: 'scale(' + (1 - Math.abs(moveX - this.cardS.width) / this.cardS.width * (1 - this.cardS.scale)) + ')'
            },
            timingFunction: 'ease',
            delay: 0,
            duration: 0
          }, function () {});
        }
        // 右边卡片
        var rightCard = this.$refs['card' + this.loopedIndex(index + 1, cardLength) + '_' + this.sliderId][0];
        rightCard && animation.transition(rightCard, {
          styles: {
            transform: 'scale(' + (1 - Math.abs(this.cardS.width + moveX) / this.cardS.width * (1 - this.cardS.scale)) + ')'
          },
          timingFunction: 'ease',
          delay: 0,
          duration: 0
        }, function () {});
      }
    },
    onEpPanStart: function onEpPanStart(e) {
      var _this2 = this;

      if (_bindEnv2.default.supportsEB() && e.state === 'start') {
        this.clearAutoPlay();
        setTimeout(function () {
          var sliderCtn = _this2.$refs['sliderCtn_' + _this2.sliderId];
          _this2.bindExp(sliderCtn);
        }, 0);
      }
    },
    onPanEnd: function onPanEnd(e) {
      if (_bindEnv2.default.supportsEB()) {
        return;
      }
      this.panEnd(e);
    },
    panEnd: function panEnd(e) {
      var _this3 = this;

      this.isMoving = true;
      var moveX = e.deltaX;

      if (_utils2.default.env.isWeb()) {
        moveX = e.changedTouches[0].clientX - this.startX;
      }

      var originIndex = this.currentIndex;
      var selectIndex = originIndex;
      var duration = Date.now() - this.startTime;
      var panOffset = this.panOffset || this.cardS.width / 2;
      var isPullMore = selectIndex === this.cardLength - 1 && (moveX < -68 || moveX < -10 && duration < 200);

      if (isPullMore) {
        this.$emit('wxcEpSliderPullMore', { currentIndex: selectIndex });
      }

      if (moveX < -panOffset || moveX < -10 && duration < 200) {
        if (selectIndex !== this.cardLength - 1) {
          selectIndex++;
        }
      } else if (moveX > panOffset || moveX > 10 && duration < 500) {
        if (selectIndex !== 0) {
          selectIndex--;
        }
      }

      this.slideTo(originIndex, selectIndex);
      setTimeout(function () {
        _this3.checkNeedAutoPlay();
      }, 3000);
    },
    slideTo: function slideTo(originIndex, selectIndex) {
      var _this4 = this;

      var currentCardScale = 1;
      var rightCardScale = this.cardS.scale;
      var leftCardScale = this.cardS.scale;
      var duration = selectIndex === 0 && originIndex === this.cardLength - 1 && this.cardLength !== 2 ? 0.00001 : 300;
      this.$emit('wxcEpSliderCurrentIndexSelected', { currentIndex: selectIndex });
      if (originIndex < selectIndex) {
        currentCardScale = this.cardS.scale;
        rightCardScale = 1;
      } else if (originIndex > selectIndex) {
        currentCardScale = this.cardS.scale;
        leftCardScale = 1;
      }
      var currentCard = this.$refs['card' + this.loopedIndex(originIndex, this.cardLength) + '_' + this.sliderId][0];
      currentCard && animation.transition(currentCard, {
        styles: {
          transform: 'scale(' + currentCardScale + ')'
        },
        timingFunction: 'ease',
        duration: duration
      }, function () {});

      var leftCard = this.$refs['card' + this.loopedIndex(originIndex - 1, this.cardLength) + '_' + this.sliderId][0];
      if (this.isMoving && leftCard && originIndex !== 0) {
        animation.transition(leftCard, {
          styles: {
            transform: 'scale(' + leftCardScale + ')'
          },
          timingFunction: 'ease',
          duration: duration
        }, function () {});
      }
      var rightCard = this.$refs['card' + this.loopedIndex(originIndex + 1, this.cardLength) + '_' + this.sliderId][0];
      if (rightCard && originIndex !== this.cardLength - 1) {
        animation.transition(rightCard, {
          styles: {
            transform: 'scale(' + rightCardScale + ')'
          },
          timingFunction: 'ease',
          duration: duration
        }, function () {});
      }

      var sliderCtn = this.$refs['sliderCtn_' + this.sliderId];
      sliderCtn && animation.transition(sliderCtn, {
        styles: {
          transform: 'translateX(-' + selectIndex * (this.cardS.width + this.cardS.spacing) + 'px)'
        },
        timingFunction: 'ease',
        duration: duration
      }, function () {
        _this4.isMoving = false;
        if (originIndex !== selectIndex) {
          _this4.currentIndex = selectIndex;
        }
      });
    },

    // 使index维持在0-length之间循环
    loopedIndex: function loopedIndex(index, total) {
      if (index < 0) {
        index = index + (1 - index / total) * total;
      }
      return parseInt(index % total);
    },
    bindExp: function bindExp(element) {
      var _this5 = this;

      if (element && element.ref) {
        if (this.isMoving && this.gesToken !== 0) {
          _indexWeex2.default.unbind({
            eventType: 'pan',
            token: this.gesToken
          });
          this.gesToken = 0;
          return;
        }

        this.startTime = Date.now();
        var index = this.loopedIndex(this.currentIndex, this.cardLength);
        var sliderCtn = this.$refs['sliderCtn_' + this.sliderId];
        var currentCard = this.$refs['card' + index + '_' + this.sliderId][0];
        var rightCard = null;
        var leftCard = null;
        var currentCardLeft = this.currentIndex * (this.cardS.width + this.cardS.spacing);

        // 卡片容器
        var sliderCtnExp = 'x - ' + currentCardLeft;
        var args = [{
          element: sliderCtn.ref,
          property: 'transform.translateX',
          expression: sliderCtnExp
        }];

        if (this.cardS.scale !== 1) {
          var currentCardExp = '1-abs(x)/' + this.cardS.width + '*' + (1 - this.cardS.scale);
          var leftCardExp = '1-abs(x-' + this.cardS.width + ')/' + this.cardS.width + '*' + (1 - this.cardS.scale);
          var rightCardExp = '1-abs(' + this.cardS.width + '+x)/' + this.cardS.width + '*' + (1 - this.cardS.scale);

          args.push({
            element: currentCard.ref,
            property: 'transform.scale',
            expression: currentCardExp
          });

          if (index === 0 && this.$refs['card' + (index + 1) + '_' + this.sliderId]) {
            rightCard = this.$refs['card' + (index + 1) + '_' + this.sliderId][0];
            args.push({
              element: rightCard.ref,
              property: 'transform.scale',
              expression: rightCardExp
            });
          } else if (index === this.cardLength - 1 && this.$refs['card' + (index - 1) + '_' + this.sliderId]) {
            leftCard = this.$refs['card' + (index - 1) + '_' + this.sliderId][0];
            args.push({
              element: leftCard.ref,
              property: 'transform.scale',
              expression: leftCardExp
            });
          } else if (this.$refs['card' + (index - 1) + '_' + this.sliderId]) {
            // 左边卡片
            leftCard = this.$refs['card' + (index - 1) + '_' + this.sliderId][0];
            args.push({
              element: leftCard.ref,
              property: 'transform.scale',
              expression: leftCardExp
            });
            // 右边卡片
            rightCard = this.$refs['card' + (index + 1) + '_' + this.sliderId][0];
            args.push({
              element: rightCard.ref,
              property: 'transform.scale',
              expression: rightCardExp
            });
          }
        }

        var gesTokenObj = _indexWeex2.default.bind({
          anchor: element.ref,
          eventType: 'pan',
          props: args
        }, function (e) {
          if (!_this5.isMoving && (e.state === 'end' || e.state === 'cancel' || e.state === 'exit')) {
            _this5.panEnd(e);
          }
        });

        this.gesToken = gesTokenObj.token;
      }
    },
    checkNeedAutoPlay: function checkNeedAutoPlay() {
      var _this6 = this;

      if (this.autoPlay) {
        this.clearAutoPlay();
        this.autoPlayTimer = setInterval(function () {
          _this6.slideTo(_this6.currentIndex, _this6.loopedIndex(_this6.currentIndex + 1, _this6.cardLength));
        }, parseInt(this.interval));
      }
    },
    clearAutoPlay: function clearAutoPlay() {
      this.autoPlayTimer && clearInterval(this.autoPlayTimer);
    },
    rebind: function rebind() {
      var sliderCtn = this.$refs['sliderCtn_' + this.sliderId];
      if (sliderCtn && sliderCtn.ref) {
        _indexWeex2.default.unbind({
          eventType: 'pan',
          token: this.gesToken
        });
        this.gesToken = 0;
        this.bindExp(sliderCtn);
      }
    },
    manualSetPage: function manualSetPage(selectIndex) {
      var _this7 = this;

      this.clearAutoPlay();
      var step = this.currentIndex < selectIndex ? 1 : -1;
      this.slideTo(this.loopedIndex(selectIndex - step, this.cardLength), selectIndex);
      setTimeout(function () {
        _this7.checkNeedAutoPlay();
      }, 3000);
    }
  }
};

/***/ }),
/* 156 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    style: _vm.containerS
  }, [_c('div', {
    ref: ("sliderCtn_" + _vm.sliderId),
    style: {
      width: _vm.cardWidth + 'px',
      height: _vm.cardS.height + 'px',
      transform: ("translateX(-" + (_vm.currentIndex * (_vm.cardS.width + _vm.cardS.spacing)) + "px)")
    },
    on: {
      "panstart": _vm.onPanStart,
      "panmove": _vm.onPanMove,
      "panend": _vm.onPanEnd,
      "horizontalpan": _vm.onEpPanStart
    }
  }, [_vm._l((_vm.cardList), function(v, index) {
    return _c('div', {
      ref: ("card" + index + "_" + _vm.sliderId),
      refInFor: true,
      staticClass: ["slider"],
      style: {
        transform: ("scale(" + (index===_vm.currentIndex ? 1 : _vm.cardS.scale) + ")"),
        left: ((index * (_vm.cardS.width+_vm.cardS.spacing)) + "px"),
        marginLeft: (((_vm.containerS.width - _vm.cardS.width) / 2) + "px"),
        width: _vm.cardS.width + 'px',
        height: _vm.cardS.height + 'px'
      }
    }, [_vm._t(("card" + index + "_" + _vm.sliderId))], 2)
  }), _vm._t("pull-more")], 2)])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fullPage = __webpack_require__(158);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_fullPage).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(159)
)

/* script */
__vue_exports__ = __webpack_require__(160)

/* template */
var __vue_template__ = __webpack_require__(161)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-tab-page\\full-page.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-6a618012"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 159 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-tab-page": {
    "width": "750",
    "backgroundColor": "#f2f3f4"
  },
  "tab-title-list": {
    "width": "750",
    "position": "absolute",
    "flexDirection": "row"
  },
  "title-item": {
    "justifyContent": "center",
    "alignItems": "center",
    "borderBottomStyle": "solid"
  },
  "border-bottom": {
    "position": "absolute",
    "bottom": 0
  },
  "tab-page-wrap": {
    "width": "750"
  },
  "tab-container": {
    "flex": 1,
    "flexDirection": "row",
    "position": "absolute"
  },
  "tab-text": {
    "lines": 1,
    "textOverflow": "ellipsis"
  }
}

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

var _bindEnv = __webpack_require__(5);

var _bindEnv2 = _interopRequireDefault(_bindEnv);

var _indexWeex = __webpack_require__(4);

var _indexWeex2 = _interopRequireDefault(_indexWeex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var dom = weex.requireModule('dom');
var animation = weex.requireModule('animation');
var swipeBack = weex.requireModule('swipeBack');
var expressionBinding = weex.requireModule('expressionBinding');

var isIos = _utils2.default.env.isIOS();

exports.default = {
  props: {
    tabTitles: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    panDist: {
      type: Number,
      default: 200
    },
    spmC: {
      type: [String, Number],
      default: ''
    },
    tabStyles: {
      type: Object,
      default: function _default() {
        return {
          titleColor: '#666666',
          activeTitleColor: '#3D3D3D',
          isActiveTitleBold: true,
          width: 160,
          height: 40,
          fontSize: 24,
          textPaddingLeft: 10,
          textPaddingRight: 10
        };
      }
    },
    titleType: {
      type: String,
      default: 'icon'
    },
    tabPageHeight: {
      type: [String, Number],
      default: 1334
    },
    needSlider: {
      type: Boolean,
      default: true
    },
    duration: {
      type: [Number, String],
      default: 300
    },
    timingFunction: {
      type: String,
      default: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
    }
  },
  data: function data() {
    return {
      currentPage: 0,
      isMoving: false,
      deltaX: 0
    };
  },
  mounted: function mounted() {
    // ios 下面禁止左滑出去
    if (swipeBack && swipeBack.forbidSwipeBack) {
      swipeBack.forbidSwipeBack(true);
    }
    if (_bindEnv2.default.supportsEBForIos() && this.needSlider) {
      var tabPageEl = this.$refs['tab-page-wrap'];
      _indexWeex2.default.prepare && _indexWeex2.default.prepare({
        anchor: tabPageEl.ref,
        eventType: 'pan'
      });
    }
  },

  methods: {
    next: function next() {
      var page = this.currentPage;
      if (page < this.tabTitles.length - 1) {
        page++;
      }
      this.setPage(page);
    },
    prev: function prev() {
      var page = this.currentPage;
      if (page > 0) {
        page--;
      }
      this.setPage(page);
    },
    startHandler: function startHandler(e) {
      if (_bindEnv2.default.supportsEBForIos() && this.isTabView && this.needSlider) {
        this.bindExp(this.$refs['tab-page-wrap']);
      }
    },
    bindExp: function bindExp(element) {
      var _this = this;

      if (element && element.ref) {

        if (this.isMoving && this.gesToken !== 0) {
          _indexWeex2.default.unbind({
            eventType: 'pan',
            token: this.gesToken
          });
          this.gesToken = 0;
          return;
        }

        var tabElement = this.$refs['tab-container'];
        var currentPage = this.currentPage,
            panDist = this.panDist;

        var dist = currentPage * 750;

        // x-dist

        var props = [{
          element: tabElement.ref,
          property: 'transform.translateX',
          expression: '{"type":"CallExpression","children":[{"type":"Identifier","value":"min"},{"type":"Arguments","children":[{"type":"NumericLiteral","value":0},{"type":"CallExpression","children":[{"type":"Identifier","value":"max"},{"type":"Arguments","children":[{"type":"NumericLiteral","value":' + -(tabTitles.length - 1) * 750 + '},{"type":"-","children":[{"type":"Identifier","value":"x"},{"type":"NumericLiteral","value":' + dist + '}]}]}]}]}]}'
        }];

        var gesTokenObj = _indexWeex2.default.bind({
          anchor: element.ref,
          eventType: 'pan',
          props: props
        }, function (e) {
          var deltaX = e.deltaX,
              state = e.state;

          if (state === 'end') {
            if (deltaX < -panDist) {
              _this.next();
            } else if (deltaX > panDist) {
              _this.prev();
            } else {
              _this.setPage(currentPage);
            }
          }
        });
        this.gesToken = gesTokenObj.token;
      }
    },
    setPage: function setPage(page) {
      if (this.isMoving === true) {
        return;
      }
      this.isMoving = true;
      var previousPage = this.currentPage;
      var currentTabEl = this.$refs['wxc-tab-title-' + page][0];
      var width = this.tabStyles.width;

      var appearNum = parseInt(750 / width);
      var tabsNum = this.tabTitles.length;
      var computedPage = tabsNum > appearNum ? 2 : page;
      var offset = page > appearNum ? -(750 - width) / 2 : -width * computedPage;

      (previousPage > appearNum || page > 1) && dom.scrollToElement(currentTabEl, {
        offset: offset
      });

      page <= 1 && previousPage > page && dom.scrollToElement(currentTabEl, {
        offset: -width * page
      });
      this._animateTransformX(page);
      this.isMoving = false;
      this.currentPage = page;
      this.$emit('wxcTabPageCurrentTabSelected', { page: page });
    },
    _animateTransformX: function _animateTransformX(page) {
      var duration = this.duration,
          timingFunction = this.timingFunction;

      var containerEl = this.$refs['tab-container'];
      var dist = page * 750;
      animation.transition(containerEl, {
        styles: {
          transform: 'translateX(' + -dist + 'px)'
        },
        duration: duration,
        timingFunction: timingFunction,
        delay: 0
      }, function () {});
    }
  }
};

/***/ }),
/* 161 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["wxc-tab-page"],
    style: {
      height: (_vm.tabPageHeight) + 'px'
    }
  }, [_c('div', {
    ref: "tab-page-wrap",
    staticClass: ["tab-page-wrap"],
    style: {
      height: _vm.tabPageHeight + 'px'
    },
    attrs: {
      "preventMoveEvent": true
    },
    on: {
      "horizontalpan": _vm.startHandler
    }
  }, [_c('div', {
    ref: "tab-container",
    staticClass: ["tab-container"]
  }, [_vm._t("default")], 2)]), _c('scroller', {
    ref: "tab-title-list",
    staticClass: ["tab-title-list"],
    style: {
      backgroundColor: _vm.tabStyles.bgColor,
      height: (_vm.tabStyles.height) + 'px',
      top: _vm.tabStyles.top + 'px'
    },
    attrs: {
      "showScrollbar": false,
      "scrollDirection": "horizontal",
      "dataSpm": _vm.spmC
    }
  }, _vm._l((_vm.tabTitles), function(v, index) {
    return _c('div', {
      key: index,
      ref: 'wxc-tab-title-' + index,
      refInFor: true,
      staticClass: ["title-item"],
      style: {
        width: _vm.tabStyles.width + 'px',
        height: _vm.tabStyles.height + 'px',
        backgroundColor: _vm.currentPage == index ? _vm.tabStyles.activeBgColor : _vm.tabStyles.bgColor
      },
      attrs: {
        "accessible": true,
        "ariaLabel": ("" + (v.title?v.title:'标签'+index))
      },
      on: {
        "click": function($event) {
          _vm.setPage(index, v.url)
        }
      }
    }, [(_vm.titleType == 'icon') ? _c('image', {
      style: {
        width: _vm.tabStyles.iconWidth + 'px',
        height: _vm.tabStyles.iconHeight + 'px'
      },
      attrs: {
        "src": _vm.currentPage == index ? v.activeIcon : v.icon
      }
    }) : _vm._e(), _c('text', {
      staticClass: ["tab-text"],
      style: {
        fontSize: _vm.tabStyles.fontSize + 'px',
        fontWeight: (_vm.currentPage == index && _vm.tabStyles.isActiveTitleBold) ? 'bold' : 'normal',
        color: _vm.currentPage == index ? _vm.tabStyles.activeTitleColor : _vm.tabStyles.titleColor,
        paddingLeft: (_vm.tabStyles.textPaddingLeft ? _vm.tabStyles.textPaddingLeft : 10) + 'px',
        paddingRight: (_vm.tabStyles.textPaddingRight ? _vm.tabStyles.textPaddingRight : 10) + 'px'
      }
    }, [_vm._v(_vm._s(v.title))]), (_vm.tabStyles.hasActiveBottom) ? _c('div', {
      staticClass: ["border-bottom"],
      style: {
        width: _vm.tabStyles.activeBottomWidth + 'px',
        left: (_vm.tabStyles.width - _vm.tabStyles.activeBottomWidth) / 2 + 'px',
        height: _vm.tabStyles.activeBottomHeight + 'px',
        backgroundColor: _vm.currentPage == index ? _vm.tabStyles.activeBottomColor : 'transparent'
      }
    }) : _vm._e()])
  }))])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(163);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(164)
)

/* script */
__vue_exports__ = __webpack_require__(165)

/* template */
var __vue_template__ = __webpack_require__(170)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-grid-select\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-39973ea2"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 164 */
/***/ (function(module, exports) {

module.exports = {
  "grid-select": {
    "flexDirection": "row",
    "justifyContent": "space-between",
    "flexWrap": "wrap"
  }
}

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _option = __webpack_require__(166);

var _option2 = _interopRequireDefault(_option);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  components: { Option: _option2.default },
  props: {
    // 标识, 当界面展示多个grid, 防止v-for :key重复
    id: {
      type: String,
      default: 'one'
    },
    // 列数
    cols: {
      type: Number,
      default: 4
    },
    // 是否单选
    single: {
      type: Boolean,
      default: false
    },
    // 数据
    list: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    // 选择个数限制
    limit: {
      type: Number
    },
    // 用户自定义样式，用于个性化设置option样式
    customStyles: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  data: function data() {
    return {
      dList: this.initList()
    };
  },

  computed: {
    cHackList: function cHackList() {
      var list = this.list,
          cols = this.cols;

      var remainder = list.length % cols;
      var len = remainder ? cols - remainder : 0;

      return Array.apply(null, { length: len });
    }
  },
  watch: {
    list: function list() {
      this.dList = this.initList();
    }
  },
  created: function created() {
    // 行间距
    this.lineSpacing = this.customStyles.lineSpacing || '12px';
  },

  methods: {
    onSelect: function onSelect(index) {
      var checked = this.dList[index].checked;
      if (this.limit <= this.checkedCount && !checked) {
        this.$emit('overLimit', this.limit);
      } else {
        this.updateList(index);
        this.$emit('select', {
          selectIndex: index,
          checked: !checked,
          checkedList: this.dList.filter(function (item) {
            return item.checked;
          })
        });
      }
    },
    initList: function initList() {
      var single = this.single;
      var checkedCount = 0;

      var dList = this.list.map(function (item, i) {
        var checked = item.checked,
            disabled = item.disabled;

        disabled = !!disabled;
        // disabled为true时认为checked无效，同时单选模式下只认为第一个checked为true的为有效值
        checked = !disabled && !!checked && (!single || checkedCount === 0);
        if (item.checked) checkedCount += 1;
        return _extends({}, item, {
          checked: checked,
          disabled: disabled
        });
      });

      this.checkedCount = checkedCount;
      return dList;
    },
    updateList: function updateList(index) {
      var single = this.single;
      var checkedCount = 0;
      this.dList = this.dList.map(function (item, i) {
        if (single) {
          item.checked = index === i && !item.checked;
        } else {
          if (i === index) item.checked = !item.checked;
        }
        if (item.checked) checkedCount += 1;
        return item;
      });
      this.checkedCount = checkedCount;
    }
  }
};

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(167)
)

/* script */
__vue_exports__ = __webpack_require__(168)

/* template */
var __vue_template__ = __webpack_require__(169)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-grid-select\\option.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-a962fa30"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 167 */
/***/ (function(module, exports) {

module.exports = {
  "grid-option": {
    "justifyContent": "center",
    "borderRadius": "8",
    "borderWidth": "2",
    "paddingLeft": "6",
    "paddingRight": "6"
  },
  "text-title": {
    "lines": 2,
    "lineHeight": "30",
    "textOverflow": "ellipsis",
    "textAlign": "center",
    "fontSize": "26"
  },
  "image-checked": {
    "position": "absolute",
    "right": 0,
    "bottom": 0,
    "width": "38",
    "height": "34"
  }
}

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  props: {
    index: {
      type: Number,
      default: -1
    },
    // 是否选中
    checked: {
      type: Boolean,
      default: false
    },
    // 是否可选
    disabled: {
      type: Boolean,
      default: false
    },
    // 标题
    title: {
      type: String,
      default: ''
    },
    width: {
      type: String,
      default: '166px'
    },
    height: {
      type: String,
      default: '72px'
    },
    // 默认 x
    icon: {
      type: String,
      default: 'https://gw.alicdn.com/tfs/TB1IAByhgMPMeJjy1XdXXasrXXa-38-34.png'
    },
    // 正常状态文字色值
    color: {
      type: String,
      default: '#3d3d3d'
    },
    // 选中状态文字色值
    checkedColor: {
      type: String,
      default: '#3d3d3d'
    },
    // 不可选状态文字色值
    disabledColor: {
      type: String,
      default: '#9b9b9b'
    },
    // 正常状态边框色值
    borderColor: {
      type: String,
      default: 'transparent'
    },
    // 选中状态边框色值
    checkedBorderColor: {
      type: String,
      default: '#ffb200'
    },
    // 不可选状态边框色值
    disabledBorderColor: {
      type: String,
      default: 'transparent'
    },
    // 正常状态背景色值
    backgroundColor: {
      type: String,
      default: '#f6f6f6'
    },
    // 选中状态背景色值
    checkedBackgroundColor: {
      type: String,
      default: '#ffffff'
    },
    // 不可选状态背景色值
    disabledBackgroundColor: {
      type: String,
      default: '#f6f6f6'
    }
  },
  computed: {
    cWrapperStyle: function cWrapperStyle() {
      var checked = this.checked,
          disabled = this.disabled,
          width = this.width,
          height = this.height,
          borderColor = this.borderColor,
          checkedBorderColor = this.checkedBorderColor,
          disabledBorderColor = this.disabledBorderColor,
          backgroundColor = this.backgroundColor,
          checkedBackgroundColor = this.checkedBackgroundColor,
          disabledBackgroundColor = this.disabledBackgroundColor;

      return {
        width: width,
        height: height,
        borderColor: disabled ? disabledBorderColor : checked ? checkedBorderColor : borderColor,
        backgroundColor: disabled ? disabledBackgroundColor : checked ? checkedBackgroundColor : backgroundColor
      };
    },
    cTitleStyle: function cTitleStyle() {
      var checked = this.checked,
          disabled = this.disabled,
          color = this.color,
          checkedColor = this.checkedColor,
          disabledColor = this.disabledColor;

      return {
        color: disabled ? disabledColor : checked ? checkedColor : color
      };
    }
  },
  methods: {
    onClick: function onClick() {
      if (!this.disabled) {
        this.$emit('select', this.index);
      }
    }
  }
};

/***/ }),
/* 169 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["grid-option"],
    style: _vm.cWrapperStyle,
    attrs: {
      "accessible": true,
      "ariaLabel": (_vm.title + "," + (_vm.checked?'已选中':'未选中'))
    },
    on: {
      "click": _vm.onClick
    }
  }, [(_vm.title) ? _c('text', {
    staticClass: ["text-title"],
    style: _vm.cTitleStyle
  }, [_vm._v(_vm._s(_vm.title))]) : _vm._e(), (_vm.checked && _vm.icon) ? _c('image', {
    staticClass: ["image-checked"],
    attrs: {
      "src": _vm.icon
    }
  }) : _vm._e()])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 170 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["grid-select"]
  }, [_vm._l((_vm.dList), function(item, index) {
    return _c('option', _vm._b({
      key: index,
      style: {
        marginTop: index >= _vm.cols ? _vm.lineSpacing : null
      },
      attrs: {
        "index": index
      },
      on: {
        "select": function($event) {
          _vm.onSelect(index)
        }
      }
    }, 'option', Object.assign({}, _vm.customStyles, item), false))
  }), _vm._l((_vm.cHackList), function(item, index) {
    return _c('option', _vm._b({
      key: _vm.id + index,
      style: {
        opacity: 0,
        marginTop: _vm.dList.length >= _vm.cols ? _vm.lineSpacing : null
      }
    }, 'option', Object.assign({}, _vm.customStyles, item), false))
  })], 2)
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(172);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(173)
)

/* script */
__vue_exports__ = __webpack_require__(174)

/* template */
var __vue_template__ = __webpack_require__(176)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-icon\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-12c9d709"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 173 */
/***/ (function(module, exports) {

module.exports = {
  "icon-font": {
    "color": "#666666"
  }
}

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _type = __webpack_require__(175);

var _type2 = _interopRequireDefault(_type);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var dom = weex.requireModule('dom');

exports.default = {
  props: {
    name: {
      default: 'success',
      type: String
    },
    size: {
      default: 'small',
      type: String
    },
    iconStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  data: function data() {
    return {
      Icon: _type2.default
    };
  },
  beforeCreate: function beforeCreate() {
    dom.addRule('fontFace', {
      'fontFamily': "weexUiIconFont",
      'src': "url('https://at.alicdn.com/t/font_520368_r89ekv69euahsemi.ttf')"
    });
  },

  computed: {
    mergeStyle: function mergeStyle() {
      var iconStyle = this.iconStyle,
          size = this.size;

      var fontSize = '48px';
      switch (size) {
        case 'xs':
          fontSize = '24px';
          break;
        case 'small':
          fontSize = '48px';
          break;
        case 'medium':
          fontSize = '72px';
          break;
        case 'big':
          fontSize = '128px';
          break;
        default:
          fontSize = '48px';
      }
      return _extends({
        fontFamily: 'weexUiIconFont',
        fontSize: fontSize
      }, iconStyle);
    }
  },
  methods: {
    itemClicked: function itemClicked(name) {
      this.$emit('wxcIconClicked', {
        name: name
      });
    }
  }
};

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  less: '\uE6A5',
  'more_unfold': '\uE6A6',
  back: '\uE697',
  more: '\uE6A7',
  add: '\uE6B9',
  subtract: '\uE6FE',
  close: '\uE69A',
  cry: '\uE69C',
  delete: '\uE69D',
  help: '\uE6A3',
  refresh: '\uE6AA',
  search: '\uE6AC',
  success: '\uE6B1',
  warning: '\uE6B6',
  wrong: '\uE6B7',
  clock: '\uE6BB',
  scanning: '\uE6EC',
  filter: '\uE6F1',
  map: '\uE715',
  play: '\uE719'
};

/***/ }),
/* 176 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('text', {
    staticClass: ["icon-font"],
    style: _vm.mergeStyle,
    on: {
      "click": function($event) {
        _vm.itemClicked(_vm.name)
      }
    }
  }, [_vm._v(_vm._s(_vm.Icon[_vm.name]))])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(178);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(179)
)

/* script */
__vue_exports__ = __webpack_require__(180)

/* template */
var __vue_template__ = __webpack_require__(185)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-lightbox\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-d2bf30f6"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 179 */
/***/ (function(module, exports) {

module.exports = {
  "indicator": {
    "position": "absolute",
    "itemColor": "rgba(255,195,0,0.5)",
    "itemSelectedColor": "#ffc300",
    "itemSize": "20",
    "height": "20",
    "bottom": "24"
  }
}

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _wxcMask = __webpack_require__(58);

var _wxcMask2 = _interopRequireDefault(_wxcMask);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  components: {
    WxcMask: _wxcMask2.default
  },
  props: {
    width: {
      type: [Number, String],
      default: 750
    },
    height: {
      type: [Number, String],
      default: 750
    },
    show: {
      type: Boolean,
      default: false
    },
    showIndicator: {
      type: Boolean,
      default: true
    },
    imageList: Array,
    indicatorColor: {
      type: Object,
      default: function _default() {
        return {
          'item-color': 'rgba(255, 195, 0, .5)',
          'item-selected-color': '#ffc300',
          'item-size': '20px'
        };
      }
    },
    index: {
      type: [Number, String],
      default: 0
    },
    interval: {
      type: [Number, String],
      default: 3000
    },
    opacity: {
      type: [Number, String],
      default: 0.6
    }
  },
  computed: {
    indicatorStyle: function indicatorStyle() {
      return _extends({
        width: this.width + 'px'
      }, this.indicatorColor);
    }
  },
  methods: {
    maskOverlayClick: function maskOverlayClick() {
      this.$emit('wxcLightboxOverlayClicked', {});
    }
  }
};

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(182)
)

/* script */
__vue_exports__ = __webpack_require__(183)

/* template */
var __vue_template__ = __webpack_require__(184)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-mask\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-1d536dbc"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 182 */
/***/ (function(module, exports) {

module.exports = {
  "container": {
    "position": "fixed",
    "width": "750",
    "zIndex": 99999
  },
  "wxc-mask": {
    "position": "fixed"
  },
  "mask-bottom": {
    "width": "100",
    "height": "100",
    "backgroundColor": "rgba(0,0,0,0)",
    "justifyContent": "center",
    "alignItems": "center"
  },
  "mask-close-icon": {
    "width": "64",
    "height": "64"
  }
}

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _wxcOverlay = __webpack_require__(14);

var _wxcOverlay2 = _interopRequireDefault(_wxcOverlay);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var animation = weex.requireModule('animation');
exports.default = {
  components: { WxcOverlay: _wxcOverlay2.default },
  props: {
    height: {
      type: [String, Number],
      default: 800
    },
    width: {
      type: [String, Number],
      default: 702
    },
    top: {
      type: Number,
      default: 0
    },
    show: {
      type: Boolean,
      default: false
    },
    showClose: {
      type: Boolean,
      default: false
    },
    duration: {
      type: [String, Number],
      default: 300
    },
    hasOverlay: {
      type: Boolean,
      default: true
    },
    hasAnimation: {
      type: Boolean,
      default: true
    },
    timingFunction: {
      type: Array,
      default: function _default() {
        return ['ease-in', 'ease-out'];
      }
    },
    overlayCfg: {
      type: Object,
      default: function _default() {
        return {
          hasAnimation: true,
          timingFunction: ['ease-in', 'ease-out'],
          canAutoClose: true,
          duration: 300,
          opacity: 0.6
        };
      }
    },
    borderRadius: {
      type: [String, Number],
      default: 0
    },
    overlayCanClose: {
      type: Boolean,
      default: true
    },
    maskBgColor: {
      type: String,
      default: '#ffffff'
    },
    opacity: {
      type: [Number, String],
      default: 0.6
    }
  },
  data: function data() {
    return {
      closeIcon: 'https://gw.alicdn.com/tfs/TB1qDJUpwMPMeJjy1XdXXasrXXa-64-64.png',
      maskTop: 264,
      opened: false
    };
  },
  computed: {
    mergeOverlayCfg: function mergeOverlayCfg() {
      return _extends({}, this.overlayCfg, {
        hasAnimation: this.hasAnimation
      });
    },
    maskStyle: function maskStyle() {
      var width = this.width,
          height = this.height,
          showClose = this.showClose,
          hasAnimation = this.hasAnimation,
          opened = this.opened,
          top = this.top;

      var newHeight = showClose ? height - 0 + 100 : height;
      var _weex$config$env = weex.config.env,
          deviceHeight = _weex$config$env.deviceHeight,
          deviceWidth = _weex$config$env.deviceWidth,
          platform = _weex$config$env.platform;

      var _deviceHeight = deviceHeight || 1334;
      var isWeb = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && platform.toLowerCase() === 'web';
      var navHeight = isWeb ? 0 : 130;
      var pageHeight = _deviceHeight / deviceWidth * 750 - navHeight;
      return {
        width: width + 'px',
        height: newHeight + 'px',
        left: (750 - width) / 2 + 'px',
        top: (top || (pageHeight - height) / 2) + 'px',
        opacity: hasAnimation && !opened ? 0 : 1
      };
    },
    contentStyle: function contentStyle() {
      return {
        width: this.width + 'px',
        backgroundColor: this.maskBgColor,
        height: this.height + 'px',
        borderRadius: this.borderRadius + 'px'
      };
    },
    shouldShow: function shouldShow() {
      var _this = this;

      var show = this.show,
          hasAnimation = this.hasAnimation;

      hasAnimation && setTimeout(function () {
        _this.appearMask(show);
      }, 50);
      return show;
    }
  },
  methods: {
    closeIconClicked: function closeIconClicked() {
      this.appearMask(false);
    },
    wxcOverlayBodyClicking: function wxcOverlayBodyClicking() {
      if (this.hasAnimation) {
        this.appearMask(false);
        this.$emit('wxcOverlayBodyClicking', {});
      }
    },
    wxcOverlayBodyClicked: function wxcOverlayBodyClicked() {
      if (!this.hasAnimation) {
        this.appearMask(false);
        this.$emit('wxcOverlayBodyClicked', {});
      }
    },
    needEmit: function needEmit() {
      var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      this.opened = bool;
      !bool && this.$emit('wxcMaskSetHidden', {});
    },
    appearMask: function appearMask(bool) {
      var _this2 = this;

      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.duration;
      var hasAnimation = this.hasAnimation,
          timingFunction = this.timingFunction;

      var maskEl = this.$refs['wxc-mask'];
      if (hasAnimation && maskEl) {
        animation.transition(maskEl, {
          styles: {
            opacity: bool ? 1 : 0
          },
          duration: duration,
          timingFunction: timingFunction[bool ? 0 : 1],
          delay: 0
        }, function () {
          _this2.needEmit(bool);
        });
      } else {
        this.needEmit(bool);
      }
    }
  }
};

/***/ }),
/* 184 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["container"]
  }, [(_vm.show) ? _c('wxc-overlay', _vm._b({
    attrs: {
      "show": _vm.show && _vm.hasOverlay,
      "canAutoClose": _vm.overlayCanClose,
      "opacity": _vm.opacity
    },
    on: {
      "wxcOverlayBodyClicking": _vm.wxcOverlayBodyClicking,
      "wxcOverlayBodyClicked": _vm.wxcOverlayBodyClicked
    }
  }, 'wxc-overlay', _vm.mergeOverlayCfg, false)) : _vm._e(), (_vm.show) ? _c('div', {
    ref: "wxc-mask",
    staticClass: ["wxc-mask"],
    style: _vm.maskStyle,
    attrs: {
      "hack": _vm.shouldShow
    }
  }, [_c('div', {
    style: _vm.contentStyle
  }, [_vm._t("default")], 2), (_vm.showClose) ? _c('div', {
    staticClass: ["mask-bottom"],
    style: {
      width: _vm.width + 'px'
    },
    on: {
      "click": _vm.closeIconClicked
    }
  }, [_c('image', {
    staticClass: ["mask-close-icon"],
    attrs: {
      "src": _vm.closeIcon,
      "ariaLabel": "关闭"
    }
  })]) : _vm._e()]) : _vm._e()], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 185 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('wxc-mask', {
    attrs: {
      "width": _vm.width,
      "height": _vm.height,
      "ariaHidden": "true",
      "maskBgColor": "transparent",
      "overlayOpacity": "0.8",
      "show": _vm.show,
      "opacity": _vm.opacity,
      "showClose": false
    },
    on: {
      "wxcMaskSetHidden": _vm.maskOverlayClick
    }
  }, [(_vm.show) ? _c('slider', {
    style: {
      height: _vm.height + 'px'
    },
    attrs: {
      "autoPlay": "false",
      "index": _vm.index,
      "interval": _vm.interval
    }
  }, [_vm._l((_vm.imageList), function(v, index) {
    return _c('div', {
      key: index,
      style: {
        height: _vm.height + 'px'
      }
    }, [_c('image', {
      style: {
        height: _vm.height + 'px',
        width: _vm.width + 'px'
      },
      attrs: {
        "resize": "cover",
        "src": v.src
      }
    })])
  }), (_vm.showIndicator) ? _c('indicator', {
    staticClass: ["indicator"],
    style: _vm.indicatorStyle
  }) : _vm._e()], 2) : _vm._e()])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(187);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(188)
)

/* script */
__vue_exports__ = __webpack_require__(189)

/* template */
var __vue_template__ = __webpack_require__(190)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-loading\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-12fb7c48"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 188 */
/***/ (function(module, exports) {

module.exports = {
  "loading-container": {
    "position": "relative"
  },
  "loading-need-mask": {
    "position": "absolute",
    "top": 0,
    "left": 0,
    "right": 0,
    "bottom": 0,
    "backgroundColor": "rgba(0,0,0,0.2)"
  },
  "wxc-loading": {
    "position": "fixed",
    "left": "287",
    "top": "500",
    "zIndex": 9999
  },
  "loading-box": {
    "alignItems": "center",
    "justifyContent": "center",
    "borderRadius": "20",
    "width": "175",
    "height": "175",
    "backgroundColor": "rgba(0,0,0,0.8)"
  },
  "trip-loading": {
    "backgroundColor": "rgba(0,0,0,0.2)"
  },
  "loading-trip-image": {
    "height": "75",
    "width": "75"
  },
  "loading-text": {
    "color": "#ffffff",
    "fontSize": "24",
    "lineHeight": "30",
    "height": "30",
    "marginTop": "8",
    "textOverflow": "ellipsis",
    "width": "140",
    "textAlign": "center"
  }
}

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _type = __webpack_require__(59);

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  props: {
    show: {
      type: Boolean,
      default: false
    },
    loadingText: {
      type: String,
      default: ''
    },
    loadingPic: {
      type: String,
      default: ''
    },
    type: {
      type: String,
      default: 'default'
    },
    interval: {
      type: [Number, String],
      default: 0
    },
    needMask: {
      type: Boolean,
      default: false
    },
    maskStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  data: function data() {
    return {
      showLoading: false,
      tid: 0
    };
  },
  watch: {
    show: function show() {
      this.setShow();
    }
  },
  computed: {
    loading: function loading() {
      var loading = {};
      switch (this.type) {
        case 'trip':
          loading = {
            url: _type.GIF,
            class: 'trip-loading'
          };
          break;
        default:
          loading = {
            url: _type.BLACK_GIF,
            class: 'default-loading'
          };
      }
      return loading;
    },
    topPosition: function topPosition() {
      return (_utils2.default.env.getPageHeight() - 200) / 2;
    }
  },
  created: function created() {
    this.setShow();
  },

  methods: {
    maskClicked: function maskClicked() {
      this.needMask && this.$emit('wxcLoadingMaskClicked', {});
    },
    setShow: function setShow() {
      var _this = this;

      var interval = this.interval,
          show = this.show,
          showLoading = this.showLoading;

      var stInterval = parseInt(interval);
      clearTimeout(this.tid);
      if (show) {
        if (showLoading) {
          return;
        }
        if (stInterval === 0) {
          this.showLoading = true;
        } else {
          this.tid = setTimeout(function () {
            _this.showLoading = true;
          }, stInterval);
        }
      } else {
        this.showLoading = false;
      }
    }
  }
};

/***/ }),
/* 190 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    class: ['loading-container', _vm.showLoading && _vm.needMask && 'loading-need-mask'],
    style: _vm.maskStyle,
    on: {
      "click": _vm.maskClicked
    }
  }, [(_vm.showLoading) ? _c('div', {
    staticClass: ["wxc-loading"],
    style: {
      top: _vm.topPosition + 'px'
    }
  }, [_c('div', {
    class: ['loading-box', _vm.loading.class],
    attrs: {
      "ariaHidden": true
    }
  }, [_c('image', {
    staticClass: ["loading-trip-image"],
    attrs: {
      "src": _vm.loadingPic || _vm.loading.url,
      "resize": "contain",
      "quality": "original"
    }
  }), (_vm.loadingText) ? _c('text', {
    staticClass: ["loading-text"]
  }, [_vm._v(_vm._s(_vm.loadingText))]) : _vm._e()])]) : _vm._e()])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(192);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(193)
)

/* script */
__vue_exports__ = __webpack_require__(194)

/* template */
var __vue_template__ = __webpack_require__(202)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-lottery-rain\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-2d73d968"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 193 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-lottery-rain": {
    "position": "absolute",
    "top": 0,
    "left": 0,
    "right": 0,
    "bottom": 0,
    "backgroundColor": "rgba(133,11,11,0.8)"
  }
}

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _rainItem = __webpack_require__(195);

var _rainItem2 = _interopRequireDefault(_rainItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  components: { RainItem: _rainItem2.default },
  props: {
    picList: Array,
    config: Object,
    wrapStyle: Object
  },
  methods: {
    wxcLotteryRainCaught: function wxcLotteryRainCaught(e) {
      this.$emit('wxcLotteryRainCaught', { rainId: e.rainId });
    },
    destroy: function destroy() {
      var picList = this.picList;

      var length = picList.length;
      for (var i = 0; i < length; i++) {
        this.$refs['rain-item-' + i][0].destroy();
      }
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(196)
)

/* script */
__vue_exports__ = __webpack_require__(197)

/* template */
var __vue_template__ = __webpack_require__(201)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-lottery-rain\\rain-item.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-a4fd1b7c"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 196 */
/***/ (function(module, exports) {

module.exports = {
  "rain-item": {
    "position": "absolute",
    "opacity": 0
  }
}

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _animate = __webpack_require__(198);

var Ani = _interopRequireWildcard(_animate);

var _config = __webpack_require__(199);

var CFG = _interopRequireWildcard(_config);

var _region = __webpack_require__(200);

var _region2 = _interopRequireDefault(_region);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  props: {
    src: String,
    rainId: [String, Number],
    config: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  computed: {
    // 合并用户配置和默认
    cfg: function cfg() {
      return _extends({}, CFG.DEFAULT, this.config);
    }
  },
  data: function data() {
    return {
      showItem: false,
      hiding: false,
      pos: {},
      showTimer: null,
      hideTimer: null,
      intervalTimer: null
    };
  },
  created: function created() {
    var _cfg = this.cfg,
        width = _cfg.width,
        height = _cfg.height;

    this.pos = _region2.default.get(width, height);
  },
  mounted: function mounted() {
    this.start();
  },

  methods: {
    start: function start() {
      var _this = this;

      var cfg = this.cfg;

      var random = Math.round(Math.random() * cfg.randomTime);
      var showTime = cfg.showTime + random;
      var intervalTime = Math.max(cfg.intervalTime, cfg.showAniTime + showTime + cfg.hideAniTime) + random;

      this.onShow = function () {
        _this.hideTimer = setTimeout(function () {
          _this.hide();
        }, showTime);
      };

      this.onHide = function () {
        _region2.default.remove(_this.pos);
        _this.pos = {};
        _this.showItem = false;
        _this.hiding = false;
        var _cfg2 = _this.cfg,
            width = _cfg2.width,
            height = _cfg2.height;

        _this.pos = _region2.default.get(width, height);
      };

      this.showTimer = setTimeout(function () {
        _this.show();
      }, random);

      this.intervalTimer = setInterval(function () {
        _this.show();
      }, intervalTime);
    },
    hide: function hide() {
      var cfg = this.cfg,
          rainId = this.rainId;

      this.hiding = true;
      clearTimeout(this.showTimer);
      clearTimeout(this.hideTimer);
      Ani.hidePig(this.$refs['rain-item-' + rainId], cfg.hideAniTime, this.onHide);
    },
    show: function show() {
      var cfg = this.cfg,
          rainId = this.rainId;

      this.showItem = true;
      Ani.showPig(this.$refs['rain-item-' + rainId], cfg.showAniTime, this.onShow);
    },
    caught: function caught() {
      var _this2 = this;

      var rainId = this.rainId,
          hiding = this.hiding;

      if (hiding) return;
      clearTimeout(this.showTimer);
      clearTimeout(this.hideTimer);
      Ani.shakePig(this.$refs['rain-item-' + rainId], function () {
        _this2.hide();
      });
      this.$emit('wxcLotteryRainCaught', { rainId: rainId });
    },
    destroy: function destroy() {
      _region2.default.remove(this.pos);
      clearTimeout(this.showTimer);
      clearTimeout(this.hideTimer);
      clearInterval(this.intervalTimer);
      this.showItem = false;
    }
  }
};

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.showPig = showPig;
exports.hidePig = hidePig;
exports.shakePig = shakePig;

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

var animation = weex.requireModule('animation');


var isIos = _utils2.default.env.isIOS();

function showPig(ref, duration, callback) {
  ref && animation.transition(ref, {
    styles: {
      transform: 'translate(0, -140px)',
      opacity: 1
    },
    duration: duration,
    timingFunction: 'ease-in'
  }, function () {
    callback && callback();
  });
}

function hidePig(ref, duration, callback) {
  ref && animation.transition(ref, {
    styles: {
      transform: 'translate(0, 0)',
      opacity: 0
    },
    duration: duration,
    timingFunction: 'ease-out'
  }, function () {
    callback && callback();
  });
}

function shakePig(ref, callback) {
  var duration = isIos ? 20 : 10;
  ref && animation.transition(ref, {
    styles: {
      transform: 'rotate(12deg) translate(0, -140px)'
    },
    duration: duration,
    timingFunction: 'ease-in'
  }, function () {
    animation.transition(ref, {
      styles: {
        transform: 'rotate(0) translate(0, -140px)'
      },
      duration: duration,
      timingFunction: 'ease-out'
    }, function () {
      animation.transition(ref, {
        styles: {
          transform: 'rotate(-12deg) translate(0, -140px)'
        },
        duration: duration,
        timingFunction: 'ease-in'
      }, function () {
        animation.transition(ref, {
          styles: {
            transform: 'rotate(0) translate(0, -140px)'
          },
          duration: duration,
          timingFunction: 'ease-out'
        }, function () {
          callback && callback();
        });
      });
    });
  });
}

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var DEFAULT = exports.DEFAULT = {
  intervalTime: 400,
  hideAniTime: 300,
  showAniTime: 300,
  showTime: 400,
  randomTime: 300,
  width: 241,
  height: 206
};

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Region = {
  regions: [],
  isCross: function isCross(region) {
    var regions = this.regions;


    region.right = region.left + region.width;
    region.bottom = region.top + region.height;

    for (var i = 0; i < regions.length; i++) {
      var curRegion = regions[i];
      // 两区域相交
      curRegion.right = curRegion.left + curRegion.width;
      curRegion.bottom = curRegion.top + curRegion.height;
      if (!(region.left > curRegion.right || region.right < curRegion.left || region.bottom < curRegion.top || region.top > curRegion.bottom)) {
        return true;
      }
    }
    return false;
  },
  get: function get(width, height) {
    if (!width || !height) {
      return;
    }
    var i = 1000;
    var viewWidth = 750;
    var viewHeight = _utils2.default.env.getPageHeight();
    var wrapWidth = viewWidth - width;
    var wrapHeight = viewHeight - height - 140;
    wrapHeight = wrapHeight < 0 ? 0 : wrapHeight;
    wrapWidth = wrapWidth < 0 ? 0 : wrapWidth;

    var region = {
      left: '-9999px',
      top: '-9999px',
      width: width + 'px',
      height: height + 'px'
    };
    while (i--) {
      region.left = Math.round(Math.random() * wrapWidth) + 'px';
      region.top = Math.round(Math.random() * wrapHeight + height) + 'px';
      if (!this.isCross(region)) {
        this.add(region);
        return region;
      }
    }
  },
  buildRandom: function buildRandom() {
    return new Date().getTime() + '_' + parseInt(Math.random() * 1000000);
  },
  add: function add(region) {
    var regions = this.regions;

    region.id = this.buildRandom();
    regions.push(region);
  },
  remove: function remove(region) {
    var regions = this.regions;

    if (!region) return;
    for (var i = 0; i < regions.length; i++) {
      if (region.id === regions[i].id) {
        regions.splice(i, 1);
      }
    }
  }
}; /*
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing,
   * software distributed under the License is distributed on an
   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
   * KIND, either express or implied.  See the License for the
   * specific language governing permissions and limitations
   * under the License.
   */

exports.default = Region;

/***/ }),
/* 201 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return (_vm.showItem && _vm.src) ? _c('image', {
    ref: ("rain-item-" + _vm.rainId),
    staticClass: ["rain-item"],
    style: _vm.pos,
    attrs: {
      "src": _vm.src
    },
    on: {
      "click": _vm.caught
    }
  }) : _vm._e()
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 202 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["wxc-lottery-rain"],
    style: _vm.wrapStyle
  }, _vm._l((_vm.picList), function(src, i) {
    return _c('rain-item', {
      key: "i",
      ref: ("rain-item-" + i),
      refInFor: true,
      attrs: {
        "src": src,
        "rainId": i
      },
      on: {
        "wxcLotteryRainCaught": _vm.wxcLotteryRainCaught
      }
    })
  }))
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(204)
)

/* script */
__vue_exports__ = __webpack_require__(205)

/* template */
var __vue_template__ = __webpack_require__(206)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-minibar\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-e026d130"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 204 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-minibar": {
    "width": "750",
    "height": "90",
    "flexDirection": "row",
    "justifyContent": "space-between",
    "alignItems": "center"
  },
  "left": {
    "width": "180",
    "paddingLeft": "32"
  },
  "middle-title": {
    "fontSize": "30",
    "color": "#ffffff",
    "height": "36",
    "lineHeight": "34"
  },
  "right": {
    "width": "180",
    "paddingRight": "32",
    "alignItems": "flex-end"
  },
  "left-button": {
    "width": "21",
    "height": "36"
  },
  "right-button": {
    "width": "32",
    "height": "32"
  },
  "icon-text": {
    "fontSize": "28",
    "color": "#ffffff"
  }
}

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var Navigator = weex.requireModule('navigator');
exports.default = {
  props: {
    backgroundColor: {
      type: String,
      default: '#FFC900'
    },
    leftButton: {
      type: String,
      default: 'https://gw.alicdn.com/tfs/TB1x18VpwMPMeJjy1XdXXasrXXa-21-36.png'
    },
    textColor: {
      type: String,
      default: '#3D3D3D'
    },
    rightButton: {
      type: String,
      default: ''
    },
    title: {
      type: String,
      default: '标题'
    },
    leftText: {
      type: String,
      default: ''
    },
    rightText: {
      type: String,
      default: ''
    },
    useDefaultReturn: {
      type: Boolean,
      default: true
    },
    show: {
      type: Boolean,
      default: true
    },
    barStyle: {
      type: Object
    }
  },
  computed: {
    newBarStyle: function newBarStyle() {
      var backgroundColor = this.backgroundColor,
          barStyle = this.barStyle;

      return _extends({
        backgroundColor: backgroundColor
      }, barStyle);
    }
  },
  methods: {
    leftButtonClicked: function leftButtonClicked() {
      if (this.useDefaultReturn) {
        Navigator.pop({}, function (e) {});
      }
      this.$emit('wxcMinibarLeftButtonClicked', {});
    },
    rightButtonClicked: function rightButtonClicked() {
      var hasRightContent = this.rightText || this.rightButton || this.$slots && this.$slots.right;
      hasRightContent && this.$emit('wxcMinibarRightButtonClicked', {});
    }
  }
};

/***/ }),
/* 206 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return (_vm.show) ? _c('div', {
    staticClass: ["wxc-minibar"],
    style: _vm.newBarStyle
  }, [_c('div', {
    staticClass: ["left"],
    attrs: {
      "ariaLabel": "返回",
      "accessible": true
    },
    on: {
      "click": _vm.leftButtonClicked
    }
  }, [_vm._t("left", [(_vm.leftButton && !_vm.leftText) ? _c('image', {
    staticClass: ["left-button"],
    attrs: {
      "src": _vm.leftButton
    }
  }) : _vm._e(), (_vm.leftText) ? _c('text', {
    staticClass: ["icon-text"],
    style: {
      color: _vm.textColor
    }
  }, [_vm._v(_vm._s(_vm.leftText))]) : _vm._e()])], 2), _vm._t("middle", [_c('text', {
    staticClass: ["middle-title"],
    style: {
      color: _vm.textColor
    }
  }, [_vm._v(_vm._s(_vm.title))])]), _c('div', {
    staticClass: ["right"],
    on: {
      "click": _vm.rightButtonClicked
    }
  }, [_vm._t("right", [(_vm.rightButton && !_vm.rightText) ? _c('image', {
    staticClass: ["right-button"],
    attrs: {
      "src": _vm.rightButton,
      "ariaHidden": true
    }
  }) : _vm._e(), (_vm.rightText) ? _c('text', {
    staticClass: ["icon-text"],
    style: {
      color: _vm.textColor
    }
  }, [_vm._v(_vm._s(_vm.rightText))]) : _vm._e()])], 2)], 2) : _vm._e()
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(208);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(209)
)

/* script */
__vue_exports__ = __webpack_require__(210)

/* template */
var __vue_template__ = __webpack_require__(212)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-noticebar\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-ea6a51f2"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 209 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-noticebar": {
    "width": "750",
    "paddingTop": "10",
    "paddingBottom": "10",
    "paddingLeft": "24",
    "backgroundColor": "#FFF7D6",
    "borderBottomWidth": "1",
    "borderTopWidth": "1",
    "borderColor": "#FFEEAE",
    "borderStyle": "solid",
    "flexDirection": "row",
    "justifyContent": "space-between",
    "alignItems": "center"
  },
  "noticebar-content": {
    "color": "#EE9900",
    "fontSize": "26",
    "lineHeight": "36",
    "width": "592",
    "textOverflow": "ellipsis"
  },
  "more-click-content": {
    "width": "64",
    "alignItems": "center",
    "justifyContent": "center"
  },
  "mode-ICON": {
    "width": "32",
    "height": "32"
  },
  "type-ICON": {
    "width": "32",
    "height": "32"
  }
}

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _type = __webpack_require__(211);

var _type2 = _interopRequireDefault(_type);

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  props: {
    notice: {
      type: String,
      default: ''
    },
    noticeUrl: {
      type: String,
      default: ''
    },
    mode: {
      type: String,
      default: ''
    },
    lines: {
      type: [Number, String],
      default: 1
    },
    type: {
      type: String,
      default: ''
    },
    spm: {
      type: String,
      default: ''
    }
  },
  computed: {
    contentWidth: function contentWidth() {
      return this.mode ? 605 : 683;
    },
    modeIcon: function modeIcon() {
      var modeIcon = void 0;
      switch (this.mode) {
        case 'link':
          modeIcon = _type2.default.linkIcon;
          break;
        case 'closable':
          modeIcon = _type2.default.closeIcon;
          break;
        default:
          modeIcon = '';
      }
      return modeIcon;
    },
    typeIcon: function typeIcon() {
      var typeIcon = void 0;
      switch (this.type) {
        case 'success':
          typeIcon = _type2.default.successIcon;
          break;
        case 'error':
          typeIcon = _type2.default.errorIcon;
          break;
        case 'info':
          typeIcon = _type2.default.infoIcon;
          break;
        case 'question':
          typeIcon = _type2.default.questionIcon;
          break;
        case 'warn':
          typeIcon = _type2.default.warnIcon;
          break;
        case 'time':
          typeIcon = _type2.default.timeIcon;
          break;
        case 'redbag':
          typeIcon = _type2.default.redbag;
          break;
        default:
          typeIcon = '';
      }
      return typeIcon;
    }
  },
  data: function data() {
    return {
      show: true
    };
  },
  methods: {
    noticeBarClicked: function noticeBarClicked() {
      var mode = this.mode,
          noticeUrl = this.noticeUrl,
          spm = this.spm;

      if (mode === 'link' && noticeUrl) {
        var ttid = weex.config.env.ttid;

        _utils2.default.goToH5Page(noticeUrl, spm, ttid, true);
        this.$emit('wxcNoticebarLinkClicked', { url: noticeUrl });
      }
    },
    noticeIconClicked: function noticeIconClicked() {
      var mode = this.mode;

      if (mode === 'closable') {
        this.show = false;
        this.$emit('wxcNoticebarCloseClicked', {});
      } else {
        this.noticeBarClicked();
      }
    }
  }
};

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Created by Tw93 on 2016/10/29.
 */

exports.default = {
  closeIcon: 'https://gw.alicdn.com/tfs/TB1THvhpwMPMeJjy1XcXXXpppXa-32-32.png',
  linkIcon: 'https://gw.alicdn.com/tfs/TB1utlZpwMPMeJjy1XdXXasrXXa-32-32.png',
  infoIcon: 'https://gw.alicdn.com/tfs/TB1xdlZpwMPMeJjy1XdXXasrXXa-32-32.png',
  warnIcon: 'https://gw.alicdn.com/tfs/TB1TCvhpwMPMeJjy1XcXXXpppXa-32-32.png',
  successIcon: 'https://gw.alicdn.com/tfs/TB12Em8pwMPMeJjy1XbXXcwxVXa-32-32.png',
  errorIcon: 'https://gw.alicdn.com/tfs/TB1UCvhpwMPMeJjy1XcXXXpppXa-32-32.png',
  questionIcon: 'https://gw.alicdn.com/tfs/TB1vJlZpwMPMeJjy1XdXXasrXXa-32-32.png',
  timeIcon: 'https://gw.alicdn.com/tfs/TB1eSzhpwMPMeJjy1XcXXXpppXa-30-30.png',
  redbag: 'https://gw.alicdn.com/tfs/TB1dCzhpwMPMeJjy1XcXXXpppXa-32-32.png'
};

/***/ }),
/* 212 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return (_vm.show) ? _c('div', {
    staticClass: ["wxc-noticebar"],
    attrs: {
      "accessible": true,
      "ariaLabel": _vm.notice
    },
    on: {
      "click": _vm.noticeBarClicked
    }
  }, [(_vm.typeIcon) ? _c('image', {
    staticClass: ["type-ICON"],
    attrs: {
      "src": _vm.typeIcon
    }
  }) : _vm._e(), _c('text', {
    staticClass: ["noticebar-content"],
    style: {
      width: _vm.contentWidth + 'px',
      lines: _vm.lines
    }
  }, [_vm._v(_vm._s(_vm.notice))]), (_vm.modeIcon) ? _c('div', {
    staticClass: ["more-click-content"],
    attrs: {
      "mode": _vm.mode
    },
    on: {
      "click": _vm.noticeIconClicked
    }
  }, [_c('image', {
    staticClass: ["mode-ICON"],
    attrs: {
      "src": _vm.modeIcon
    }
  })]) : _vm._e()]) : _vm._e()
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(214);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(215)
)

/* script */
__vue_exports__ = __webpack_require__(216)

/* template */
var __vue_template__ = __webpack_require__(218)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-page-calendar\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-be1e1d70"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 215 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-page-calendar": {
    "position": "fixed",
    "width": "750",
    "color": "#333333",
    "backgroundColor": "#ffffff"
  },
  "flex-item": {
    "flex": 1,
    "textAlign": "center"
  },
  "calendar-weekday": {
    "height": "60",
    "backgroundColor": "#ffffff",
    "borderBottomWidth": "1",
    "borderTopWidth": "1",
    "borderColor": "#e2e2e2",
    "flexDirection": "row",
    "justifyContent": "space-around",
    "alignItems": "center"
  },
  "weekday-text": {
    "color": "#000000",
    "flex": 1,
    "fontSize": "24",
    "textAlign": "center"
  },
  "calendar-list": {
    "flex": 1
  },
  "month-text": {
    "fontSize": "32",
    "height": "60",
    "lineHeight": "60",
    "width": "750",
    "textAlign": "center",
    "alignItems": "center",
    "backgroundColor": "#f2f3f4"
  },
  "calendar-row": {
    "height": "140",
    "flexDirection": "row",
    "backgroundColor": "#ffffff",
    "borderBottomWidth": "1",
    "borderColor": "#f2f3f4",
    "alignItems": "center",
    "justifyContent": "space-between"
  },
  "row-item": {
    "flex": 1,
    "height": "140",
    "paddingTop": "10",
    "paddingBottom": "10",
    "justifyContent": "center",
    "alignItems": "center"
  },
  "iphone-x": {
    "height": "68"
  },
  "calendar-note": {
    "height": "36",
    "lineHeight": "36",
    "fontSize": "24",
    "color": "#000000",
    "textAlign": "center"
  },
  "calendar-day": {
    "height": "48",
    "lineHeight": "48",
    "fontSize": "36",
    "color": "#000000",
    "textAlign": "center"
  },
  "calendar-ext": {
    "height": "36",
    "lineHeight": "36",
    "color": "#999999",
    "textAlign": "center",
    "fontSize": "24",
    "textOverflow": "ellipsis"
  },
  "calendar-holiday": {
    "color": "#FF5000"
  },
  "calendar-rest": {
    "color": "#FF5000"
  },
  "item-row-selected": {
    "color": "#ffffff",
    "backgroundColor": "#FFC900",
    "textAlign": "center"
  },
  "item-text-selected": {
    "color": "#3d3d3d",
    "textAlign": "center"
  },
  "calendar-disabled": {
    "color": "#CCCCCC"
  },
  "cell-disabled": {
    "backgroundColor": "#FBFBFB"
  },
  "calendar-day-include": {
    "backgroundColor": "#FFF7D6"
  }
}

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _format = __webpack_require__(217);

var Format = _interopRequireWildcard(_format);

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

var _wxcMinibar = __webpack_require__(60);

var _wxcMinibar2 = _interopRequireDefault(_wxcMinibar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var isWeb = _utils2.default.env.isWeb();

var dom = weex.requireModule('dom');

exports.default = {
  components: { WxcMinibar: _wxcMinibar2.default },
  props: {
    selectedDate: Array,
    animationType: {
      type: String,
      default: 'push'
    },
    dateRange: {
      type: Array,
      required: true,
      default: function _default() {
        return [];
      }
    },
    minibarCfg: {
      type: Object,
      default: function _default() {
        return {
          'title': '选择日期',
          'background-color': '#FFC900',
          'text-color': '#3D3D3D'
        };
      }
    },
    showHeader: {
      type: Boolean,
      default: false
    },
    selectedNote: {
      type: Array,
      default: function _default() {
        return ['开始', '到达', '往返'];
      }
    },
    isRange: {
      type: Boolean,
      default: false
    },
    needDestroy: {
      type: Boolean,
      default: false
    },
    descList: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    selectedCellStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    selectedTextStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  data: function data() {
    return {
      isShow: false,
      reSelect: true,
      today: Format.getToDay(),
      departDate: '',
      arriveDate: ''
    };
  },
  computed: {
    calendarExtendStyle: function calendarExtendStyle() {
      return _utils2.default.uiStyle.pageTransitionAnimationStyle(this.animationType);
    },
    monthsArray: function monthsArray() {
      var range = this.dateRange,
          today = this.today,
          departDate = this.departDate,
          arriveDate = this.arriveDate,
          selectedNote = this.selectedNote,
          descList = this.descList;

      var param = { range: range, today: today, departDate: departDate, arriveDate: arriveDate, selectedNote: selectedNote, descList: descList };
      return Format.generateDateCell(param);
    }
  },
  created: function created() {
    this.isIPhoneX = _utils2.default.env.isIPhoneX();
    this.showTitle = isWeb || this.showHeader;
    this.detectShow();
  },
  mounted: function mounted() {
    var _this = this;

    var needDestroy = this.needDestroy;

    var hold = isWeb ? 700 : 100;
    !needDestroy && setTimeout(function () {
      _this.isShow = true;
      _this.scrollToDate();
    }, hold);
  },

  watch: {
    needDestroy: function needDestroy(newVal, preVal) {
      var _this2 = this;

      if (!newVal && newVal !== preVal) {
        setTimeout(function () {
          _this2.isShow = true;
        }, 200);
      }
    }
  },
  methods: {
    minibarLeftButtonClick: function minibarLeftButtonClick() {
      var _this3 = this;

      setTimeout(function () {
        _this3.hide();
        _this3.$emit('wxcPageCalendarBackClicked', {});
      }, 100);
    },
    onClickDate: function onClickDate(datConfig) {
      var self = this;
      if (datConfig.disabled || datConfig.isEmpty) return;

      if (self.reSelect) {
        self.departDate = '';
        self.arriveDate = '';
        self.reSelect = false;
      }

      if (self.isRange) {
        if (self.departDate && Date.parse(self.departDate) <= Date.parse(datConfig.date)) {
          self.arriveDate = datConfig.date;
        } else {
          self.departDate = datConfig.date;
        }
        if (self.departDate && self.arriveDate) {
          self.dispatchDateChange([self.departDate, self.arriveDate]);
        }
      } else {
        self.departDate = datConfig.date;
        self.dispatchDateChange([self.departDate]);
      }
    },
    scrollToDate: function scrollToDate() {
      var _this4 = this;

      setTimeout(function () {
        if (_this4.departDate) {
          var el = _this4.$refs.departDate[0];
          el && dom.getComponentRect && dom.getComponentRect(el, function (e) {
            if (e && e.result) {
              var bottom = e.size.bottom;
              var env = weex.config.env;
              // 误差

              var height = env.deviceHeight / env.deviceWidth * 750 - 50;
              if (bottom > height || bottom === 0) {
                dom.scrollToElement(el, { offset: -146, animated: false });
              }
            }
          });
        }
      }, 10);
    },
    dispatchDateChange: function dispatchDateChange(dateArr) {
      var _this5 = this;

      var duration = isWeb ? 400 : 600;
      setTimeout(function () {
        _this5.hide();
      }, duration);
      this.$emit('wxcPageCalendarDateSelected', {
        date: dateArr
      });
    },
    detectShow: function detectShow() {
      if (this.isRange && this.selectedDate.length >= 2) {
        this.departDate = this.selectedDate[0];
        this.arriveDate = this.selectedDate[1];
      } else if (this.selectedDate.length >= 1) {
        this.departDate = this.selectedDate[0];
        this.arriveDate = '';
      }
    },
    _animate: function _animate(status) {
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var ref = this.$refs.pageCalendar;
      if (this.animationType === 'push') {
        _utils2.default.animation.pageTransitionAnimation(ref, 'translateX(' + (status ? -750 : 750) + 'px)', status, callback);
      } else if (this.animationType === 'model') {
        _utils2.default.animation.pageTransitionAnimation(ref, 'translateY(' + (status ? -_utils2.default.env.getScreenHeight() : _utils2.default.env.getScreenHeight()) + 'px)', status, callback);
      }
    },
    show: function show() {
      var needDestroy = this.needDestroy;

      needDestroy && (this.isShow = true);
      this.reSelect = true;
      this.detectShow();
      this._animate(true);
      needDestroy && this.scrollToDate();
    },
    hide: function hide() {
      this.needDestroy && (this.isShow = false);
      this.reSelect = false;
      this._animate(false);
      this.$emit('wxcPageCalendarHide', {});
    }
  }
};

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._getTraditionalHoliday = _getTraditionalHoliday;
exports._isDate = _isDate;
exports._checkHash = _checkHash;
exports.getTime = getTime;
exports._isInRange = _isInRange;
exports._isInSelectRange = _isInSelectRange;
exports._fixNum = _fixNum;
exports._isWeekend = _isWeekend;
exports._isToday = _isToday;
exports._getMonthDays = _getMonthDays;
exports._getPadding = _getPadding;
exports._unique = _unique;
exports.getToDay = getToDay;
exports.getWeekRows = getWeekRows;
exports.generateDateCell = generateDateCell;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

// 国际节日
var GLOBAL_HOLIDAY = exports.GLOBAL_HOLIDAY = {
  '01-01': '元旦',
  '02-14': '情人',
  '05-01': '劳动',
  '06-01': '儿童',
  '10-01': '国庆',
  '12-25': '圣诞'
};

// 传统节日
var TRADITIONAL_HOLIDAY = {
  '除夕': ['2015-02-18', '2016-02-07', '2017-01-27', '2018-02-15', '2019-02-04', '2020-01-24'],
  '春节': ['2015-02-19', '2016-02-08', '2017-01-28', '2018-02-16', '2019-02-05', '2020-01-25'],
  '元宵': ['2015-03-05', '2016-02-22', '2017-02-11', '2018-03-02', '2019-02-19', '2020-02-08'],
  '清明': ['2015-04-05', '2016-04-04', '2017-04-04', '2018-04-05', '2019-04-05', '2020-04-04'],
  '端午': ['2015-06-20', '2016-06-09', '2017-05-30', '2018-06-18', '2019-06-07', '2020-06-25'],
  '中秋': ['2015-09-27', '2016-09-15', '2017-10-04', '2018-09-24', '2019-09-13', '2020-10-01'],
  '重阳': ['2015-10-21', '2016-10-09', '2017-10-28', '2018-10-17', '2019-10-07', '2020-10-25']
};

// 放假日
var REST_DAYS = ['2017-10-01', '2017-10-02', '2017-10-03', '2017-10-04', '2017-10-05', '2017-10-06', '2017-10-07', '2017-10-08'];

// 工作日
var WORK_DAYS = ['2017-09-30'];

function _getTraditionalHoliday() {
  var HOLIDAY_TEMP = {};

  var keys = Object.keys(TRADITIONAL_HOLIDAY);
  keys.forEach(function (k) {
    var arr = TRADITIONAL_HOLIDAY[k];
    arr.forEach(function (i) {
      HOLIDAY_TEMP[i] = k;
    });
  });
  return HOLIDAY_TEMP;
}

function _isDate(obj) {
  var type = obj === null ? String(obj) : {}.toString.call(obj) || 'object';
  return type === '[object date]';
}

/**
 * 检测Hash
 *
 * @method _checkHash
 * @private
 */
function _checkHash(url, hash) {
  return url && url.match(/#/) && url.replace(/^.*#/, '') === hash;
}

/**
 * 获取当前日期的毫秒数
 * @method getTime
 * @param {String} date
 * @return {Number}
 */
function getTime(date) {
  if (_isDate(date)) {
    return new Date(date).getTime();
  } else {
    try {
      return new Date(date.replace(/-/g, '/')).getTime();
    } catch (e) {
      return 0;
    }
  }
}

function _isInRange(range, date) {
  var start = getTime(range[0]);
  var end = getTime(range[1]);
  var d = getTime(date);
  return start <= d && end >= d;
}

function _isInSelectRange(range, date) {
  var start = getTime(range[0]);
  var end = getTime(range[1]);
  var d = getTime(date);
  return start < d && end > d;
}

function _fixNum(num) {
  return (num < 10 ? '0' : '') + num;
}

/**
 * 是否是周末
 * @method isWeekend
 * @param {String} date
 * @return {Boolean}
 */
function _isWeekend(date) {
  var day = new Date(date.replace(/-/g, '/')).getDay();
  return day === 0 || day === 6;
}

/**
 * 是否是今天
 * @method isToday
 * @param {String} date
 * @return {Boolean}
 */
function _isToday(today, date) {
  return getTime(today) === getTime(date);
}

/**
 * 检查是否是闰年
 * @method _checkLeapYear
 * @param {Number} y 年份
 * @param {Date} t today
 * @protected
 */
function _getMonthDays(y, t) {
  var MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var year = y || t.getFullYear();
  var isLeapYear = false;

  if (year % 100) {
    isLeapYear = !(year % 4);
  } else {
    isLeapYear = !(year % 400);
  }

  if (isLeapYear) {
    MONTH_DAYS[1] = 29;
  } else {
    MONTH_DAYS[1] = 28;
  }
  return MONTH_DAYS;
}

/**
 * 当月1号前面有多少空格
 * @method _getPadding
 * @protected
 */
function _getPadding(year, month) {
  var date = new Date(year + '/' + month + '/1');
  return date.getDay();
}

function _unique(array) {
  return Array.prototype.filter.call(array, function (item, index) {
    return array.indexOf(item) === index;
  });
}

function getToDay() {
  return new Date().getFullYear() + '-' + _fixNum(new Date().getMonth() + 1) + '-' + _fixNum(new Date().getDate());
}

function getWeekRows(y, m, today, dateRange, departDate, arriveDate, selectedNote, descList) {
  var monthDays = _getMonthDays(y, today);
  var padding = _getPadding(y, m, 7);
  var num = monthDays[m - 1] + padding;
  var rows = Math.ceil(num / 7);
  var remain = num % 7;
  var rowsData = [];

  for (var i = 1; i <= rows; i++) {
    var cells = [];

    for (var j = 1; j <= 7; j++) {
      var cell = {};
      // 前后空格
      if (i === 1 && j <= padding || remain && i === rows && j > remain) {
        cell.isEmpty = true;
      } else {
        (function () {
          var d = (i - 1) * 7 + j - padding;
          var date = y + '-' + _fixNum(m) + '-' + _fixNum(d);
          var cls = [];
          var ref = '';
          var cellClass = [];
          var isInRange = _isInRange(dateRange, date);
          var disabled = false;
          var global = _fixNum(m) + '-' + _fixNum(d);
          var note = '';
          var ext = '';
          var isSelected = false;

          if (descList && descList.length > 0) {
            var nowDesc = descList.filter(function (item) {
              return item.date === date;
            });
            if (nowDesc && nowDesc.length > 0) {
              ext = nowDesc[0].value;
              if (nowDesc[0].emphasize) {
                cls.push('calendar-holiday');
              }
            }
          }

          // 国际节日
          if (GLOBAL_HOLIDAY[global]) {
            note = GLOBAL_HOLIDAY[global];
            cls.push('calendar-holiday');
          }

          var tHoliday = _getTraditionalHoliday()[date];

          // 传统节日
          if (tHoliday) {
            note = tHoliday;
            cls.push('calendar-holiday');
          }
          // 放假日
          if (REST_DAYS.indexOf(date) > -1) {
            cls.push('calendar-holiday');
          }

          // 工作日
          if (WORK_DAYS.indexOf(date) > -1) {
            cls.push('calendar-work');
          }

          // 周末
          if (_isWeekend(date)) {
            cls.push('calendar-holiday');
          }

          // 今天
          if (_isToday(today, date)) {
            cls.push('calendar-today');
            note = '今天';
          }

          // 不在日期范围内
          if (!isInRange) {
            disabled = true;
          }

          if (disabled) {
            cls = [];
            cls.push('calendar-disabled');
            cellClass.push('cell-disabled');
          }

          if (!ext && disabled && isInRange) {
            ext = '不可选';
          }

          if (departDate === date || arriveDate === date) {
            note = departDate === date ? selectedNote[0] : selectedNote[1];
            ref = departDate === date ? 'departDate' : 'arriveDate';
            if (departDate === arriveDate && selectedNote.length >= 3) {
              note = selectedNote[2];
            }
            isSelected = true;
            cls.push('item-text-selected');
            cellClass.push('item-row-selected');
          }

          if (departDate && arriveDate && _isInSelectRange([departDate, arriveDate], date)) {
            cellClass.push('calendar-day-include');
          }

          cell = {
            isSelected: isSelected,
            isEmpty: false,
            ref: ref,
            cls: _unique(cls).join(' '),
            cellClass: _unique(cellClass).join(' '),
            note: note,
            date: date,
            ext: ext,
            disabled: disabled,
            text: d
          };
        })();
      }
      cells.push(cell);
    }

    rowsData.push(cells);
  }

  return rowsData;
}

function generateDateCell(_ref) {
  var range = _ref.range,
      today = _ref.today,
      departDate = _ref.departDate,
      arriveDate = _ref.arriveDate,
      selectedNote = _ref.selectedNote,
      descList = _ref.descList;

  var start = new Date(range[0].replace(/-/g, '/'));
  var end = new Date(range[1].replace(/-/g, '/'));
  var startYear = start.getFullYear();
  var startMonth = start.getMonth() + 1;
  var endYear = end.getFullYear();
  var endMonth = end.getMonth() + 1;

  var l = (endYear - startYear) * 12 + endMonth - startMonth + 1;
  var y = startYear;
  var n = startMonth;
  var months = [];

  for (var i = 0; i < l; i++) {
    if (n > 12) {
      n = 1;
      y++;
    }
    months.push.apply(months, [{ title: y + '-' + _fixNum(n) }].concat(_toConsumableArray(getWeekRows(y, n, today, range, departDate, arriveDate, selectedNote, descList))));
    n++;
  }
  return months;
}

/***/ }),
/* 218 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    ref: "pageCalendar",
    staticClass: ["wxc-page-calendar"],
    style: _vm.calendarExtendStyle
  }, [_c('wxc-minibar', _vm._b({
    attrs: {
      "show": _vm.showTitle,
      "useDefaultReturn": false
    },
    on: {
      "wxcMinibarLeftButtonClicked": _vm.minibarLeftButtonClick
    }
  }, 'wxc-minibar', _vm.minibarCfg, false)), (_vm.isShow) ? _c('div', {
    staticClass: ["calendar-weekday"]
  }, _vm._l((['日', '一', '二', '三', '四', '五', '六']), function(week, k) {
    return _c('text', {
      key: k,
      staticClass: ["flex-item", "weekday-text"],
      attrs: {
        "ariaLabel": ("周" + week)
      }
    }, [_vm._v(_vm._s(week))])
  })) : _vm._e(), (_vm.isShow) ? _c('list', {
    staticClass: ["calendar-list"]
  }, [_vm._l((_vm.monthsArray), function(month, index) {
    return _c('cell', {
      key: index,
      class: [!month.title && 'calendar-row'],
      appendAsTree: true,
      attrs: {
        "append": "tree"
      }
    }, [(month.title) ? _c('text', {
      staticClass: ["month-text"]
    }, [_vm._v(_vm._s(month.title))]) : _vm._l((month), function(cell, rowIndex) {
      return _c('div', {
        key: (index + "-" + rowIndex),
        ref: cell.ref,
        refInFor: true,
        class: ['row-item', cell.cellClass],
        style: cell.isSelected ? _vm.selectedCellStyle : {},
        attrs: {
          "accessible": true,
          "ariaLabel": ((cell.text?cell.text:'') + "," + (cell.note?cell.note:'') + "," + (cell.ext?cell.ext:''))
        },
        on: {
          "click": function($event) {
            _vm.onClickDate(cell)
          }
        }
      }, [_c('text', {
        class: ['calendar-note', cell.cls],
        style: cell.isSelected ? _vm.selectedTextStyle : {}
      }, [_vm._v(_vm._s(cell.note))]), _c('text', {
        class: ['calendar-day', cell.cls],
        style: cell.isSelected ? _vm.selectedTextStyle : {}
      }, [_vm._v(_vm._s(cell.text))]), _c('text', {
        class: ['calendar-ext', cell.cls],
        style: cell.isSelected ? _vm.selectedTextStyle : {}
      }, [_vm._v(_vm._s(cell.ext))])])
    })], 2)
  }), (_vm.isIPhoneX) ? _c('cell', {
    staticClass: ["iphone-x"],
    appendAsTree: true,
    attrs: {
      "append": "tree"
    }
  }) : _vm._e()], 2) : _vm._e()], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(220);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* script */
__vue_exports__ = __webpack_require__(221)

/* template */
var __vue_template__ = __webpack_require__(222)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-pan-item\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _indexWeex = __webpack_require__(4);

var _indexWeex2 = _interopRequireDefault(_indexWeex);

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

var _bindEnv = __webpack_require__(5);

var _bindEnv2 = _interopRequireDefault(_bindEnv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  props: {
    url: {
      type: String,
      default: ''
    },
    needSlider: {
      type: Boolean,
      default: true
    }
  },
  data: function data() {
    return {
      isPanning: false,
      appearMap: [],
      supportAndroid: _bindEnv2.default.supportsEBForAndroid()
    };
  },
  mounted: function mounted() {
    var _this = this;

    setTimeout(function () {
      if (_this.supportAndroid && _this.needSlider) {
        var element = _this.$refs['wxc-pan-item'];
        _indexWeex2.default.prepare && _indexWeex2.default.prepare({
          anchor: element.ref,
          eventType: 'pan'
        });
      }
    }, 300);
  },

  methods: {
    itemClicked: function itemClicked() {
      if (this.isPanning) {
        return;
      }
      this.url && _utils2.default.goToH5Page(this.url, true);
      this.$emit('wxcPanItemClicked', { extId: this.extId });
    },
    dispatchPan: function dispatchPan(e) {
      var _this2 = this;

      if (this.supportAndroid && this.needSlider) {
        if (e.state === 'start') {
          this.isPanning = true;
          var element = this.$refs['wxc-pan-item'];
          element && this.$emit('wxcPanItemPan', { element: element, extId: this.extId });
        } else if (e.state === 'end') {
          setTimeout(function () {
            _this2.isPanning = false;
          }, 50);
        }
      }
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 222 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [(_vm.supportAndroid) ? _c('div', {
    ref: "wxc-pan-item",
    on: {
      "horizontalpan": _vm.dispatchPan,
      "appear": _vm.onItemAppear,
      "disappear": _vm.onItemDisAppear,
      "click": _vm.itemClicked
    }
  }, [_vm._t("default")], 2) : _c('div', {
    ref: "wxc-pan-item",
    on: {
      "click": _vm.itemClicked
    }
  }, [_vm._t("default")], 2)])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(224);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* script */
__vue_exports__ = __webpack_require__(225)

/* template */
var __vue_template__ = __webpack_require__(226)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-part-loading\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _type = __webpack_require__(59);

exports.default = {
  props: {
    show: {
      type: Boolean,
      default: false
    },
    width: {
      type: [Number, String],
      default: 36
    },
    height: {
      type: [Number, String],
      default: 36
    }
  },
  data: function data() {
    return {
      PART: _type.PART
    };
  },
  computed: {
    loadingStyle: function loadingStyle() {
      var height = this.height,
          width = this.width;

      return {
        height: height + 'px',
        width: width + 'px'
      };
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 226 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [(_vm.show) ? _c('image', {
    style: _vm.loadingStyle,
    attrs: {
      "src": _vm.PART,
      "resize": "contain",
      "quality": "original"
    }
  }) : _vm._e()])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(228);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(229)
)

/* script */
__vue_exports__ = __webpack_require__(230)

/* template */
var __vue_template__ = __webpack_require__(231)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-popover\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-e97beb1e"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 229 */
/***/ (function(module, exports) {

module.exports = {
  "wrapper": {
    "zIndex": 999
  },
  "g-cover": {
    "position": "fixed",
    "top": 0,
    "right": 0,
    "left": 0,
    "bottom": 0,
    "backgroundColor": "rgba(0,0,0,0.4)",
    "zIndex": 1
  },
  "g-popover": {
    "position": "fixed",
    "paddingTop": "15",
    "paddingRight": "15",
    "paddingBottom": "15",
    "paddingLeft": "15",
    "zIndex": 10
  },
  "u-popover-arrow": {
    "position": "absolute",
    "borderRadius": "4",
    "width": "30",
    "height": "30",
    "backgroundColor": "#ffffff"
  },
  "u-popover-inner": {
    "borderRadius": "10",
    "backgroundColor": "#ffffff"
  },
  "i-btn": {
    "flexDirection": "row",
    "justifyContent": "space-between",
    "alignItems": "center",
    "marginLeft": "20",
    "marginRight": "20",
    "paddingLeft": "20",
    "paddingRight": "20",
    "borderBottomWidth": "1",
    "borderBottomColor": "#dddddd"
  },
  "i-btn-noborder": {
    "borderBottomColor": "#ffffff"
  },
  "btn-icon": {
    "width": "32",
    "height": "32",
    "marginRight": "16"
  },
  "btn-text": {
    "flex": 1,
    "height": "80",
    "fontSize": "30",
    "lineHeight": "80"
  },
  "text-align-center": {
    "textAlign": "center"
  }
}

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var animation = weex.requireModule('animation');
exports.default = {
  props: {
    buttons: {
      type: Array,
      default: []
    },
    position: {
      type: Object,
      default: function _default() {
        return {
          x: 0,
          y: 0
        };
      }
    },
    arrowPosition: {
      type: Object,
      default: function _default() {
        return {
          pos: 'top',
          x: 0,
          y: 0
        };
      }
    },
    coverColor: {
      type: String,
      default: 'rgba(0, 0, 0, 0.4)'
    },
    hasAnimation: {
      type: Boolean,
      default: true
    },
    textStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  data: function data() {
    return {
      show: false,
      showIn: false
    };
  },
  computed: {
    coverStyle: function coverStyle() {
      return this.coverColor ? { backgroundColor: this.coverColor, opacity: this.hasAnimation || !this.showIn ? '0' : '1' } : '';
    },
    transformOrigin: function transformOrigin() {
      var _arrowPosition = this.arrowPosition,
          _arrowPosition$x = _arrowPosition.x,
          x = _arrowPosition$x === undefined ? 0 : _arrowPosition$x,
          _arrowPosition$y = _arrowPosition.y,
          y = _arrowPosition$y === undefined ? 0 : _arrowPosition$y,
          _arrowPosition$pos = _arrowPosition.pos,
          pos = _arrowPosition$pos === undefined ? 'top' : _arrowPosition$pos;

      var _origins = [];
      switch (pos) {
        case 'top':
        case 'bottom':
          _origins = [x < 0 ? 'right' : 'left', pos];
          break;
        case 'left':
        case 'right':
          _origins = [pos, y < 0 ? 'bottom' : 'top'];
          break;
      }
      return _origins.join(' ');
    },
    contentTransform: function contentTransform() {
      var _arrowPosition$pos2 = this.arrowPosition.pos,
          pos = _arrowPosition$pos2 === undefined ? 'top' : _arrowPosition$pos2;
      var _arrowPosition2 = this.arrowPosition,
          _arrowPosition2$x = _arrowPosition2.x,
          x = _arrowPosition2$x === undefined ? 0 : _arrowPosition2$x,
          _arrowPosition2$y = _arrowPosition2.y,
          y = _arrowPosition2$y === undefined ? 0 : _arrowPosition2$y;

      var _translates = ['scale(0)'];
      if (x >= 0 && x < 22) {
        x = 22;
      } else if (x < 0 && x > -22) {
        x = -22;
      }
      if (y >= 0 && y < 22) {
        y = 22;
      } else if (y < 0 && y > -22) {
        y = -22;
      }
      switch (pos) {
        case 'top':
        case 'bottom':
          _translates[1] = 'translateX(' + (x < 0 ? x - 15 : x + 15) + 'px)';
          break;
        case 'left':
        case 'right':
          _translates[1] = 'translateY(' + (y < 0 ? y - 15 : y + 15) + 'px)';
          break;
      }
      return _translates.join(' ');
    },
    contentStyle: function contentStyle() {
      var _position = this.position,
          _position$x = _position.x,
          x = _position$x === undefined ? 0 : _position$x,
          _position$y = _position.y,
          y = _position$y === undefined ? 0 : _position$y;

      var style = {};
      x < 0 ? style.right = -x + 'px' : style.left = x + 'px';
      y < 0 ? style.bottom = -y + 'px' : style.top = y + 'px';
      style.opacity = this.hasAnimation || !this.showIn ? '0' : '1';
      style.transform = this.hasAnimation || !this.showIn ? this.contentTransform : 'scale(1)';
      style.transformOrigin = this.transformOrigin;
      return style;
    },
    arrowStyle: function arrowStyle() {
      var _arrowPosition3 = this.arrowPosition,
          _arrowPosition3$x = _arrowPosition3.x,
          x = _arrowPosition3$x === undefined ? 0 : _arrowPosition3$x,
          _arrowPosition3$y = _arrowPosition3.y,
          y = _arrowPosition3$y === undefined ? 0 : _arrowPosition3$y;
      var _arrowPosition$pos3 = this.arrowPosition.pos,
          pos = _arrowPosition$pos3 === undefined ? 'top' : _arrowPosition$pos3;

      var style = {};
      switch (pos) {
        case 'top':
          style.top = '6px';
        case 'bottom':
          //eslint-disable-line
          !style.top && (style.bottom = '6px');
          style.transform = 'scaleX(0.8) rotate(45deg)';
          if (x >= 0 && x < 22) {
            x = 22;
          } else if (x < 0 && x > -22) {
            x = -22;
          }
          x < 0 ? style.right = -x + 'px' : style.left = x + 'px';
          break;
        case 'left':
          style.left = '6px';
        case 'right':
          //eslint-disable-line
          !style.left && (style.right = '6px');
          style.transform = 'scaleY(0.8) rotate(45deg)';
          if (y >= 0 && y < 22) {
            y = 22;
          } else if (y < 0 && y > -22) {
            y = -22;
          }
          y < 0 ? style.bottom = -y + 'px' : style.top = y + 'px';
          break;
        default:
          break;
      }
      return style;
    }
  },
  methods: {
    wxcPopoverShow: function wxcPopoverShow() {
      var _this = this;

      if (this.animationLock) {
        return;
      }
      this.show = true;
      if (this.hasAnimation) {
        setTimeout(function () {
          return _this.wxcPopoverAnimationShow();
        }, 40);
      } else {
        setTimeout(function () {
          return _this.showIn = true;
        }, 40);
      }
    },

    /**
    * smooth in
    **/
    wxcPopoverAnimationShow: function wxcPopoverAnimationShow() {
      var _this2 = this;

      var popoverEl = this.$refs['wxc-popover'];
      var coverEl = this.$refs['wxc-cover'];
      if (!coverEl || !popoverEl) {
        return;
      }
      this.setAnimationLock();
      var a1End = false;
      var a2End = false;
      animation.transition(popoverEl, {
        styles: {
          opacity: 1,
          transform: 'scale(1)',
          transformOrigin: this.transformOrigin
        },
        delay: 0,
        duration: 250,
        timingFunction: 'ease-out'
      }, function (e) {
        a1End = true;
        if (a1End && a2End) {
          _this2.animationLock = false;
        }
      });

      animation.transition(coverEl, {
        styles: {
          opacity: 1
        },
        delay: 0,
        duration: 250,
        timingFunction: 'ease-in'
      }, function (e) {
        a2End = true;
        if (a1End && a2End) {
          _this2.animationLock = false;
        }
      });
    },
    wxcButtonClicked: function wxcButtonClicked(index, key) {
      if (this.animationLock) {
        return;
      }
      this.$emit('wxcPopoverButtonClicked', { key: key, index: index });
      this.hideAction();
    },

    /**
       * 隐藏操作
       */
    hideAction: function hideAction() {
      var _this3 = this;

      if (this.animationLock) {
        return;
      }
      if (this.hasAnimation) {
        this.setAnimationLock();
        var popoverEl = this.$refs['wxc-popover'];
        var coverEl = this.$refs['wxc-cover'];
        if (!popoverEl || !coverEl) {
          return;
        }
        var a1End = false;
        var a2End = false;
        animation.transition(popoverEl, {
          styles: {
            opacity: 0,
            transform: this.contentTransform,
            transformOrigin: this.transformOrigin
          },
          duration: 250
        }, function () {
          a1End = true;
          if (a1End && a2End) {
            _this3.show = false;
            _this3.showIn = false;
            _this3.animationLock = false;
          }
        });
        animation.transition(coverEl, {
          styles: {
            opacity: 0
          },
          duration: 250
        }, function () {
          a2End = true;
          if (a1End && a2End) {
            _this3.show = false;
            _this3.showIn = false;
            _this3.animationLock = false;
          }
        });
      } else {
        this.show = false;
        this.showIn = false;
      }
    },

    /**
       * 设置动画锁
       */
    setAnimationLock: function setAnimationLock() {
      this.animationLock = true;
    }
  }
};

/***/ }),
/* 231 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["wrapper"]
  }, [(_vm.show) ? _c('div', {
    ref: "wxc-cover",
    staticClass: ["g-cover"],
    style: _vm.coverStyle,
    on: {
      "click": _vm.hideAction
    }
  }) : _vm._e(), (_vm.show && _vm.buttons.length) ? _c('div', {
    ref: "wxc-popover",
    staticClass: ["g-popover"],
    style: _vm.contentStyle
  }, [_c('div', {
    staticClass: ["u-popover-arrow"],
    style: _vm.arrowStyle
  }), _c('div', {
    staticClass: ["u-popover-inner"]
  }, _vm._l((_vm.buttons), function(item, i) {
    return _c('div', {
      key: i,
      class: ['i-btn', i === _vm.buttons.length - 1 ? 'i-btn-noborder' : ''],
      on: {
        "click": function($event) {
          _vm.wxcButtonClicked(i, item.key)
        }
      }
    }, [(item.icon) ? _c('image', {
      staticClass: ["btn-icon"],
      attrs: {
        "src": item.icon
      }
    }) : _vm._e(), _c('text', {
      staticClass: ["btn-text"],
      style: _vm.textStyle
    }, [_vm._v(_vm._s(item.text))])])
  }))]) : _vm._e()])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(233);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(234)
)

/* script */
__vue_exports__ = __webpack_require__(235)

/* template */
var __vue_template__ = __webpack_require__(236)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-popup\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-ef24f190"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 234 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-popup": {
    "position": "fixed",
    "width": "750"
  },
  "top": {
    "left": 0,
    "right": 0
  },
  "bottom": {
    "left": 0,
    "right": 0
  },
  "left": {
    "bottom": 0,
    "top": 0
  },
  "right": {
    "bottom": 0,
    "top": 0
  }
}

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _wxcOverlay = __webpack_require__(14);

var _wxcOverlay2 = _interopRequireDefault(_wxcOverlay);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var animation = weex.requireModule('animation');
exports.default = {
  components: { WxcOverlay: _wxcOverlay2.default },
  props: {
    show: {
      type: Boolean,
      default: false
    },
    pos: {
      type: String,
      default: 'bottom'
    },
    popupColor: {
      type: String,
      default: '#FFFFFF'
    },
    overlayCfg: {
      type: Object,
      default: function _default() {
        return {
          hasAnimation: true,
          timingFunction: ['ease-in', 'ease-out'],
          duration: 300,
          opacity: 0.6
        };
      }
    },
    height: {
      type: [Number, String],
      default: 840
    },
    standOut: {
      type: [Number, String],
      default: 0
    },
    width: {
      type: [Number, String],
      default: 750
    },
    animation: {
      type: Object,
      default: function _default() {
        return {
          timingFunction: 'ease-in'
        };
      }
    }
  },
  data: function data() {
    return {
      haveOverlay: true,
      isOverShow: true
    };
  },
  computed: {
    isNeedShow: function isNeedShow() {
      var _this = this;

      setTimeout(function () {
        _this.appearPopup(_this.show);
      }, 50);
      return this.show;
    },
    _height: function _height() {
      this.appearPopup(this.show, 150);
      return this.height;
    },
    padStyle: function padStyle() {
      var pos = this.pos,
          width = this.width,
          height = this.height,
          popupColor = this.popupColor,
          standOut = this.standOut;

      var stand = parseInt(standOut, 10);
      var style = {
        width: width + 'px',
        backgroundColor: popupColor
      };
      pos === 'top' && (style = _extends({}, style, {
        top: -height + stand + 'px',
        height: height + 'px'
      }));
      pos === 'bottom' && (style = _extends({}, style, {
        bottom: -height + stand + 'px',
        height: height + 'px'
      }));
      pos === 'left' && (style = _extends({}, style, {
        left: -width + stand + 'px'
      }));
      pos === 'right' && (style = _extends({}, style, {
        right: -width + stand + 'px'
      }));
      return style;
    }
  },
  methods: {
    handleTouchEnd: function handleTouchEnd(e) {
      // 在支付宝上面有点击穿透问题
      var platform = weex.config.env.platform;

      platform === 'Web' && e.preventDefault && e.preventDefault();
    },
    hide: function hide() {
      this.appearPopup(false);
      this.$refs.overlay.appearOverlay(false);
    },
    wxcOverlayBodyClicking: function wxcOverlayBodyClicking() {
      this.isShow && this.appearPopup(false);
    },
    appearPopup: function appearPopup(bool) {
      var _this2 = this;

      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;

      this.isShow = bool;
      var popupEl = this.$refs['wxc-popup'];
      if (!popupEl) {
        return;
      }
      animation.transition(popupEl, _extends({
        styles: {
          transform: this.getTransform(this.pos, this.width, this.height, !bool)
        },
        duration: duration,
        delay: 0
      }, this.animation), function () {
        if (!bool) {
          _this2.$emit('wxcPopupOverlayClicked', { pos: _this2.pos });
        }
      });
    },
    getTransform: function getTransform(pos, width, height, bool) {
      var _size = pos === 'top' || pos === 'bottom' ? height : width;
      bool && (_size = 0);
      var _transform = void 0;
      switch (pos) {
        case 'top':
          _transform = 'translateY(' + _size + 'px)';
          break;
        case 'bottom':
          _transform = 'translateY(-' + _size + 'px)';
          break;
        case 'left':
          _transform = 'translateX(' + _size + 'px)';
          break;
        case 'right':
          _transform = 'translateX(-' + _size + 'px)';
          break;
      }
      return _transform;
    }
  }
};

/***/ }),
/* 236 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_c('div', {
    on: {
      "touchend": _vm.handleTouchEnd
    }
  }, [(_vm.show) ? _c('wxc-overlay', _vm._b({
    ref: "overlay",
    attrs: {
      "show": _vm.haveOverlay && _vm.isOverShow
    },
    on: {
      "wxcOverlayBodyClicking": _vm.wxcOverlayBodyClicking
    }
  }, 'wxc-overlay', _vm.overlayCfg, false)) : _vm._e()], 1), (_vm.show) ? _c('div', {
    ref: "wxc-popup",
    class: ['wxc-popup', _vm.pos],
    style: _vm.padStyle,
    attrs: {
      "height": _vm._height,
      "hack": _vm.isNeedShow
    },
    on: {
      "click": function () {}
    }
  }, [_vm._t("default")], 2) : _vm._e()])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(238);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(239)
)

/* script */
__vue_exports__ = __webpack_require__(240)

/* template */
var __vue_template__ = __webpack_require__(241)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-progress\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-6fb0dabd"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 239 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-progress": {
    "backgroundColor": "#f2f3f4"
  },
  "progress": {
    "position": "absolute",
    "backgroundColor": "#FFC900"
  }
}

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  props: {
    barColor: {
      type: String,
      default: '#FFC900'
    },
    barWidth: {
      type: Number,
      default: 600
    },
    barHeight: {
      type: Number,
      default: 8
    },
    barRadius: {
      type: Number,
      default: 0
    },
    value: {
      type: Number,
      default: 0
    },
    backgroundColor: {
      type: String,
      default: '#f2f3f4'
    }
  },
  computed: {
    runWayStyle: function runWayStyle() {
      var barWidth = this.barWidth,
          barHeight = this.barHeight,
          barRadius = this.barRadius,
          backgroundColor = this.backgroundColor;

      return {
        width: barWidth + 'px',
        height: barHeight + 'px',
        borderRadius: barRadius + 'px',
        backgroundColor: backgroundColor
      };
    },
    progressStyle: function progressStyle() {
      var value = this.value,
          barWidth = this.barWidth,
          barHeight = this.barHeight,
          barColor = this.barColor,
          barRadius = this.barRadius;

      var newValue = value < 0 ? 0 : value > 100 ? 100 : value;
      return {
        backgroundColor: barColor,
        borderRadius: barRadius + 'px',
        height: barHeight + 'px',
        width: newValue / 100 * barWidth + 'px'
      };
    }
  }
};

/***/ }),
/* 241 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["wxc-progress"],
    style: _vm.runWayStyle,
    attrs: {
      "accessible": true,
      "ariaLabel": ("进度为百分之" + _vm.value)
    }
  }, [_c('div', {
    staticClass: ["progress"],
    style: _vm.progressStyle
  })])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(243);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(244)
)

/* script */
__vue_exports__ = __webpack_require__(245)

/* template */
var __vue_template__ = __webpack_require__(251)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-radio\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-7ab2d872"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 244 */
/***/ (function(module, exports) {

module.exports = {}

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _item = __webpack_require__(246);

var _item2 = _interopRequireDefault(_item);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  components: { wxcRadio: _item2.default },
  props: {
    list: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    config: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  data: function data() {
    return {
      checkedIndex: -1
    };
  },
  computed: {
    updateList: function updateList() {
      var checkedIndex = this.checkedIndex,
          list = this.list;

      var updateList = [];
      list && list.forEach(function (item, i) {
        item.checked = i === checkedIndex;
        updateList.push(item);
      });
      return updateList;
    }
  },
  watch: {
    list: function list(newList, oldList) {
      if (JSON.stringify(newList) !== JSON.stringify(oldList.map(function (v) {
        var title = v.title,
            value = v.value;

        return { title: title, value: value };
      }))) {
        this.checkedIndex = -1;
      }
      this.setListChecked(newList);
    }
  },
  created: function created() {
    this.setListChecked(this.list);
  },

  methods: {
    setListChecked: function setListChecked(list) {
      var _this = this;

      if (list && list.length > 0) {
        list.forEach(function (item, i) {
          item.checked && (_this.checkedIndex = i);
        });
      }
    },
    wxcRadioItemChecked: function wxcRadioItemChecked(i, e) {
      var oldIndex = this.checkedIndex;
      var _list$i = this.list[i],
          value = _list$i.value,
          title = _list$i.title;

      this.checkedIndex = i;
      this.$emit('wxcRadioListChecked', { value: value, title: title, oldIndex: oldIndex, index: i });
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(247)
)

/* script */
__vue_exports__ = __webpack_require__(248)

/* template */
var __vue_template__ = __webpack_require__(250)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-radio\\item.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-6c5a49a4"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 247 */
/***/ (function(module, exports) {

module.exports = {
  "radio": {
    "width": "36",
    "height": "36"
  },
  "title-text": {
    "fontSize": "30",
    "height": "40",
    "lineHeight": "40"
  }
}

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _wxcCell = __webpack_require__(29);

var _wxcCell2 = _interopRequireDefault(_wxcCell);

var _type = __webpack_require__(249);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  components: { WxcCell: _wxcCell2.default },
  props: {
    hasTopBorder: {
      type: Boolean,
      default: false
    },
    title: {
      type: String,
      require: true
    },
    value: {
      type: [String, Number, Object],
      require: true
    },
    disabled: {
      type: Boolean,
      default: false
    },
    checked: {
      type: Boolean,
      default: false
    },
    config: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  data: function data() {
    return {
      icon: [_type.CHECKED, _type.DISABLED]
    };
  },
  computed: {
    radioIcon: function radioIcon() {
      var icon = this.icon,
          disabled = this.disabled,
          checked = this.checked,
          config = this.config;

      var mergeIcon = icon;
      config.checkedIcon && (mergeIcon[0] = config.checkedIcon);
      config.disabledIcon && (mergeIcon[1] = config.disabledIcon);
      return checked ? mergeIcon[disabled ? 1 : 0] : '';
    },
    backgroundColor: function backgroundColor() {
      var disabled = this.disabled;

      return disabled ? '#F2F3F4' : '#FFFFFF';
    },
    color: function color() {
      var disabled = this.disabled,
          checked = this.checked,
          config = this.config;

      var checkedColor = '#EE9900';
      config.checkedColor && (checkedColor = config.checkedColor);
      return checked && !disabled ? checkedColor : '#3D3D3D';
    }
  },
  methods: {
    wxcCellClicked: function wxcCellClicked() {
      var disabled = this.disabled,
          value = this.value;

      if (!disabled) {
        this.$emit('wxcRadioItemChecked', { value: value, disabled: disabled });
      }
    }
  }
};

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var CHECKED = exports.CHECKED = 'https://gw.alicdn.com/tfs/TB1Y9vlpwMPMeJjy1XcXXXpppXa-72-72.png';
var DISABLED = exports.DISABLED = 'https://gw.alicdn.com/tfs/TB1PtN3pwMPMeJjy1XdXXasrXXa-72-72.png';

/***/ }),
/* 250 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('wxc-cell', {
    attrs: {
      "hasTopBorder": _vm.hasTopBorder,
      "cellStyle": {
        backgroundColor: _vm.backgroundColor
      },
      "accessible": true,
      "ariaLabel": (_vm.title + ",状态为" + (_vm.checked?'已选中':'未选中') + "," + (_vm.disabled?'不可更改':''))
    },
    on: {
      "wxcCellClicked": _vm.wxcCellClicked
    }
  }, [_c('text', {
    staticClass: ["title-text"],
    style: {
      color: _vm.color
    },
    attrs: {
      "slot": "title"
    },
    slot: "title"
  }, [_vm._v(_vm._s(_vm.title))]), (_vm.radioIcon) ? _c('image', {
    staticClass: ["radio"],
    attrs: {
      "slot": "value",
      "src": _vm.radioIcon
    },
    slot: "value"
  }) : _vm._e()])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 251 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', _vm._l((_vm.updateList), function(item, i) {
    return _c('wxc-radio', _vm._b({
      key: i,
      attrs: {
        "config": _vm.config
      },
      on: {
        "wxcRadioItemChecked": function($event) {
          _vm.wxcRadioItemChecked(i, $event)
        }
      }
    }, 'wxc-radio', item, false))
  }))
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(253);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(254)
)

/* script */
__vue_exports__ = __webpack_require__(255)

/* template */
var __vue_template__ = __webpack_require__(256)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-refresher\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-5c48c954"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 254 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-refresher": {
    "height": "140",
    "width": "750",
    "flexDirection": "row",
    "justifyContent": "center",
    "paddingTop": "50"
  },
  "cycle-container": {
    "position": "relative",
    "width": "60",
    "height": "60"
  },
  "u-cover": {
    "position": "absolute",
    "width": "30",
    "height": "60",
    "top": 0,
    "backgroundColor": "#ffffff",
    "overflow": "hidden",
    "right": 0
  },
  "c1": {
    "zIndex": 1
  },
  "c2": {
    "zIndex": 2,
    "transformOrigin": "left center",
    "transform": "rotateZ(0deg)"
  },
  "u-cover-cycle": {
    "position": "absolute",
    "width": "60",
    "height": "60",
    "right": 0,
    "top": 0,
    "borderWidth": "2",
    "borderColor": "#666666",
    "borderStyle": "solid",
    "borderRadius": "30",
    "opacity": 0
  },
  "cover1": {
    "opacity": 1
  },
  "indicator": {
    "marginRight": "20",
    "height": "60",
    "width": "60",
    "color": "#666666"
  },
  "arrow-down": {
    "position": "relative",
    "top": "15",
    "left": "-45",
    "width": "30",
    "height": "30"
  },
  "u-txt": {
    "fontSize": "24",
    "lineHeight": "40",
    "color": "#999999",
    "marginTop": "10",
    "marginLeft": "10",
    "height": "40",
    "lines": 1
  }
}

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(4);

var _index2 = _interopRequireDefault(_index);

var _bindEnv = __webpack_require__(5);

var _bindEnv2 = _interopRequireDefault(_bindEnv);

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var animation = weex.requireModule('animation');

// 减少打包体积


var ICON_ARROW_DOWN = 'https://img.alicdn.com/tfs/TB1A8faeTtYBeNjy1XdXXXXyVXa-48-48.png';

exports.default = {
  props: {
    scrollerRef: String,
    maxTime: {
      type: Number,
      default: 0
    },
    mainText: {
      type: String,
      default: '下拉即可刷新...'
    },
    pullingText: {
      type: String,
      default: '释放即可刷新...'
    },
    refreshingText: {
      type: String,
      default: '加载中...'
    },
    textWidth: {
      type: Number,
      default: 200
    }
  },
  data: function data() {
    return {
      ICON_ARROW_DOWN: ICON_ARROW_DOWN,
      refreshing: false,
      couldUnLash: false
    };
  },

  computed: {
    newStyleFlag: function newStyleFlag() {
      return this.scrollerRef && _bindEnv2.default.supportsEBForIos();
    },
    refresherText: function refresherText() {
      return this.refreshing ? this.refreshingText : this.pText;
    },
    pText: function pText() {
      return this.couldUnLash ? this.pullingText : this.mainText;
    }
  },
  created: function created() {
    this.newStyleFlag && this.animationBinding();
  },
  beforeDestroy: function beforeDestroy() {
    this.bindingsDestroy();
  },

  methods: {
    onRefresh: function onRefresh(event) {
      var _this = this;

      this.$emit('wxcRefresh', event);
      this.refreshing = true;
      this.newStyleFlag && this.cycleGoRound();
      if (this.maxTime <= 0) return;
      this.timeoutSto && clearTimeout(this.timeoutSto);
      this.timeoutSto = setTimeout(function () {
        _this.$emit('wxcTimeout');
        _this.wxcCancel();
      }, this.maxTime);
    },

    /**
     * 取消 refreshing
     */
    wxcCancel: function wxcCancel() {
      this.refreshing = false;
      this.timeoutSto && clearTimeout(this.timeoutSto);
      this.roundingDestroy();
    },

    /**
     * 下拉事件
     */
    onPullingDown: function onPullingDown(event) {
      this.$emit('wxcPullingDown', event);
      var pd = event.pullingDistance * (_utils2.default.env.isIOS() ? -1 : 1);
      pd > (_utils2.default.env.isAndroid() ? 200 : 140) ? this.couldUnLash = true : this.couldUnLash = false;
      if (this.refreshing && pd < 20) {
        this.timeoutSto && clearTimeout(this.timeoutSto);
        this.refreshing = false;
        this.roundingDestroy();
      }
    },

    /**
     * 注册 bindingx
     */
    animationBinding: function animationBinding() {
      var _this2 = this;

      setTimeout(function () {
        // 降级版本取不到，需要注意
        var scroller = _this2.$parent.$refs[_this2.scrollerRef].ref;
        var cover2 = _this2.$refs['cover2'].ref;
        var coverCycle = _this2.$refs['cover-cycle'].ref;

        var bindingResult = _index2.default.bind({
          eventType: 'scroll',
          anchor: scroller,
          props: [{
            element: cover2,
            property: 'transform.rotateZ',
            expression: 'y>-140?(y%75/150*-360):156'
          }, {
            element: coverCycle,
            property: 'opacity',
            expression: 'y<-75 ?1:0'
          }]
        }, function (e) {});
        _this2.bindingToken = bindingResult.token;
      }, 300);
    },

    /**
     * 旋转动作
     */
    cycleGoRound: function cycleGoRound() {
      if (_utils2.default.env.isAndroid()) return;
      var cycle = this.$refs['cycle'].ref;
      this.arrowShow(false);
      if (!cycle) {
        return;
      }
      var roundingResult = _index2.default.bind({
        eventType: 'timing',
        props: [{
          element: cycle,
          property: 'transform.rotateZ',
          expression: 't*0.72'
        }]
      }, function (e) {});
      this.roundingToken = roundingResult.token;
    },

    /**
     * 箭头显隐控制
     */
    arrowShow: function arrowShow() {
      var _show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      var arrow = this.$refs['arrow'];
      arrow && animation.transition(arrow, {
        styles: {
          opacity: _show ? 1 : 0,
          transform: _show ? "scale(1)" : "scale(0.5)"
        },
        duration: 300,
        delay: 0
      }, function () {});
    },

    /**
     * 完整 bindingx 销毁
     */
    bindingsDestroy: function bindingsDestroy() {
      if (this.bindingToken !== 0) {
        _index2.default && _index2.default.unbind({
          eventType: 'scroll',
          token: this.bindingToken
        });
        this.bindingToken = 0;
      }
      this.roundingDestroy();
    },

    /**
     * 旋转 bindingx 销毁
     */
    roundingDestroy: function roundingDestroy() {
      if (this.roundingToken !== 0) {
        _index2.default && _index2.default.unbind({
          eventType: 'timing',
          token: this.roundingToken
        });
        this.roundingToken = 0;
      }
      this.arrowShow(true);
    }
  }
};

/***/ }),
/* 256 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('refresh', {
    staticClass: ["wxc-refresher"],
    attrs: {
      "display": _vm.refreshing ? 'show' : 'hide'
    },
    on: {
      "refresh": _vm.onRefresh,
      "pullingdown": _vm.onPullingDown
    }
  }, [(_vm.newStyleFlag) ? _c('div', {
    ref: "cycle",
    staticClass: ["cycle-container"]
  }, [_c('div', {
    ref: "cover1",
    staticClass: ["u-cover", "c1"]
  }, [_c('div', {
    staticClass: ["u-cover-cycle", "cover1"]
  })]), _c('div', {
    ref: "cover2",
    staticClass: ["u-cover", "c2"]
  }, [_c('div', {
    ref: "cover-cycle",
    staticClass: ["u-cover-cycle"]
  })])]) : _vm._e(), (_vm.newStyleFlag) ? _c('image', {
    ref: "arrow",
    staticClass: ["arrow-down"],
    attrs: {
      "src": _vm.ICON_ARROW_DOWN,
      "resize": "contain"
    }
  }) : _c('loading-indicator', {
    staticClass: ["indicator"]
  }), _c('text', {
    staticClass: ["u-txt"],
    style: {
      width: (_vm.textWidth + "px")
    }
  }, [_vm._v(_vm._s(_vm.refresherText))])])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(258);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(259)
)

/* script */
__vue_exports__ = __webpack_require__(260)

/* template */
var __vue_template__ = __webpack_require__(274)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-rich-text\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-51a39eec"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 259 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-rich-text": {
    "alignItems": "center",
    "flexDirection": "row"
  },
  "default-text": {
    "color": "#A5A5A5",
    "fontSize": "24",
    "lineHeight": "30"
  }
}

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  components: {
    WxcRichTextText: __webpack_require__(30),
    WxcRichTextLink: __webpack_require__(264),
    WxcRichTextIcon: __webpack_require__(267),
    WxcRichTextTag: __webpack_require__(61)
  },
  props: {
    configList: {
      type: [Array, String],
      default: function _default() {
        return [];
      }
    },
    hasTextMargin: {
      type: Boolean,
      default: true
    }
  },
  data: function data() {
    return {};
  },
  computed: {
    isNotEmptyArray: function isNotEmptyArray() {
      return _utils2.default.isNonEmptyArray(this.configList);
    },
    isString: function isString() {
      return _utils2.default.isString(this.configList);
    }
  },
  methods: {
    linkClick: function linkClick(e) {
      this.$emit('wxcRichTextLinkClick', e);
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 261 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-text": {
    "fontSize": "24",
    "color": "#3d3d3d"
  },
  "black": {
    "color": "#3D3D3D"
  },
  "yellow": {
    "color": "#EE9900"
  },
  "blue": {
    "color": "#30A0FF"
  },
  "gray": {
    "color": "#A5A5A5"
  },
  "red": {
    "color": "#FF5000"
  },
  "margin-text": {
    "marginRight": "6"
  }
}

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  props: {
    textValue: {
      type: String,
      default: ''
    },
    textTheme: {
      type: String,
      default: 'gray'
    },
    textStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    hasTextMargin: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    themeStyle: function themeStyle() {
      var style = _extends({}, this.textStyle);
      if (style && (style.fontSize || style['font-size'])) {
        style = _extends({}, style, {
          fontSize: (style.fontSize || style['font-size']) + 'px',
          height: (style.fontSize || style['font-size']) * 1.2 + 'px'
        });
      }
      return style;
    }
  }
};

/***/ }),
/* 263 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('text', {
    class: ['wxc-text', _vm.textTheme, _vm.hasTextMargin ? 'margin-text' : ''],
    style: _vm.themeStyle
  }, [_vm._v(_vm._s(_vm.textValue))])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* script */
__vue_exports__ = __webpack_require__(265)

/* template */
var __vue_template__ = __webpack_require__(266)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-rich-text\\wxc-rich-text-link.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

var _wxcRichTextText = __webpack_require__(30);

var _wxcRichTextText2 = _interopRequireDefault(_wxcRichTextText);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  components: { WxcRichTextText: _wxcRichTextText2.default },
  props: {
    linkValue: {
      type: [String, Number],
      default: ''
    },
    hasTextMargin: {
      type: Boolean,
      default: true
    },
    linkHref: {
      type: String,
      default: ''
    },
    linkTheme: {
      type: String,
      default: 'black'
    },
    linkStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  data: function data() {
    return {
      defObj: {}
    };
  },
  methods: {
    onLinkClick: function onLinkClick(e) {
      this.$emit('wxcRichTextLinkClick', { element: e, href: this.linkHref });
      _utils2.default.goToH5Page(this.linkHref);
    }
  }
};

/***/ }),
/* 266 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    on: {
      "click": _vm.onLinkClick
    }
  }, [_c('wxc-rich-text-text', {
    attrs: {
      "textValue": _vm.linkValue,
      "hasTextMargin": _vm.hasTextMargin,
      "textStyle": _vm.linkStyle ? _vm.linkStyle : _vm.defObj,
      "textTheme": _vm.linkTheme ? _vm.linkTheme : 'black'
    }
  })], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(268)
)

/* script */
__vue_exports__ = __webpack_require__(269)

/* template */
var __vue_template__ = __webpack_require__(270)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-rich-text\\wxc-rich-text-icon.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-5d0a782a"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 268 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-image": {
    "width": "90",
    "height": "24",
    "marginRight": "6"
  }
}

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  props: {
    iconSrc: String,
    iconStyle: {
      type: Object,
      default: function _default() {
        return {
          height: 24
        };
      }
    }
  },
  data: function data() {
    return {
      width: 90
    };
  },
  computed: {
    computedStyle: function computedStyle() {
      var width = this.width,
          iconStyle = this.iconStyle;

      if (iconStyle && iconStyle.width && iconStyle.height) {
        return {
          width: iconStyle.width + "px",
          height: iconStyle.height + "px"
        };
      } else {
        return {
          width: width + "px",
          height: iconStyle.height + "px"
        };
      }
    }
  },
  methods: {
    onLoad: function onLoad(e) {
      if (e.success && e.size && e.size.naturalWidth > 0) {
        var width = e.size.naturalWidth;
        var height = e.size.naturalHeight;
        this.width = width * (this.iconStyle.height / height);
      }
    }
  }
};

/***/ }),
/* 270 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('image', {
    staticClass: ["wxc-image"],
    style: {
      width: _vm.computedStyle.width,
      height: _vm.computedStyle.height
    },
    attrs: {
      "src": _vm.iconSrc,
      "ariaHidden": true
    },
    on: {
      "load": _vm.onLoad
    }
  })
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 271 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-tag": {
    "borderColor": "#3d3d3d",
    "borderWidth": "2",
    "borderRadius": "4",
    "marginRight": "6",
    "backgroundColor": "rgba(0,0,0,0)",
    "paddingLeft": "6",
    "paddingRight": "6",
    "height": "26",
    "justifyContent": "center",
    "alignItems": "center"
  },
  "tag-text": {
    "fontSize": "20",
    "color": "#3d3d3d"
  },
  "black": {
    "color": "#3D3D3D"
  },
  "yellow": {
    "color": "#EE9900"
  },
  "blue": {
    "color": "#30A0FF"
  },
  "gray": {
    "color": "#A5A5A5"
  },
  "red": {
    "color": "#FF5000"
  },
  "border-black": {
    "borderColor": "#A5A5A5"
  },
  "border-yellow": {
    "borderColor": "#EE9900"
  },
  "border-blue": {
    "borderColor": "#30A0FF"
  },
  "border-gray": {
    "borderColor": "#A5A5A5"
  },
  "border-red": {
    "borderColor": "#FF5000"
  }
}

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  props: {
    tagValue: {
      type: [String, Number],
      default: ''
    },
    tagTheme: {
      type: String,
      default: 'blue'
    },
    tagStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  computed: {
    newTheme: function newTheme() {
      var tagStyle = this.tagStyle;
      var tagValue = this.tagValue;
      var divStyle = {};
      var textStyle = {};
      if (tagStyle && tagStyle.fontSize) {
        textStyle = _extends({}, textStyle, {
          fontSize: tagStyle.fontSize + 'px'
        });
      }
      if (tagStyle && tagStyle.color) {
        textStyle = _extends({}, textStyle, {
          color: tagStyle.color
        });
      }

      if (tagStyle && tagStyle.borderColor) {
        divStyle = _extends({}, divStyle, {
          borderColor: tagStyle.borderColor
        });
      }

      if (tagStyle && tagStyle.borderWidth) {
        divStyle = _extends({}, divStyle, {
          borderWidth: tagStyle.borderWidth + 'px'
        });
      }

      if (tagStyle && tagStyle.borderRadius) {
        divStyle = _extends({}, divStyle, {
          borderRadius: tagStyle.borderRadius + 'px'
        });
      }

      if (tagStyle && tagStyle.backgroundColor) {
        divStyle = _extends({}, divStyle, {
          backgroundColor: tagStyle.backgroundColor
        });
      }

      if (tagStyle && tagStyle.height) {
        divStyle = _extends({}, divStyle, {
          height: tagStyle.height + 'px'
        });
      }

      if (tagStyle && tagStyle.width) {
        divStyle = _extends({}, divStyle, {
          width: tagStyle.width + 'px'
        });
      }

      if (tagValue && tagValue.length === 1) {
        divStyle = _extends({}, divStyle, {
          paddingLeft: 0,
          paddingRight: 0
        });
      }

      return {
        divStyle: divStyle,
        textStyle: textStyle
      };
    }
  }
};

/***/ }),
/* 273 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    class: ['wxc-tag', 'border-' + _vm.tagTheme],
    style: _vm.newTheme.divStyle
  }, [_c('text', {
    class: ['tag-text', _vm.tagTheme],
    style: _vm.newTheme.textStyle
  }, [_vm._v(_vm._s(_vm.tagValue))])])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 274 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [(_vm.isNotEmptyArray) ? _c('div', {
    staticClass: ["wxc-rich-text"]
  }, _vm._l((_vm.configList), function(v) {
    return _c('div', [(v.type == 'text' && v.value) ? _c('wxc-rich-text-text', {
      attrs: {
        "textValue": v.value,
        "textStyle": v.style,
        "hasTextMargin": _vm.hasTextMargin,
        "textTheme": v.theme
      }
    }) : _vm._e(), (v.type == 'link' && v.href && v.value) ? _c('wxc-rich-text-link', {
      attrs: {
        "linkValue": v.value,
        "linkHref": v.href,
        "linkStyle": v.style,
        "hasTextMargin": _vm.hasTextMargin,
        "linkTheme": v.theme
      },
      on: {
        "wxcRichTextLinkClick": _vm.linkClick
      }
    }) : _vm._e(), (v.type == 'icon' && v.src) ? _c('wxc-rich-text-icon', {
      attrs: {
        "iconSrc": v.src,
        "iconStyle": v.style
      }
    }) : _vm._e(), (v.type == 'tag' && v.value) ? _c('wxc-rich-text-tag', {
      attrs: {
        "tagValue": v.value,
        "tagTheme": v.theme,
        "tagStyle": v.style
      }
    }) : _vm._e()], 1)
  })) : _vm._e(), (_vm.isString) ? _c('text', {
    staticClass: ["default-text"]
  }, [_vm._v(_vm._s(_vm.configList))]) : _vm._e()])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(276);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(277)
)

/* script */
__vue_exports__ = __webpack_require__(278)

/* template */
var __vue_template__ = __webpack_require__(279)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-simple-flow\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-172fef96"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 277 */
/***/ (function(module, exports) {

module.exports = {
  "flex-row": {
    "flexDirection": "row"
  },
  "full-rest": {
    "flex": 1
  },
  "root": {
    "paddingTop": "28",
    "paddingBottom": "24",
    "backgroundColor": "#ffffff"
  },
  "content": {
    "paddingTop": "9",
    "paddingBottom": "42",
    "paddingLeft": "70",
    "paddingRight": "70"
  },
  "last-one-content": {
    "paddingBottom": 0
  },
  "title": {
    "paddingLeft": "70",
    "paddingRight": "70"
  },
  "line": {
    "position": "absolute",
    "top": 0,
    "bottom": 0,
    "left": "38",
    "width": "2",
    "backgroundColor": "#FFC300"
  },
  "first-one-title-line": {
    "top": "20"
  },
  "last-one-title-line": {
    "bottom": "20"
  },
  "last-one-content-line": {
    "width": 0
  },
  "point": {
    "position": "absolute",
    "top": "13",
    "left": "32",
    "width": "14",
    "height": "14",
    "backgroundColor": "#FFF0BD",
    "borderStyle": "solid",
    "borderWidth": "2",
    "borderColor": "#EE9900",
    "borderRadius": "100"
  },
  "highlight-point": {
    "top": "7",
    "left": "26",
    "width": "26",
    "height": "26",
    "backgroundColor": "#EE9900",
    "borderStyle": "solid",
    "borderWidth": "6",
    "borderColor": "#FFE78D"
  },
  "text-title": {
    "fontSize": "30",
    "color": "#3d3d3d"
  },
  "text-highlight-title": {
    "color": "#EE9900"
  },
  "text-desc": {
    "fontSize": "24",
    "color": "#a5a5a5",
    "marginBottom": "12"
  },
  "text-date": {
    "fontSize": "24",
    "color": "#a5a5a5"
  }
}

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  props: {
    list: {
      type: Array,
      required: true
    },
    themeColor: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  computed: {
    cItems: function cItems() {
      return this.adapter(this.list);
    }
  },
  methods: {
    adapter: function adapter(items) {
      var _themeColor = this.themeColor,
          lineColor = _themeColor.lineColor,
          pointInnerColor = _themeColor.pointInnerColor,
          pointBorderColor = _themeColor.pointBorderColor,
          highlightTitleColor = _themeColor.highlightTitleColor,
          highlightPointInnerColor = _themeColor.highlightPointInnerColor,
          highlightPointBorderColor = _themeColor.highlightPointBorderColor;

      var len = items.length;
      var pre = Date.now();

      return items.map(function (item, index) {
        item.key = pre + '_' + index;
        item.__titleLineClass__ = [];
        item.__contentClass__ = [];
        item.__contentLineClass__ = [];
        item.__pointClass__ = [];
        item.__titleTextClass__ = [];
        item.__pointStyle__ = {};
        item.__lineStyle__ = {};
        item.__titleStyle__ = {};

        if (lineColor) item.__lineStyle__.backgroundColor = lineColor;
        if (pointInnerColor) item.__pointStyle__.backgroundColor = pointInnerColor;
        if (pointBorderColor) item.__pointStyle__.borderColor = pointBorderColor;

        if (index === 0) {
          item.__titleLineClass__.push('first-one-title-line');
        }

        if (index === len - 1) {
          item.__titleLineClass__.push('last-one-title-line');
          item.__contentClass__.push('last-one-content');
          item.__contentLineClass__.push('last-one-content-line');
        }

        if (item.highlight) {
          item.__pointClass__.push('highlight-point');
          item.__titleTextClass__.push('text-highlight-title');
          if (highlightTitleColor) item.__titleStyle__.color = highlightTitleColor;
          if (highlightPointInnerColor) item.__pointStyle__.backgroundColor = highlightPointInnerColor;
          if (highlightPointBorderColor) item.__pointStyle__.borderColor = highlightPointBorderColor;
        }
        return item;
      });
    }
  }
};

/***/ }),
/* 279 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["root"]
  }, _vm._l((_vm.cItems), function(item, index) {
    return _c('div', {
      key: item.key,
      attrs: {
        "accessible": true,
        "ariaLabel": ((item.title) + "," + (item.desc?item.desc:'') + "," + (item.date?item.date:'') + "," + (item.highlight?'已完成':'等待完成'))
      }
    }, [_c('div', {
      staticClass: ["title", "flex-row"]
    }, [_c('div', {
      staticClass: ["line"],
      class: item.__titleLineClass__,
      style: item.__lineStyle__
    }), _c('div', {
      staticClass: ["point"],
      class: item.__pointClass__,
      style: item.__pointStyle__
    }), _c('text', {
      staticClass: ["text-title", "full-rest"],
      class: item.__titleTextClass__,
      style: item.__titleStyle__
    }, [_vm._v(_vm._s(item.title))])]), _c('div', {
      staticClass: ["content", "flex-row"],
      class: item.__contentClass__
    }, [_c('div', {
      staticClass: ["line"],
      class: item.__contentLineClass__,
      style: item.__lineStyle__
    }), _c('div', {
      staticClass: ["full-rest"]
    }, [(item.desc) ? _c('text', {
      staticClass: ["text-desc"]
    }, [_vm._v(_vm._s(item.desc))]) : _vm._e(), (item.date) ? _c('text', {
      staticClass: ["text-date"]
    }, [_vm._v(_vm._s(item.date))]) : _vm._e()])])])
  }))
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(281);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(282)
)

/* script */
__vue_exports__ = __webpack_require__(283)

/* template */
var __vue_template__ = __webpack_require__(284)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-slide-nav\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-2f2d0cd3"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 282 */
/***/ (function(module, exports) {

module.exports = {
  "slide-nav": {
    "position": "absolute",
    "zIndex": 1000
  }
}

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var DOM = weex.requireModule('dom');
var Animation = weex.requireModule('animation');
var OFFSET_ACCURACY = 10;
var SCALE = weex.config.env.platform.toLowerCase() === 'web' ? 2 : 1;

function _toNum(str) {
  return typeof str === 'number' ? str : parseFloat((str || '').replace(/px$/i, ''));
}

function _getHeight(element, callback) {
  if (!element) {
    return;
  }
  if (element.__cacheHeight) {
    element.__cacheHeight && callback && callback(element.__cacheHeight);
  } else {
    DOM.getComponentRect(element, function (res) {
      var height = (parseFloat(res && res.size && res.size.height) || 0) / SCALE;
      height && callback && callback(element.__cacheHeight = height);
    });
  }
}

exports.default = {

  props: {
    position: {
      'type': String,
      'default': 'top'
    },

    height: [String, Number]
  },

  data: function data() {
    return {
      visible: true
    };
  },


  watch: {
    visible: function visible(newVal) {
      newVal ? this._slideIn() : this._slideOut();
    }
  },

  created: function created() {
    this._height = _toNum(this.height) || 0;
    this._isBottom = this.position === 'bottom';
    this._direction = this._isBottom ? 1 : -1;
  },


  methods: {
    _slideOut: function _slideOut() {
      var _this = this;

      this.getHeight(function (height) {
        _this.$emit('slideOut');
        _this.slideY(height * _this._direction * SCALE, function () {
          _this.$emit('slideOutEnd');
        });
      });
    },
    _slideIn: function _slideIn() {
      var _this2 = this;

      this.getHeight(function (height) {
        _this2.$emit('slideIn');
        _this2.slideY(0, function () {
          _this2.$emit('slideInEnd');
        });
      });
    },
    getHeight: function getHeight(callback) {
      return _getHeight(this.$refs.wrapper, callback);
    },
    slideOut: function slideOut() {
      this.visible = false;
    },
    slideIn: function slideIn() {
      this.visible = true;
    },
    slideY: function slideY(y, callback) {
      Animation.transition(this.$refs.wrapper, {
        styles: { transform: 'translateY(' + y + 'px)' },
        duration: 150, //ms
        timingFunction: 'ease',
        delay: 0 //ms
      }, callback);
    }
  },

  handleTouchStart: function handleTouchStart(e) {
    var touch = e.changedTouches[0];
    this._touchParams = {
      pageY: touch.screenY,
      startY: touch.screenY,
      lastPageY: touch.screenY,
      timeStamp: e.timeStamp,
      direction: -1
    };
  },
  handleTouchMove: function handleTouchMove(e, bottomNav) {
    var tp = this._touchParams;
    var touch = e.changedTouches[0];
    var offsetY = void 0;

    // 安卓下滚动的时候经常不触发touchstart事件
    if (!tp || tp.hasEnd) {
      return this._touchParams = {
        pageY: touch.screenY,
        startY: touch.screenY,
        lastPageY: touch.screenY,
        timeStamp: e.timeStamp,
        direction: -1
      };
    }

    offsetY = touch.screenY - tp.pageY;

    tp.lastPageY = tp.pageY;
    tp.lastDirection = tp.direction;
    tp.direction = offsetY > 0 ? 1 : -1;

    if (tp.lastDirection !== tp.direction) {
      tp.startY = tp.lastPageY;
    }

    tp.pageY = touch.screenY;
    tp.offsetY = tp.pageY - tp.startY;

    if (!this.__scrollable && bottomNav) {
      if (tp.offsetY <= -OFFSET_ACCURACY) {
        bottomNav.slideOut();
      } else if (tp.offsetY >= OFFSET_ACCURACY) {
        bottomNav.slideIn();
      }
    }
  },
  handleTouchEnd: function handleTouchEnd() {
    var tp = this._touchParams;
    tp && (tp.hasEnd = true);
  },
  handleScroll: function handleScroll(e, scroller, topNav, bottomNav, startThreshold) {
    var _this3 = this;

    var moveThreshold = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 5;

    var scrollY = e.contentOffset.y;
    var nav = topNav || bottomNav;
    var scrollFn = function scrollFn(maxScrollY) {
      if (-scrollY > maxScrollY) {
        return;
      }
      maxScrollY = Math.abs(maxScrollY);
      if (Math.abs(scrollY) < startThreshold) {
        if (Math.abs(scrollY) >= maxScrollY - OFFSET_ACCURACY) {
          var tp = _this3._touchParams;
          if (!tp) {
            return;
          }
          var offsetY = tp.offsetY;
          if (offsetY < -OFFSET_ACCURACY) {
            bottomNav && bottomNav.slideOut();
          } else if (offsetY > OFFSET_ACCURACY) {
            bottomNav && bottomNav.slideIn();
          }
        } else {
          topNav && topNav.slideIn();
          bottomNav && bottomNav.slideIn();
        }
      } else {
        var _tp = _this3._touchParams;
        if (!_tp) {
          return;
        }
        var _offsetY = _tp.offsetY;
        if (Math.abs(_offsetY) >= moveThreshold) {
          if (_offsetY > 0) {
            topNav && topNav.slideIn();
            bottomNav && bottomNav.slideIn();
          } else {
            topNav && topNav.slideOut();
            bottomNav && bottomNav.slideOut();
          }
        }
      }
    };

    var maxScrollYCheck = function maxScrollYCheck(maxScrollY) {
      if (!_this3.__scrollable) {
        return;
      }
      if (startThreshold) {
        scrollFn(maxScrollY);
      } else {
        nav.getHeight(function (navHeight) {
          startThreshold = navHeight;
          scrollFn(maxScrollY);
        });
      }
    };

    if (!nav) {
      return;
    }

    _getHeight(scroller, function (scrollerHeight) {
      var maxScrollY = e.contentSize.height - scrollerHeight;
      _this3.__scrollable = maxScrollY >= OFFSET_ACCURACY;

      if (bottomNav) {
        bottomNav.getHeight(function (height) {
          _this3.__scrollable = maxScrollY >= height;
          maxScrollYCheck(maxScrollY);
        });
      } else {
        maxScrollYCheck(maxScrollY);
      }
    });
  }
};

/***/ }),
/* 284 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    ref: "wrapper",
    staticClass: ["slide-nav"]
  }, [_vm._t("default")], 2)
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(286);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(287)
)

/* script */
__vue_exports__ = __webpack_require__(288)

/* template */
var __vue_template__ = __webpack_require__(289)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-slider-bar\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-1e3a70b7"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 287 */
/***/ (function(module, exports) {

module.exports = {
  "slider-bar-container": {
    "height": "56",
    "justifyContent": "center",
    "alignItems": "center",
    "overflow": "hidden"
  },
  "range-bar": {
    "overflow": "hidden"
  },
  "value-bar": {
    "height": "4",
    "overflow": "hidden"
  },
  "slide-block": {
    "width": "56",
    "height": "56",
    "borderRadius": "28",
    "borderWidth": "1",
    "borderColor": "rgba(0,0,0,0.1)",
    "position": "absolute",
    "left": 0,
    "bottom": 0
  }
}

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

var _bindEnv = __webpack_require__(5);

var _bindEnv2 = _interopRequireDefault(_bindEnv);

var _indexWeex = __webpack_require__(4);

var _indexWeex2 = _interopRequireDefault(_indexWeex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var animation = weex.requireModule('animation'); //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var dom = weex.requireModule('dom');

exports.default = {
  data: function data() {
    return {
      env: 'weex',
      diffX1: 0,
      diffX2: 0,
      barWidth: 0,
      preventMoveEvent: true,
      minDist: 0,
      // selectRange: [0, 0],
      blockRadius: 28,
      DPR: 1,
      timeout: 100,
      isAndroid: _utils2.default.env.isAndroid()
    };
  },
  props: {
    selectRange: {
      type: Array,
      default: [0, 0]
    },
    length: {
      type: Number,
      default: 500
    },
    height: {
      type: Number,
      default: 4
    },
    // 是否双滑块模式
    range: {
      type: Boolean,
      default: false
    },
    // 最小值
    min: {
      type: Number,
      default: 0
    },
    // 最大值
    max: {
      type: Number,
      default: 100
    },
    // 最小取值范围，用于范围选择范围最小差值
    minDiff: {
      type: Number,
      default: 5
    },
    // 设置当前取值。当 range 为 false 时，使用 number，否则用 [number, number]
    value: {
      type: [Number, Array],
      default: 0
    },
    // 设置初始取值。当 range 为 false 时，使用 number，否则用 [number, number]
    defaultValue: {
      type: [Number, Array],
      default: 0
    },
    // 值为 true 时，滑块为禁用状态
    disabled: {
      type: Boolean,
      default: false
    },
    invalidColor: {
      type: String,
      default: '#E0E0E0'
    },
    validColor: {
      type: String,
      default: '#EE9900'
    },
    disabledColor: {
      type: String,
      default: '#AAA'
    },
    blockColor: {
      type: String,
      default: '#ffffff'
    }
  },
  watch: {
    value: function value(e) {
      if (!this.range) {
        this.diffX1 = this._getDiffX(e || this.defaultValue);
      } else {
        this.diffX1 = this._getDiffX(e[0] || this.defaultValue[0]);
        this.diffX2 = this._getDiffX(e[1] || this.defaultValue[1]);
        this.barWidth = this.diffX2 - this.diffX1;
      }
    }
  },
  created: function created() {
    if (_utils2.default.env.isWeb()) {
      this.env = 'web';
      this.DPR = window.devicePixelRatio ? window.devicePixelRatio : 1;
    } else {
      this.DPR = weex.config.env.scale;
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.block1 = this.$refs['slide-block-1']; // 左侧滑块
    this.block2 = this.$refs['slide-block-2']; // 右侧滑块
    this.valueBar = this.$refs['value-bar']; // 黄色值条
    this.barContainer = this.$refs['bar-container']; // 滚动条容器

    if (!this.range) {
      this.diffX1 = this._getDiffX(this.value || this.defaultValue);
    } else {
      this.diffX1 = this._getDiffX(this.value[0] || this.defaultValue[0]);
      this.diffX2 = this._getDiffX(this.value[1] || this.defaultValue[1]);
      this.barWidth = this.diffX2 - this.diffX1;
    }

    // 是否支持expresstionBinding
    if (_bindEnv2.default.supportsEB() && _indexWeex2.default.prepare) {
      this.block1 && _indexWeex2.default.prepare({
        anchor: this.block1.ref,
        eventType: 'pan'
      });
      this.block2 && _indexWeex2.default.prepare({
        anchor: this.block2.ref,
        eventType: 'pan'
      });
      this.valueBar && _indexWeex2.default.prepare({
        anchor: this.valueBar.ref,
        eventType: 'pan'
      });
    }

    if (this.range) {
      this.selectRange = this.value || this.defaultValue; // 初始化范围选择返回数据
      this.minDist = this.minDiff / (this.max - this.min) * this.length; // 滑块1、2之前最小间距
    }

    // 由于weex在mounted后渲染是异步的不能确保元素渲染完成，需要异步执行
    setTimeout(function () {
      dom.getComponentRect(_this.barContainer, function (option) {
        var left = option.size.left;

        _this.leftDiffX = left;
      });
    }, 100);
  },


  computed: {
    containerStyle: function containerStyle() {
      return {
        width: this.length + 56 + 'px',
        height: '56px'
      };
    },
    rangeBarStyle: function rangeBarStyle() {
      return {
        width: this.length + 'px',
        height: this.height + 'px',
        flexDirection: 'row',
        backgroundColor: this.invalidColor
      };
    },
    valueBarStyle: function valueBarStyle() {
      var left = 0;
      var width = 0;

      if (!this.range) {
        left = this.diffX1 - this.length;
        width = this.length;
      } else {
        left = this.diffX1;
        width = this.diffX2 - this.diffX1;
      }

      return {
        width: width + 'px',
        height: this.height + 'px',
        transform: 'translateX(' + left + 'px)',
        backgroundColor: this.disabled ? this.disabledColor : this.validColor
      };
    },
    blockStyle1: function blockStyle1() {
      var left = this.diffX1;
      return {
        transform: 'translateX(' + left + 'px)',
        backgroundColor: this.blockColor
      };
    },
    blockStyle2: function blockStyle2() {
      return {
        transform: 'translateX(' + this.diffX2 + 'px)',
        backgroundColor: this.blockColor
      };
    }
  },
  methods: {
    getBlock1Value: function getBlock1Value(callback) {
      var _this2 = this;

      dom.getComponentRect(this.block1, function (option) {
        var left = option.size.left;

        var value = _this2._getValue(left - _this2.leftDiffX);
        if (!_this2.range) {
          callback && callback(value);
        } else {
          _this2.selectRange[0] = value;
          callback && callback(_this2.selectRange);
        }
      });
    },
    getBlock2Value: function getBlock2Value(callback) {
      var _this3 = this;

      dom.getComponentRect(this.block2, function (option) {
        var left = option.size.left;

        _this3.selectRange[1] = _this3._getValue(left - _this3.leftDiffX);
        callback && callback(_this3.selectRange);
      });
    },

    // 更新单选值或最小值
    weexHandler1: function weexHandler1(e) {
      var _this4 = this;

      var self = this;
      switch (e.state) {
        case 'start':
          self.bindBlock1();
          break;
        case 'move':
          this.getBlock1Value(function (value) {
            return _this4.$emit('updateValue', value);
          });
          break;
        case 'end':
          this.getBlock1Value(function (value) {
            return _this4.$emit('wxcSliderBarTouchEnd', value);
          });
          break;
        default:
          break;
      }
    },


    // 更新最大值
    weexHandler2: function weexHandler2(e) {
      var _this5 = this;

      var self = this;

      switch (e.state) {
        case 'start':
          self.bindBlock2();
          break;
        case 'move':
          self.getBlock2Value(function (value) {
            return _this5.$emit('updateValue', value);
          });
          break;
        case 'end':
          self.getBlock2Value(function (value) {
            return _this5.$emit('wxcSliderBarTouchEnd', value);
          });
          break;
        default:
          break;
      }
    },
    weexStartHandler1: function weexStartHandler1() {
      var _this6 = this;

      // 由于android端不支持 horizontalpan 的move事件，使用setInterval hack方案
      if (!this.isAndroid) {
        return;
      }
      this.firstInterval = setInterval(function () {
        _this6.getBlock1Value(function (value) {
          return _this6.$emit('updateValue', value);
        });
      }, this.timeout);
    },
    weexStartHandler2: function weexStartHandler2() {
      var _this7 = this;

      if (!this.isAndroid) {
        return;
      }
      // 由于android端不支持 horizontalpan 的move事件，使用setInterval hack方案
      this.secondInterval = setInterval(function () {
        _this7.getBlock2Value(function (value) {
          return _this7.$emit('updateValue', value);
        });
      }, this.timeout);
    },


    // 清除定时器
    weexEndHandler: function weexEndHandler() {
      var _this8 = this;

      if (!this.isAndroid) {
        return;
      }
      this.firstInterval && clearInterval(this.firstInterval);
      this.secondInterval && clearInterval(this.secondInterval);
      if (this.range) {
        this.getBlock2Value(function (value) {
          return _this8.$emit('updateValue', value);
        });
      } else {
        this.getBlock1Value(function (value) {
          return _this8.$emit('updateValue', value);
        });
      }
    },
    webStartHandler: function webStartHandler(e) {
      if (this.env === 'weex') {
        return;
      }
      this.startX = e.touch.clientX;
      this.startDiffX1 = this.diffX1;
      this.startDiffX2 = this.diffX2;
    },
    webMoveHandler1: function webMoveHandler1(e) {
      if (this.env === 'weex' || this.disabled) {
        return;
      }

      var deltaX = (e.touch.clientX - this.startX) * this.DPR;
      var diff = this.startDiffX1 + deltaX;

      var max = this.length;
      if (this.range) {
        max = this.diffX2 - this.minDist;
      }

      if (diff > 0 && diff < max) {
        this.diffX1 = diff;
        animation.transition(this.block1, {
          styles: {
            transform: 'translateX(' + this.diffX1 + 'px)'
          }
        }, function () {});
        if (!this.range) {
          this.$emit('updateValue', this._getValue(this.diffX1));
        } else {
          this.selectRange[0] = this._getValue(this.diffX1);
          this.$emit('updateValue', this.selectRange);
        }
      }
    },
    webEndHandler: function webEndHandler(e) {
      if (this.env === 'weex' || this.disabled) {
        return;
      }
      if (!this.range) {
        this.$emit('wxcSliderBarTouchEnd', this._getValue(this.diffX1));
      } else {
        this.selectRange[1] = this._getValue(this.diffX2);
        this.$emit('wxcSliderBarTouchEnd', this.selectRange);
      }
    },
    webMoveHandler2: function webMoveHandler2(e) {
      if (this.env === 'weex' || this.disabled) {
        return;
      }

      var deltaX = (e.touch.clientX - this.startX) * this.DPR;
      var diff = this.startDiffX2 + deltaX;
      var min = this.diffX1 + this.minDist;
      var max = this.length;

      if (diff > min && diff < max) {
        this.diffX2 = diff;
        animation.transition(this.block2, {
          styles: {
            transform: 'translateX(' + this.diffX2 + 'px)'
          }
        }, function () {});
        if (!this.range) {
          this.$emit('updateValue', this._getValue(this.diffX2));
        } else {
          this.selectRange[1] = this._getValue(this.diffX2);
          this.$emit('updateValue', this.selectRange);
        }
      }
    },
    bindBlock1: function bindBlock1() {
      var self = this;

      // 如果禁用，不行进行表达式绑定
      if (self.disabled) {
        _indexWeex2.default.unbind({
          token: this.gesToken1,
          eventType: 'pan'
        });
        this.gesToken1 = 0;
        return;
      }

      // 初始化按钮&条的大小范围
      var blockMax1 = 0;
      if (self.range) {
        blockMax1 = self.diffX2 - self.minDist;
      } else {
        blockMax1 = self.length;
      }

      var barMax1 = self.diffX2;

      if (!self.range) {

        var startLeft = self.diffX1 - blockMax1 - self.minDist;

        var props = [{
          element: self.block1.ref,
          property: 'transform.translateX',
          expression: 'min(' + blockMax1 + ', max(x + ' + self.diffX1 + ', 0))'
        }, {
          element: self.valueBar.ref,
          property: 'transform.translateX',
          expression: 'min(0, max(x + ' + startLeft + ', -' + blockMax1 + '))'
        }];

        var gesTokenObj = _indexWeex2.default.bind({
          anchor: self.block1.ref,
          eventType: 'pan',
          props: props
        }, function (e) {
          if (e.state === 'end' || e.state === 'cancel' || e.state === 'exit') {
            var range = self.getRange();
            // 限制diffX1范围
            self.diffX1 = self._restrictValue(range.rangeX1, self.diffX1 + e.deltaX);
            self.bindBlock1();
          }
        });
        this.gesToken1 = gesTokenObj.token;
      } else {

        // 选范围
        var _props = [{
          element: self.block1.ref,
          property: 'transform.translateX',
          expression: 'min(' + blockMax1 + ', max(x + ' + self.diffX1 + ', 0))'
        }, {
          element: self.valueBar.ref,
          property: 'transform.translateX',
          expression: 'min(' + blockMax1 + ', max(x + ' + self.diffX1 + ', 0))'
        }, {
          element: self.valueBar.ref,
          property: 'width',
          expression: 'min(' + barMax1 + ', max(0, ' + self.barWidth + ' - x))'
        }];

        var _gesTokenObj = _indexWeex2.default.bind({
          anchor: self.block1.ref,
          eventType: 'pan',
          props: _props
        }, function (e) {
          if (e.state === 'end' || e.state === 'cancel' || e.state === 'exit') {
            var range = self.getRange();
            self.barWidth = self._restrictValue(range.rangeX1, self.barWidth - e.deltaX);
            self.diffX1 = self._restrictValue(range.rangeX1, self.diffX1 + e.deltaX);
            self.bindBlock1();
          }
        });
        this.gesToken1 = _gesTokenObj.token;
      }
    },
    bindBlock2: function bindBlock2() {
      var self = this;

      // 如果禁用，不行进行表达式绑定
      if (self.disabled) {
        _indexWeex2.default.unbind({
          token: this.gesToken2,
          eventType: 'pan'
        });
        this.gesToken2 = 0;
        return;
      }

      // 初始化按钮&条的大小范围
      var blockMax1 = 0;
      if (self.range) {
        blockMax1 = self.diffX2 - self.minDist;
      } else {
        blockMax1 = self.length;
      }

      var blockMax2 = self.length;
      var blockMin2 = self.diffX1 + self.minDist;
      var barMax2 = self.length - self.diffX1;

      var props = [{
        element: self.block2.ref,
        property: 'transform.translateX',
        expression: 'min(' + blockMax2 + ', max(x + ' + self.diffX2 + ', ' + blockMin2 + '))'
      }, {
        element: self.valueBar.ref,
        property: 'width',
        expression: 'min(' + barMax2 + ', max(0, x + ' + self.barWidth + '))'
      }];

      var gesTokenObj = _indexWeex2.default.bind({
        anchor: self.block2.ref,
        eventType: 'pan',
        props: props
      }, function (e) {
        if (e.state === 'end' || e.state === 'cancel' || e.state === 'exit') {
          var range = self.getRange();
          self.barWidth = self._restrictValue([0, self.length - self.diffX1], self.barWidth + e.deltaX);
          self.diffX2 = self._restrictValue(range.rangeX2, self.diffX2 + e.deltaX);
          self.bindBlock2();
        }
      });
      this.gesToken2 = gesTokenObj.token;
    },


    // 获取diffx1 diffx2 取值范围
    getRange: function getRange() {
      if (!this.range) {
        return {
          rangeX1: [0, this.length]
        };
      } else {
        return {
          rangeX1: [0, this.diffX2 - this.minDist],
          rangeX2: [this.diffX1 + this.minDist, this.length]
        };
      }
    },


    // 限制取值范围
    _restrictValue: function _restrictValue(range, value) {
      if (range && range.length && range.length === 2) {
        if (value < range[0]) {
          return range[0];
        } else if (value > range[1]) {
          return range[1];
        } else {
          return value;
        }
      }
    },


    // 根据x方向偏移量计算value
    _getValue: function _getValue(diffX) {
      return Math.round(diffX / this.length * (this.max - this.min) + this.min);
    },


    // 根据value和length计算x方向偏移值
    _getDiffX: function _getDiffX(value) {
      return (value - this.min) / (this.max - this.min) * this.length;
    }
  }
};

/***/ }),
/* 289 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    ref: "bar-container",
    staticClass: ["slider-bar-container"],
    style: _vm.containerStyle
  }, [_c('div', {
    staticClass: ["range-bar"],
    style: _vm.rangeBarStyle
  }, [_c('div', {
    ref: "value-bar",
    staticClass: ["value-bar"],
    style: _vm.valueBarStyle
  }, [_c('div')])]), _c('div', {
    ref: "slide-block-1",
    staticClass: ["slide-block"],
    style: _vm.blockStyle1,
    attrs: {
      "preventMoveEvent": _vm.preventMoveEvent
    },
    on: {
      "panstart": _vm.webStartHandler,
      "panmove": _vm.webMoveHandler1,
      "panend": _vm.webEndHandler,
      "touchstart": _vm.weexStartHandler1,
      "touchend": _vm.weexEndHandler,
      "horizontalpan": _vm.weexHandler1
    }
  }, [_c('div')]), (_vm.range) ? _c('div', {
    ref: "slide-block-2",
    staticClass: ["slide-block"],
    style: _vm.blockStyle2,
    attrs: {
      "preventMoveEvent": _vm.preventMoveEvent
    },
    on: {
      "panstart": _vm.webStartHandler,
      "panmove": _vm.webMoveHandler2,
      "panend": _vm.webEndHandler,
      "touchstart": _vm.weexStartHandler2,
      "touchend": _vm.weexEndHandler,
      "horizontalpan": _vm.weexHandler2
    }
  }, [_c('div')]) : _vm._e()])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(291);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(292)
)

/* script */
__vue_exports__ = __webpack_require__(293)

/* template */
var __vue_template__ = __webpack_require__(294)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-special-rich-text\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-7a14a914"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 292 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-special-rich-text": {
    "position": "relative"
  },
  "tag-div": {
    "position": "absolute",
    "top": 0,
    "color": "#A5A5A5",
    "fontSize": "24",
    "lineHeight": "30"
  },
  "wxc-text": {
    "fontSize": "24",
    "lineHeight": "34",
    "color": "#3d3d3d",
    "lines": 2,
    "textOverflow": "ellipsis",
    "overflow": "hidden"
  },
  "black": {
    "color": "#3D3D3D"
  },
  "yellow": {
    "color": "#EE9900"
  },
  "blue": {
    "color": "#30A0FF"
  },
  "gray": {
    "color": "#A5A5A5"
  },
  "red": {
    "color": "#FF5000"
  },
  "margin-text": {
    "marginRight": "6"
  }
}

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

var _wxcRichTextText = __webpack_require__(30);

var _wxcRichTextText2 = _interopRequireDefault(_wxcRichTextText);

var _wxcRichTextTag = __webpack_require__(61);

var _wxcRichTextTag2 = _interopRequireDefault(_wxcRichTextTag);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _weex$config$env = weex.config.env,
    appName = _weex$config$env.appName,
    osName = _weex$config$env.osName,
    deviceWidth = _weex$config$env.deviceWidth;

var needHack = (_utils2.default.env.isWeb() || appName === 'UC' || appName === 'TUnionSDK') && osName !== 'iOS' || _utils2.default.env.isAndroid();
var isPad = osName === 'iOS' && deviceWidth > 1300;

exports.default = {
  components: {
    WxcRichTextText: _wxcRichTextText2.default,
    WxcRichTextTag: _wxcRichTextTag2.default
  },
  props: {
    configList: {
      type: [Array, String],
      default: function _default() {
        return {};
      }
    }
  },
  data: function data() {
    return {
      iconWidth: 90,
      iconHeight: 24,
      needHack: needHack
    };
  },
  computed: {
    newList: function newList() {
      var configList = this.configList,
          iconHeight = this.iconHeight,
          iconWidth = this.iconWidth,
          needHack = this.needHack;

      if (_utils2.default.isNonEmptyArray(configList) && configList.length === 2) {
        var r1 = configList[0];
        var r2 = configList[1];
        var iconStyle = r1.style;
        var textStyle = r2.style;
        var style = {};
        var fontSize = 24;
        var tagWidth = iconStyle && iconStyle.width ? iconStyle.width : 24;

        if (textStyle && textStyle.fontSize && !isNaN(textStyle.fontSize)) {
          fontSize = textStyle.fontSize;
          style = {
            fontSize: textStyle.fontSize + 'px',
            lineHeight: Number(textStyle.fontSize * 1.4).toFixed(2) + 'px'
          };
        }

        if (textStyle && textStyle.color) {
          style = _extends({}, style, {
            color: textStyle.color
          });
        }

        if (textStyle && textStyle.lines) {
          style = _extends({}, style, {
            lines: textStyle.lines
          });
        }

        if (r1.type === 'icon' && iconStyle && iconStyle.height && !iconStyle.width) {
          tagWidth = parseInt(iconWidth * (iconStyle.height / iconHeight));
          r1 = _extends({}, r1, {
            style: {
              width: tagWidth + 'px',
              height: iconStyle.height + 'px'
            }
          });
        }

        if (r1.type === 'icon' && !(iconStyle && iconStyle.height)) {
          r1 = _extends({}, r1, {
            style: {
              width: iconWidth + 'px',
              height: iconHeight + 'px'
            }
          });
        }

        if (r1.type === 'tag' && iconStyle && iconStyle.width) {
          r1 = _extends({}, r1, {
            style: _extends({}, iconStyle, { width: null })
          });
        }

        var blank = '';
        var num = Math.ceil(tagWidth / fontSize) + 1;

        if (r1.type === 'tag' && r1.value) {
          num = this.countString(r1.value);
        }

        var tagMoreBlank = (!isPad && num < 7 ? '  ' : '') + (needHack ? '  ' : '') + (isPad && num < 3 ? '    ' : '');
        var iconMoreBlank = num > 2 ? needHack ? '     ' : '   ' : ' ';
        if (r1.type === 'tag') {
          blank = new Array(num).join('  ') + tagMoreBlank;
        } else if (r1.type === 'icon') {
          blank = new Array(num).join('  ') + iconMoreBlank;
        }
        blank += isPad && num > 2 ? '     ' : '';
        var newValue = r2.value ? blank + (' ' + r2.value) : '';

        r2 = _extends({}, r2, {
          style: style,
          value: newValue
        });

        return [r1, r2];
      } else {
        return configList;
      }
    },
    top: function top() {
      var configList = this.configList,
          needHack = this.needHack;

      if (_utils2.default.isNonEmptyArray(configList) && configList.length === 2) {
        var iconStyle = configList[0].style;
        var textStyle = configList[1].style;
        var fontSize = 24;
        var tagHeight = iconStyle && iconStyle.height ? iconStyle.height : 26;
        if (textStyle && textStyle.fontSize) {
          fontSize = textStyle.fontSize;
        }
        var d = needHack ? 1.1 : 1.4;
        return Math.ceil((fontSize * d - tagHeight) / 2);
      } else {
        return 0;
      }
    }
  },
  methods: {
    onLoad: function onLoad(e) {
      if (e.success && e.size && e.size.naturalWidth > 0) {
        var _e$size = e.size,
            naturalWidth = _e$size.naturalWidth,
            naturalHeight = _e$size.naturalHeight;

        this.iconWidth = naturalWidth;
        this.iconHeight = naturalHeight;
      } else {
        var configList = this.configList;

        if (_utils2.default.isNonEmptyArray(configList) && configList.length === 2) {
          var style = configList[0].style;

          if (style && style.height && style.width) {
            this.iconWidth = style.width;
            this.iconHeight = style.height;
          }
        }
      }
    },
    countString: function countString(str) {
      var chineseRegex = /[^ -~]/g;
      return str.replace(chineseRegex, '**').length;
    }
  }
};

/***/ }),
/* 294 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["wxc-special-rich-text"],
    on: {
      "click": function($event) {
        _vm.$emit('wxcSpecialRichTextClick')
      }
    }
  }, [_c('div', {
    staticClass: ["tag-div"],
    style: Object.assign({
      top: _vm.top + 'px'
    }, _vm.newList[0].tagDivStyle)
  }, [(_vm.newList[0] && _vm.newList[0].type === 'icon' && _vm.newList[0].src) ? _c('image', {
    staticClass: ["wxc-image"],
    style: _vm.newList[0].style,
    attrs: {
      "src": _vm.newList[0].src,
      "quality": "original",
      "original": true,
      "ariaHidden": true
    },
    on: {
      "load": _vm.onLoad
    }
  }) : _vm._e(), (_vm.newList[0] && _vm.newList[0].type === 'tag' && _vm.newList[0].value) ? _c('wxc-rich-text-tag', {
    attrs: {
      "tagValue": _vm.newList[0].value,
      "tagTheme": _vm.newList[0].theme,
      "tagStyle": _vm.newList[0].style
    }
  }) : _vm._e()], 1), (_vm.newList[0] && _vm.newList[0].type === 'text' && _vm.newList[0].value) ? _c('text', {
    class: ['wxc-text', _vm.newList[0].theme],
    style: _vm.newList[0].style
  }, [_vm._v(_vm._s(_vm.newList[0].value))]) : _vm._e(), (_vm.newList[1] && _vm.newList[1].value) ? _c('text', {
    class: ['wxc-text', _vm.newList[1].theme],
    style: _vm.newList[1].style
  }, [_vm._v(_vm._s(_vm.newList[1].value))]) : _vm._e()])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(296);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(297)
)

/* script */
__vue_exports__ = __webpack_require__(298)

/* template */
var __vue_template__ = __webpack_require__(299)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-stepper\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-53770b9d"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 297 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-stepper": {
    "flexDirection": "row"
  },
  "stepper-plus": {
    "width": "56",
    "height": "56",
    "backgroundColor": "#ededed",
    "alignItems": "center",
    "justifyContent": "center",
    "borderRadius": "6"
  },
  "stepper-minus": {
    "width": "56",
    "height": "56",
    "backgroundColor": "#ededed",
    "alignItems": "center",
    "justifyContent": "center",
    "borderRadius": "6"
  },
  "stepper-input": {
    "borderWidth": 0,
    "textAlign": "center",
    "color": "#3d3d3d",
    "fontSize": "30",
    "lineHeight": "56",
    "height": "56",
    "width": "86"
  },
  "stepper-icon": {
    "fontSize": "36",
    "color": "#666666",
    "marginTop": "-4"
  }
}

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  props: {
    min: {
      type: [String, Number],
      default: 1
    },
    max: {
      type: [String, Number],
      default: 100
    },
    step: {
      type: [String, Number],
      default: 1
    },
    disabled: {
      type: Boolean,
      default: false
    },
    defaultValue: {
      type: [String, Number],
      default: 1
    },
    readOnly: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    disableStyle: function disableStyle() {
      if (this.disabled) {
        return {
          color: '#cccccc'
        };
      }
    },
    valueString: function valueString() {
      return this.value.toString();
    }
  },
  data: function data() {
    return {
      value: 1,
      isLess: false,
      isOver: false
    };
  },
  watch: {
    defaultValue: function defaultValue(newNum) {
      this.value = newNum;
    }
  },
  created: function created() {
    this.value = parseInt(this.defaultValue, 10);
    if (this.disabled) {
      this.isLess = true;
      this.isOver = true;
    }
  },

  methods: {
    minusClicked: function minusClicked() {
      if (this.disabled) {
        return;
      }
      var isMinOver = this.value <= this.min;
      var nowNum = this.value - parseInt(this.step, 10);
      if (isMinOver) {
        this.$emit('wxcStepperValueIsMinOver', { value: this.value });
      } else {
        this.value = nowNum;
        this.resetDisabledStyle();
      }
      // 由于此处已经减step
      if (nowNum <= this.min) {
        this.value = parseInt(this.min, 10);
        this.isLess = true;
      }
      this.$emit('wxcStepperValueChanged', { value: this.value });
    },
    plusClicked: function plusClicked() {
      if (this.disabled) {
        return;
      }
      var isMaxOver = this.value >= this.max;
      var nowNum = this.value + parseInt(this.step, 10);
      if (isMaxOver) {
        this.$emit('wxcStepperValueIsMaxOver', { value: this.value });
      } else {
        this.value = nowNum;
        this.resetDisabledStyle();
      }
      // 由于此处已经加step
      if (nowNum >= this.max) {
        this.value = parseInt(this.max, 10);
        this.isOver = true;
      }
      this.$emit('wxcStepperValueChanged', { value: this.value });
    },
    onInput: function onInput(e) {
      this.correctInputValue(e.value);
    },
    onBlur: function onBlur(e) {
      this.correctInputValue(e.value);
    },
    correctInputValue: function correctInputValue(v) {
      var _this = this;

      var lastValue = this.value;
      if (/^[1-9]\d{0,}$/.test(v) && parseInt(v, 10) >= this.min && parseInt(v, 10) <= this.max) {
        this.value = parseInt(v, 10);
      } else {
        this.value = '';
        setTimeout(function () {
          _this.value = lastValue;
        }, 1);
      }
      this.$emit('wxcStepperValueChanged', { value: this.value });
    },
    resetDisabledStyle: function resetDisabledStyle() {
      this.isLess = false;
      this.isOver = false;
    }
  }
};

/***/ }),
/* 299 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["wxc-stepper"]
  }, [_c('div', {
    staticClass: ["stepper-minus"],
    attrs: {
      "ariaLabel": "减数",
      "accessible": true
    },
    on: {
      "click": _vm.minusClicked
    }
  }, [_c('text', {
    staticClass: ["stepper-icon"],
    style: {
      color: _vm.isLess ? '#cccccc' : '#666666'
    }
  }, [_vm._v("-")])]), _c('input', {
    staticClass: ["stepper-input"],
    style: _vm.disableStyle,
    attrs: {
      "type": "number",
      "value": _vm.valueString,
      "disabled": _vm.disabled || _vm.readOnly
    },
    on: {
      "input": _vm.onInput,
      "blur": _vm.onBlur
    }
  }), _c('div', {
    staticClass: ["stepper-plus"],
    attrs: {
      "ariaLabel": "加数",
      "accessible": true
    },
    on: {
      "click": _vm.plusClicked
    }
  }, [_c('text', {
    staticClass: ["stepper-icon"],
    style: {
      color: _vm.isOver ? '#cccccc' : '#666666'
    }
  }, [_vm._v("+")])])])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(301);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(302)
)

/* script */
__vue_exports__ = __webpack_require__(303)

/* template */
var __vue_template__ = __webpack_require__(304)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-swipe-action\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-e7d35e8e"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 302 */
/***/ (function(module, exports) {

module.exports = {
  "container": {
    "backgroundColor": "#dddddd",
    "borderTopWidth": "1",
    "borderTopColor": "#dddddd"
  },
  "border": {
    "borderBottomWidth": "1",
    "borderBottomColor": "#dddddd"
  },
  "wxc-skid": {
    "flexDirection": "row",
    "backgroundColor": "#FFFFFF"
  },
  "swipe-action-right": {
    "flexDirection": "row",
    "alignItems": "center"
  },
  "swipe-action-center": {
    "width": "750"
  },
  "swipe-action-child": {
    "width": "100",
    "textAlign": "center",
    "color": "#FFFFFF",
    "backgroundColor": "#dddddd",
    "lineHeight": "90"
  },
  "swipe-action-text": {
    "fontSize": "30"
  }
}

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _indexWeex = __webpack_require__(4);

var _indexWeex2 = _interopRequireDefault(_indexWeex);

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var animation = weex.requireModule("animation"); //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  props: {
    data: {
      type: Array,
      default: []
    },
    height: {
      type: Number,
      default: 90
    },
    styles: {
      type: Object,
      default: {}
    }
  },
  data: function data() {
    return {
      mobileX: 0,
      webStarX: 0,
      saveIdx: null,
      isAndroid: _utils2.default.env.isAndroid()
    };
  },

  methods: {
    special: function special(dom, styles) {
      animation.transition(dom, {
        styles: styles,
        duration: 200, //ms
        timingFunction: "ease",
        delay: 100 //ms
      });
    },
    onRightNode: function onRightNode(pNode, node, i) {
      node.onPress();
      if (pNode.autoClose) this.special(this.$refs.skid[i], {
        transform: "translate(0, 0)"
      });
    },
    onNodeClick: function onNodeClick(node, i) {
      if (this.mobileX < 0) {
        this.mobileX = 0;
        this.special(this.$refs.skid[this.saveIdx], {
          transform: "translate(0, 0)"
        });
        this.isAndroid && this.special(this.$refs.skid[i], {
          transform: "translate(0, 0)"
        });
      } else {
        this.$emit("onNodeClick", node, i);
      }
    },
    onPanEnd: function onPanEnd(e, node, i) {
      if (_utils2.default.env.isWeb()) {
        var webEndX = e.changedTouches[0].pageX;
        this.movingDistance(webEndX - this.webStarX, node, this.$refs.skid[i]);
      }
    },

    onPanStart: function onPanStart(e, node, i) {
      var saveIdx = this.saveIdx;

      if (saveIdx !== i && saveIdx !== null && this.$refs.skid[saveIdx]) {
        this.special(this.$refs.skid[saveIdx], {
          transform: "translate(0, 0)"
        });
        this.mobileX = 0;
      }
      this.saveIdx = i;
      !_utils2.default.env.isWeb() ? this.mobile(e, node, i) : this.web(e, node, i);
      e.stopPropagation();
    },
    web: function web(e, node, i) {
      this.webStarX = e.changedTouches[0].pageX;
    },
    mobile: function mobile(e, node, i) {
      var _this = this;

      var el = this.$refs["skid"][i];
      _indexWeex2.default.bind({
        anchor: el.ref,
        eventType: "pan",
        props: [{
          element: el.ref,
          property: "transform.translateX",
          expression: "x+" + (this.isAndroid ? 0 : this.mobileX)
        }]
      }, function (e) {
        var state = e.state,
            deltaX = e.deltaX;

        if (state === "end") {
          _this.mobileX += deltaX;
          _this.movingDistance(_this.mobileX, node, el);
        }
      });
    },
    movingDistance: function movingDistance(scope, node, el) {
      var len = node.right ? node.right.length : 0;
      var distance = len * -100;
      if (scope < -30) {
        this.special(el, {
          transform: "translate(" + distance + "px, 0)"
        });
        this.mobileX = distance;
      } else {
        this.special(el, {
          transform: "translate(0, 0)"
        });
        this.mobileX = 0;
      }
    }
  }
};

/***/ }),
/* 304 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["container"]
  }, _vm._l((_vm.data), function(item, i) {
    return _c('div', {
      key: 'skid-' + i,
      ref: "skid",
      refInFor: true,
      staticClass: ["wxc-skid"],
      style: {
        width: (750 + item.right.length * 100) + 'px',
        height: _vm.height + 'px'
      },
      on: {
        "click": function($event) {
          _vm.onNodeClick(item, i)
        },
        "touchstart": function (e) { return !_vm.isAndroid && _vm.onPanStart(e, item, i); },
        "horizontalpan": function (e) { return _vm.isAndroid && _vm.onPanStart(e, item, i); },
        "touchend": function (e) { return _vm.onPanEnd(e, item, i); }
      }
    }, [_c('div', {
      staticClass: ["swipe-action-center", "border"],
      style: _vm.styles
    }, [_vm._t("default", null, {
      val: {
        item: item,
        index: i
      }
    })], 2), _c('div', {
      staticClass: ["swipe-action-right"]
    }, _vm._l((item.right), function(child, childIdx) {
      return _c('text', {
        key: 'child-' + childIdx,
        staticClass: ["swipe-action-child", "swipe-action-text"],
        style: Object.assign({
          lineHeight: _vm.height + 'px'
        }, child.style || {}),
        on: {
          "click": function($event) {
            _vm.onRightNode(item, child, i)
          }
        }
      }, [_vm._v(_vm._s(child.text))])
    }))])
  }))
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(306);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(307)
)

/* script */
__vue_exports__ = __webpack_require__(308)

/* template */
var __vue_template__ = __webpack_require__(309)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-tab-bar\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-dc8303b2"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 307 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-tab-page": {
    "position": "absolute",
    "top": 0,
    "left": 0,
    "right": 0,
    "bottom": 0
  },
  "tab-title-list": {
    "flexDirection": "row",
    "justifyContent": "space-around"
  },
  "title-item": {
    "justifyContent": "center",
    "alignItems": "center",
    "borderBottomStyle": "solid"
  },
  "tab-page-wrap": {
    "width": "750",
    "flex": 1
  },
  "tab-container": {
    "flex": 1,
    "flexDirection": "row",
    "position": "absolute"
  },
  "tab-text": {
    "lines": 1,
    "textOverflow": "ellipsis"
  },
  "desc-tag": {
    "position": "absolute",
    "top": "10",
    "right": "20",
    "borderBottomRightRadius": "14",
    "borderBottomLeftRadius": 0,
    "borderTopLeftRadius": "14",
    "borderTopRightRadius": "14",
    "backgroundColor": "#FF5E00",
    "height": "26",
    "alignItems": "center",
    "justifyContent": "center",
    "paddingLeft": "6",
    "paddingRight": "6"
  },
  "dot": {
    "width": "12",
    "height": "12",
    "borderBottomRightRadius": "12",
    "borderBottomLeftRadius": "12",
    "borderTopLeftRadius": "12",
    "borderTopRightRadius": "12",
    "position": "absolute",
    "top": "10",
    "right": "40",
    "backgroundColor": "#FF5E00"
  },
  "desc-text": {
    "fontSize": "18",
    "color": "#ffffff"
  }
}

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var dom = weex.requireModule('dom');
var animation = weex.requireModule('animation');
exports.default = {
  props: {
    tabTitles: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    tabStyles: {
      type: Object,
      default: function _default() {
        return {
          bgColor: '#FFFFFF',
          titleColor: '#666666',
          activeTitleColor: '#3D3D3D',
          activeBgColor: '#FFFFFF',
          isActiveTitleBold: true,
          iconWidth: 70,
          iconHeight: 70,
          width: 160,
          height: 120,
          fontSize: 24,
          activeBottomColor: '#FFC900',
          activeBottomWidth: 120,
          activeBottomHeight: 6,
          textPaddingLeft: 10,
          textPaddingRight: 10
        };
      }
    },
    titleType: {
      type: String,
      default: 'icon'
    },
    titleUseSlot: {
      type: Boolean,
      default: false
    },
    isTabView: {
      type: Boolean,
      default: true
    },
    supportXBar: {
      type: Boolean,
      default: true
    },
    duration: {
      type: [Number, String],
      default: 300
    },
    timingFunction: {
      type: String,
      default: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
    },
    wrapBgColor: {
      type: String,
      default: '#f2f3f4'
    }
  },
  data: function data() {
    return {
      currentPage: 0,
      translateX: 0
    };
  },
  created: function created() {
    var titleType = this.titleType,
        tabStyles = this.tabStyles,
        supportXBar = this.supportXBar;

    if (titleType === 'iconFont' && tabStyles.iconFontUrl) {
      dom.addRule('fontFace', {
        'fontFamily': "wxcIconFont",
        'src': 'url(\'' + tabStyles.iconFontUrl + '\')'
      });
    }
    this.isIPhoneX = _utils2.default.env.isIPhoneX() && supportXBar;
  },

  methods: {
    next: function next() {
      var page = this.currentPage;
      if (page < this.tabTitles.length - 1) {
        page++;
      }
      this.setPage(page);
    },
    prev: function prev() {
      var page = this.currentPage;
      if (page > 0) {
        page--;
      }
      this.setPage(page);
    },
    setPage: function setPage(page) {
      var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var animated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (!this.isTabView) {
        this.currentPage = page;
        this._animateTransformX(page, animated);
        this.$emit('wxcTabBarCurrentTabSelected', { page: page });
        this.jumpOut(url);
        return;
      }
      var previousPage = this.currentPage;
      var currentTabEl = this.$refs['wxc-tab-title-' + page][0];
      var width = this.tabStyles.width;

      var appearNum = parseInt(750 / width);
      var tabsNum = this.tabTitles.length;
      var offset = page > appearNum ? -(750 - width) / 2 : -width * 2;

      if (appearNum < tabsNum) {
        (previousPage > appearNum || page > 1) && dom.scrollToElement(currentTabEl, {
          offset: offset, animated: animated
        });

        page <= 1 && previousPage > page && dom.scrollToElement(currentTabEl, {
          offset: -width * page,
          animated: animated
        });
      }

      this.currentPage = page;
      this._animateTransformX(page, animated);
      this.$emit('wxcTabBarCurrentTabSelected', { page: page });
    },
    jumpOut: function jumpOut(url) {
      url && _utils2.default.goToH5Page(url);
    },
    _animateTransformX: function _animateTransformX(page, animated) {
      var duration = this.duration,
          timingFunction = this.timingFunction;

      var computedDur = animated ? duration : 0.00001;
      var containerEl = this.$refs['tab-container'];
      var dist = page * 750;
      animation.transition(containerEl, {
        styles: {
          transform: 'translateX(' + -dist + 'px)'
        },
        duration: computedDur,
        timingFunction: timingFunction,
        delay: 0
      }, function () {});
    }
  }
};

/***/ }),
/* 309 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["wxc-tab-page"],
    style: {
      backgroundColor: _vm.wrapBgColor
    }
  }, [_c('div', {
    ref: "tab-page-wrap",
    staticClass: ["tab-page-wrap"]
  }, [_c('div', {
    ref: "tab-container",
    staticClass: ["tab-container"]
  }, [_vm._t("default")], 2)]), _c('div', {
    staticClass: ["tab-title-list"],
    style: {
      backgroundColor: _vm.tabStyles.bgColor,
      height: (_vm.tabStyles.height + (_vm.isIPhoneX ? 78 : 0)) + 'px',
      paddingBottom: _vm.isIPhoneX ? '78px' : '0'
    }
  }, _vm._l((_vm.tabTitles), function(v, index) {
    return _c('div', {
      key: index,
      ref: 'wxc-tab-title-' + index,
      refInFor: true,
      staticClass: ["title-item"],
      style: {
        width: _vm.tabStyles.width + 'px',
        height: _vm.tabStyles.height + 'px',
        backgroundColor: _vm.currentPage == index ? _vm.tabStyles.activeBgColor : _vm.tabStyles.bgColor
      },
      attrs: {
        "accessible": true,
        "ariaLabel": ("" + (v.title?v.title:'标签'+index))
      },
      on: {
        "click": function($event) {
          _vm.setPage(index, v.url)
        }
      }
    }, [(_vm.titleType === 'icon' && !_vm.titleUseSlot) ? _c('image', {
      style: {
        width: _vm.tabStyles.iconWidth + 'px',
        height: _vm.tabStyles.iconHeight + 'px'
      },
      attrs: {
        "src": _vm.currentPage == index ? v.activeIcon : v.icon
      }
    }) : _vm._e(), (_vm.titleType === 'iconFont' && v.codePoint && !_vm.titleUseSlot) ? _c('text', {
      style: {
        fontFamily: 'wxcIconFont',
        fontSize: _vm.tabStyles.iconFontSize + 'px',
        marginBottom: _vm.tabStyles.iconFontMarginBottom ? (_vm.tabStyles.iconFontMarginBottom + 'px') : '8px',
        color: _vm.currentPage == index ? _vm.tabStyles.activeIconFontColor : _vm.tabStyles.iconFontColor
      }
    }, [_vm._v(_vm._s(v.codePoint))]) : _vm._e(), (!_vm.titleUseSlot) ? _c('text', {
      staticClass: ["tab-text"],
      style: {
        fontSize: _vm.tabStyles.fontSize + 'px',
        fontWeight: (_vm.currentPage == index && _vm.tabStyles.isActiveTitleBold) ? 'bold' : 'normal',
        color: _vm.currentPage == index ? _vm.tabStyles.activeTitleColor : _vm.tabStyles.titleColor,
        paddingLeft: _vm.tabStyles.textPaddingLeft + 'px',
        paddingRight: _vm.tabStyles.textPaddingRight + 'px'
      }
    }, [_vm._v(_vm._s(v.title))]) : _vm._e(), (v.badge && !_vm.titleUseSlot) ? _c('div', {
      staticClass: ["desc-tag"]
    }, [_c('text', {
      staticClass: ["desc-text"]
    }, [_vm._v(_vm._s(v.badge))])]) : _vm._e(), (v.dot && !v.badge && !_vm.titleUseSlot) ? _c('div', {
      staticClass: ["dot"]
    }) : _vm._e(), (_vm.titleUseSlot) ? _vm._t(("tab-title-" + index)) : _vm._e()], 2)
  }))])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(311);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(312)
)

/* script */
__vue_exports__ = __webpack_require__(313)

/* template */
var __vue_template__ = __webpack_require__(314)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-tab-page\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-57f519d7"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 312 */
/***/ (function(module, exports) {

module.exports = {
  "wxc-tab-page": {
    "width": "750"
  },
  "tab-title-list": {
    "flexDirection": "row"
  },
  "title-item": {
    "justifyContent": "center",
    "alignItems": "center",
    "borderBottomStyle": "solid"
  },
  "border-bottom": {
    "position": "absolute",
    "bottom": 0
  },
  "tab-page-wrap": {
    "width": "750"
  },
  "tab-container": {
    "flex": 1,
    "flexDirection": "row",
    "position": "absolute"
  },
  "tab-text": {
    "lines": 1,
    "textOverflow": "ellipsis"
  },
  "rightIcon": {
    "position": "fixed",
    "backgroundColor": "#ffffff",
    "boxShadow": "-50px 0 20px #ffffff"
  }
}

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(0);

var _utils2 = _interopRequireDefault(_utils);

var _bindEnv = __webpack_require__(5);

var _bindEnv2 = _interopRequireDefault(_bindEnv);

var _indexWeex = __webpack_require__(4);

var _indexWeex2 = _interopRequireDefault(_indexWeex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var dom = weex.requireModule('dom');
var animation = weex.requireModule('animation');
var swipeBack = weex.requireModule('swipeBack');

exports.default = {
  props: {
    tabTitles: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    panDist: {
      type: Number,
      default: 200
    },
    spmC: {
      type: [String, Number],
      default: ''
    },
    titleUseSlot: {
      type: Boolean,
      default: false
    },
    tabStyles: {
      type: Object,
      default: function _default() {
        return {
          bgColor: '#FFFFFF',
          titleColor: '#666666',
          activeTitleColor: '#3D3D3D',
          activeBgColor: '#FFFFFF',
          isActiveTitleBold: true,
          iconWidth: 70,
          iconHeight: 70,
          width: 160,
          height: 120,
          fontSize: 24,
          hasActiveBottom: true,
          activeBottomColor: '#FFC900',
          activeBottomWidth: 120,
          activeBottomHeight: 6,
          textPaddingLeft: 10,
          textPaddingRight: 10,
          leftOffset: 0,
          rightOffset: 0,
          normalBottomColor: '#F2F2F2',
          normalBottomHeight: 0,
          hasRightIcon: false
        };
      }
    },
    titleType: {
      type: String,
      default: 'icon'
    },
    tabPageHeight: {
      type: [String, Number],
      default: 1334
    },
    needSlider: {
      type: Boolean,
      default: true
    },
    isTabView: {
      type: Boolean,
      default: true
    },
    duration: {
      type: [Number, String],
      default: 300
    },
    timingFunction: {
      type: String,
      default: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
    },
    wrapBgColor: {
      type: String,
      default: '#f2f3f4'
    },
    clickAnimation: {
      type: Boolean,
      default: true
    },
    rightIconStyle: {
      type: Object,
      default: function _default() {
        return {
          top: 0,
          right: 0,
          paddingLeft: 20,
          paddingRight: 20
        };
      }
    }
  },
  data: function data() {
    return {
      currentPage: 0,
      gesToken: 0,
      isMoving: false,
      startTime: 0,
      deltaX: 0,
      translateX: 0
    };
  },
  created: function created() {
    var titleType = this.titleType,
        tabStyles = this.tabStyles;

    if (titleType === 'iconFont' && tabStyles.iconFontUrl) {
      dom.addRule('fontFace', {
        'fontFamily': 'wxcIconFont',
        'src': 'url(' + tabStyles.iconFontUrl + ')'
      });
    }
  },
  mounted: function mounted() {
    if (swipeBack && swipeBack.forbidSwipeBack) {
      swipeBack.forbidSwipeBack(true);
    }
    if (_bindEnv2.default.supportsEBForIos() && this.isTabView && this.needSlider) {
      var tabPageEl = this.$refs['tab-page-wrap'];
      _indexWeex2.default.prepare && _indexWeex2.default.prepare({
        anchor: tabPageEl.ref,
        eventType: 'pan'
      });
    }
  },

  methods: {
    next: function next() {
      var page = this.currentPage;
      if (page < this.tabTitles.length - 1) {
        page++;
      }
      this.setPage(page);
    },
    prev: function prev() {
      var page = this.currentPage;
      if (page > 0) {
        page--;
      }
      this.setPage(page);
    },
    startHandler: function startHandler() {
      if (_bindEnv2.default.supportsEBForIos() && this.isTabView && this.needSlider) {
        this.bindExp(this.$refs['tab-page-wrap']);
      }
    },
    bindExp: function bindExp(element) {
      var _this = this;

      if (element && element.ref) {
        if (this.isMoving && this.gesToken !== 0) {
          _indexWeex2.default.unbind({
            eventType: 'pan',
            token: this.gesToken
          });
          this.gesToken = 0;
          return;
        }

        var tabElement = this.$refs['tab-container'];
        var currentPage = this.currentPage,
            panDist = this.panDist;

        var dist = currentPage * 750;

        // x-dist
        var props = [{
          element: tabElement.ref,
          property: 'transform.translateX',
          expression: 'x-' + dist
        }];

        var gesTokenObj = _indexWeex2.default.bind({
          anchor: element.ref,
          eventType: 'pan',
          props: props
        }, function (e) {
          var deltaX = e.deltaX,
              state = e.state;

          if (state === 'end') {
            if (deltaX < -panDist) {
              _this.next();
            } else if (deltaX > panDist) {
              _this.prev();
            } else {
              _this.setPage(currentPage);
            }
          }
        });
        this.gesToken = gesTokenObj.token;
      }
    },
    setPage: function setPage(page) {
      var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var animated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (!this.isTabView) {
        this.jumpOut(url);
        return;
      }
      if (this.isMoving === true) {
        return;
      }
      this.isMoving = true;
      var previousPage = this.currentPage;
      var currentTabEl = this.$refs['wxc-tab-title-' + page][0];
      var width = this.tabStyles.width;

      var appearNum = parseInt(750 / width);
      var tabsNum = this.tabTitles.length;
      var offset = page > appearNum ? -(750 - width) / 2 : -width * 2;

      if (appearNum < tabsNum) {
        (previousPage > appearNum || page > 1) && dom.scrollToElement(currentTabEl, {
          offset: offset, animated: animated
        });

        page <= 1 && previousPage > page && dom.scrollToElement(currentTabEl, {
          offset: -width * page,
          animated: animated
        });
      }

      this.isMoving = false;
      this.currentPage = page;
      this._animateTransformX(page, animated);
      this.$emit('wxcTabPageCurrentTabSelected', { page: page });
    },
    jumpOut: function jumpOut(url) {
      url && _utils2.default.goToH5Page(url);
    },
    _animateTransformX: function _animateTransformX(page, animated) {
      var duration = this.duration,
          timingFunction = this.timingFunction;

      var computedDur = animated ? duration : 0.00001;
      var containerEl = this.$refs['tab-container'];
      var dist = page * 750;
      animation.transition(containerEl, {
        styles: {
          transform: 'translateX(' + -dist + 'px)'
        },
        duration: computedDur,
        timingFunction: timingFunction,
        delay: 0
      }, function () {});
    }
  }
};

/***/ }),
/* 314 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["wxc-tab-page"],
    style: {
      height: (_vm.tabPageHeight) + 'px',
      backgroundColor: _vm.wrapBgColor
    }
  }, [_c('scroller', {
    ref: "tab-title-list",
    staticClass: ["tab-title-list"],
    style: {
      backgroundColor: _vm.tabStyles.bgColor,
      height: (_vm.tabStyles.height) + 'px',
      paddingLeft: (_vm.tabStyles.leftOffset ? _vm.tabStyles.leftOffset : 0) + 'px',
      paddingRight: _vm.tabStyles.rightOffset
    },
    attrs: {
      "showScrollbar": false,
      "scrollDirection": "horizontal",
      "dataSpm": _vm.spmC
    }
  }, [_vm._l((_vm.tabTitles), function(v, index) {
    return _c('div', {
      key: index,
      ref: 'wxc-tab-title-' + index,
      refInFor: true,
      staticClass: ["title-item"],
      style: {
        width: _vm.tabStyles.width + 'px',
        height: _vm.tabStyles.height + 'px',
        backgroundColor: _vm.currentPage === index ? _vm.tabStyles.activeBgColor : _vm.tabStyles.bgColor,
        borderBottomWidth: _vm.tabStyles.normalBottomHeight,
        borderBottomColor: _vm.tabStyles.normalBottomColor
      },
      attrs: {
        "accessible": true,
        "ariaLabel": ("" + (v.title?v.title:'标签'+index))
      },
      on: {
        "click": function($event) {
          _vm.setPage(index, v.url, _vm.clickAnimation)
        }
      }
    }, [(_vm.titleType === 'icon' && !_vm.titleUseSlot) ? _c('image', {
      style: {
        width: _vm.tabStyles.iconWidth + 'px',
        height: _vm.tabStyles.iconHeight + 'px'
      },
      attrs: {
        "src": _vm.currentPage === index ? v.activeIcon : v.icon
      }
    }) : _vm._e(), (_vm.titleType === 'iconFont' && v.codePoint && !_vm.titleUseSlot) ? _c('text', {
      staticClass: ["icon-font"],
      style: {
        fontFamily: 'wxcIconFont',
        fontSize: _vm.tabStyles.iconFontSize + 'px',
        color: _vm.currentPage === index ? _vm.tabStyles.activeIconFontColor : _vm.tabStyles.iconFontColor
      }
    }, [_vm._v(_vm._s(v.codePoint))]) : _vm._e(), (!_vm.titleUseSlot) ? _c('text', {
      staticClass: ["tab-text"],
      style: {
        fontSize: _vm.tabStyles.fontSize + 'px',
        fontWeight: (_vm.currentPage === index && _vm.tabStyles.isActiveTitleBold) ? 'bold' : 'normal',
        color: _vm.currentPage === index ? _vm.tabStyles.activeTitleColor : _vm.tabStyles.titleColor,
        paddingLeft: (_vm.tabStyles.textPaddingLeft ? _vm.tabStyles.textPaddingLeft : 10) + 'px',
        paddingRight: (_vm.tabStyles.textPaddingRight ? _vm.tabStyles.textPaddingRight : 10) + 'px'
      }
    }, [_vm._v(_vm._s(v.title))]) : _vm._e(), (_vm.tabStyles.hasActiveBottom && !_vm.titleUseSlot) ? _c('div', {
      staticClass: ["border-bottom"],
      style: {
        width: _vm.tabStyles.activeBottomWidth + 'px',
        left: (_vm.tabStyles.width - _vm.tabStyles.activeBottomWidth) / 2 + 'px',
        height: _vm.tabStyles.activeBottomHeight + 'px',
        backgroundColor: _vm.currentPage === index ? _vm.tabStyles.activeBottomColor : 'transparent'
      }
    }) : _vm._e(), (_vm.titleUseSlot) ? _vm._t(("tab-title-" + index)) : _vm._e()], 2)
  }), (_vm.tabStyles.hasRightIcon) ? _c('div', {
    staticClass: ["rightIcon"],
    style: {
      top: _vm.rightIconStyle.top,
      right: _vm.rightIconStyle.right,
      paddingLeft: _vm.rightIconStyle.paddingLeft,
      paddingRight: _vm.rightIconStyle.paddingRight
    }
  }, [_vm._t("rightIcon")], 2) : _vm._e()], 2), _c('div', {
    ref: "tab-page-wrap",
    staticClass: ["tab-page-wrap"],
    style: {
      height: (_vm.tabPageHeight - _vm.tabStyles.height) + 'px'
    },
    on: {
      "horizontalpan": _vm.startHandler
    }
  }, [_c('div', {
    ref: "tab-container",
    staticClass: ["tab-container"]
  }, [_vm._t("default")], 2)])])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(316);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_index).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(317)
)

/* script */
__vue_exports__ = __webpack_require__(318)

/* template */
var __vue_template__ = __webpack_require__(319)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\node_modules\\weex-ui\\packages\\wxc-tag\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-a90327b4"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 317 */
/***/ (function(module, exports) {

module.exports = {
  "tag-item": {
    "height": "24",
    "justifyContent": "center",
    "alignItems": "center",
    "paddingBottom": "2"
  },
  "tag-border": {
    "borderBottomLeftRadius": "4",
    "borderBottomRightRadius": "4",
    "borderTopLeftRadius": "4",
    "borderTopRightRadius": "4"
  },
  "tag-hollow": {
    "borderWidth": "1"
  },
  "tag-image": {
    "height": "24"
  },
  "tag-special": {
    "borderWidth": "1",
    "flexDirection": "row"
  },
  "left-image": {
    "width": "20",
    "height": "20"
  },
  "tag-left": {
    "width": "24",
    "height": "24",
    "alignItems": "center",
    "justifyContent": "center"
  },
  "tag-text": {
    "fontSize": "20",
    "height": "22",
    "lineHeight": "22",
    "paddingLeft": "6",
    "paddingRight": "6"
  }
}

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  props: {
    type: {
      type: String,
      default: 'solid'
    },
    value: {
      type: [String, Number],
      default: '测试测试'
    },
    tagColor: {
      type: String,
      default: '#ff5000'
    },
    fontColor: {
      type: String,
      default: '#333333'
    },
    specialIcon: {
      type: String,
      default: ''
    },
    img: {
      type: String,
      default: ''
    }
  },
  computed: {
    showSolid: function showSolid() {
      var type = this.type,
          value = this.value;

      return type === 'solid' && value !== '';
    },
    showHollow: function showHollow() {
      var type = this.type,
          value = this.value;

      return type === 'hollow' && value !== '';
    },
    showSpecial: function showSpecial() {
      var type = this.type,
          value = this.value,
          specialIcon = this.specialIcon;

      return type === 'special' && value !== '' && specialIcon !== '';
    },
    showImage: function showImage() {
      var type = this.type,
          img = this.img;

      return type === 'image' && img !== '';
    },
    tagTextStyle: function tagTextStyle() {
      var tagColor = this.tagColor,
          showSolid = this.showSolid;

      return showSolid ? { backgroundColor: tagColor } : { borderColor: tagColor };
    }
  },
  data: function data() {
    return {
      imgWidth: 90
    };
  },
  methods: {
    onLoad: function onLoad(e) {
      if (e.success && e.size && e.size.naturalWidth > 0) {
        var width = e.size.naturalWidth;
        var height = e.size.naturalHeight;
        this.imgWidth = width * (24 / height);
      }
    }
  }
};

/***/ }),
/* 319 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [(_vm.showSolid || _vm.showHollow) ? _c('div', {
    class: ['tag-item', 'tag-border', _vm.showHollow && 'tag-hollow'],
    style: _vm.tagTextStyle
  }, [_c('text', {
    staticClass: ["tag-text"],
    style: {
      color: _vm.fontColor
    }
  }, [_vm._v(_vm._s(_vm.value))])]) : _vm._e(), (_vm.showImage) ? _c('image', {
    staticClass: ["tag-image"],
    style: {
      width: _vm.imgWidth + 'px'
    },
    attrs: {
      "src": _vm.img,
      "ariaHidden": true
    },
    on: {
      "load": _vm.onLoad
    }
  }) : _vm._e(), (_vm.showSpecial) ? _c('div', {
    staticClass: ["tag-special", "tag-border"],
    style: {
      borderColor: _vm.tagColor
    },
    attrs: {
      "accessible": true,
      "ariaLabel": _vm.value
    }
  }, [_c('div', {
    staticClass: ["tag-left"],
    style: {
      backgroundColor: _vm.tagColor
    }
  }, [_c('image', {
    staticClass: ["left-image"],
    attrs: {
      "src": _vm.specialIcon
    }
  })]), _c('text', {
    staticClass: ["tag-text"],
    style: {
      color: _vm.fontColor
    }
  }, [_vm._v(_vm._s(_vm.value))])]) : _vm._e()])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){
var this$1 = this;
var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["wrapper"]
  }, [_c('wxc-minibar', {
    attrs: {
      "title": "登录gitee",
      "leftButton": "",
      "textColor": "while",
      "backgroundColor": "#238FFF"
    }
  }, [_c('div', {
    staticStyle: {
      width: "60px",
      height: "60px",
      justifyContent: "center",
      alignItems: "center"
    },
    attrs: {
      "slot": "left"
    },
    on: {
      "click": function () {
        this$1.$router.back()
      }
    },
    slot: "left"
  }, [_c('image', {
    staticStyle: {
      width: "40px",
      height: "40px"
    },
    attrs: {
      "src": __webpack_require__(321).default
    }
  })])]), (_vm.showWeb) ? _c('web', {
    staticClass: ["webview"],
    attrs: {
      "src": _vm.webviewUrl,
      "showLoading": "true"
    },
    on: {
      "receivedtitle": _vm.test,
      "pagestart": _vm.onLoad
    }
  }) : _c('div', {
    staticClass: ["success"]
  }, [_c('text', {
    staticStyle: {
      fontSize: "50px"
    }
  }, [_vm._v("登录成功")])])], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 321 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(323)
)

/* script */
__vue_exports__ = __webpack_require__(324)

/* template */
var __vue_template__ = __webpack_require__(381)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\src\\home.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-2fadf1e5"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 323 */
/***/ (function(module, exports) {

module.exports = {
  "item-container": {
    "width": "750",
    "backgroundColor": "#f2f3f4",
    "alignItems": "center",
    "justifyContent": "center"
  }
}

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _weexUi = __webpack_require__(3);

var _user = __webpack_require__(325);

var _user2 = _interopRequireDefault(_user);

var _search = __webpack_require__(340);

var _search2 = _interopRequireDefault(_search);

var _star = __webpack_require__(359);

var _star2 = _interopRequireDefault(_star);

var _hot = __webpack_require__(363);

var _hot2 = _interopRequireDefault(_hot);

var _events = __webpack_require__(367);

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var modal = weex.requireModule('modal');

var titles = [{
    title: '热门仓库',
    icon: __webpack_require__(371).default,
    activeIcon: __webpack_require__(372).default
}, {
    title: '事件',
    icon: __webpack_require__(373).default,
    activeIcon: __webpack_require__(374).default
}, {
    title: '我的star',
    icon: __webpack_require__(375).default,
    activeIcon: __webpack_require__(376).default
}, {
    title: '搜索',
    icon: __webpack_require__(377).default,
    activeIcon: __webpack_require__(378).default
}, {
    title: '个人信息',
    icon: __webpack_require__(379).default,
    activeIcon: __webpack_require__(380).default
}];
var styles = {
    bgColor: '#FFFFFF',
    titleColor: '#666666',
    activeTitleColor: '#3D3D3D',
    activeBgColor: '#FFFFFF',
    isActiveTitleBold: true,
    iconWidth: 45,
    iconHeight: 45,
    width: 140,
    height: 120,
    fontSize: 24,
    textPaddingLeft: 10,
    textPaddingRight: 10
};

exports.default = {
    name: "home",
    components: {
        WxcTabBar: _weexUi.WxcTabBar,
        user: _user2.default,
        search: _search2.default,
        star: _star2.default,
        hot: _hot2.default,
        events: _events2.default
    },
    created: function created() {
        var tabPageHeight = _weexUi.Utils.env.getPageHeight();
        // 如果页面没有导航栏，可以用下面这个计算高度的方法
        // const tabPageHeight = env.deviceHeight / env.deviceWidth * 750;
        var tabStyles = this.tabStyles;

        this["contentStyle"] = {
            height: tabPageHeight - tabStyles.height + 'px'
        };
    },
    data: function data() {
        return {
            tabStyles: styles,
            titles: titles
        };
    }
};

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(326)
)

/* script */
__vue_exports__ = __webpack_require__(327)

/* template */
var __vue_template__ = __webpack_require__(339)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\src\\user.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-3cc692d1"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 326 */
/***/ (function(module, exports) {

module.exports = {
  "refresh": {
    "width": "750",
    "display": "flex",
    "MsFlexAlign": "center",
    "WebkitAlignItems": "center",
    "WebkitBoxAlign": "center",
    "alignItems": "center"
  },
  "wrapper": {
    "backgroundColor": "#F5F5F5",
    "flex": 1
  },
  "head-icon": {
    "backgroundColor": "#238FFF",
    "height": "150",
    "width": "150",
    "marginTop": "25",
    "marginLeft": "30",
    "borderRadius": "10"
  },
  "head-bar": {
    "flexDirection": "row",
    "backgroundColor": "#FFFFFF",
    "height": "200",
    "borderBottomWidth": "0.5",
    "borderBottomColor": "#dddddd"
  },
  "head-bar2": {
    "paddingLeft": "80",
    "paddingRight": "80",
    "backgroundColor": "#FFFFFF",
    "height": "100",
    "flexDirection": "row",
    "justifyContent": "space-between"
  },
  "item2": {
    "borderWidth": "0.5",
    "borderColor": "#dddddd",
    "backgroundColor": "#FFFFFF",
    "alignItems": "center",
    "height": "80",
    "flexDirection": "row"
  },
  "item2-icon": {
    "width": "50",
    "height": "50",
    "borderRadius": "5",
    "marginLeft": "30"
  },
  "head-item": {
    "flexDirection": "column",
    "justifyContent": "center",
    "alignItems": "center"
  }
}

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = __webpack_require__(7);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _gitee = __webpack_require__(10);

var _gitee2 = _interopRequireDefault(_gitee);

var _contributionView = __webpack_require__(328);

var _contributionView2 = _interopRequireDefault(_contributionView);

var _weexUi = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var team = __webpack_require__(332).default;
var wechat = __webpack_require__(333).default;
var email = __webpack_require__(334).default;
var qq = __webpack_require__(335).default;
var setting = __webpack_require__(336).default;
var info = __webpack_require__(337).default;
var feedback = __webpack_require__(338).default;
var right = __webpack_require__(62).default;

exports.default = {
    name: "user",
    components: {
        WxcMinibar: _weexUi.WxcMinibar,
        contributionView: _contributionView2.default
    },
    methods: {
        onRefresh: function onRefresh() {},
        onClick: function onClick(index) {},
        onClick2: function onClick2(index) {
            if (index === 1) {
                this.$router.push('/about');
            }
        }
    },
    created: function created() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
            var info;
            return _regenerator2.default.wrap(function _callee$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            _context.next = 2;
                            return _gitee2.default.loadMyInfo();

                        case 2:
                            info = _context.sent;


                            _this.username = info['login'];
                            _this.nikeName = info['name'];
                            _this.bio = info['bio'];
                            _this.avatarIcon = info['avatar_url'];
                            _this.joinTime = new Date(info['created_at']).toLocaleDateString();
                            _this.items = [["仓库", info['public_repos']], ["关注中", info['following']], ["关注者", info['followers']]];
                            _this.items2 = [[team, info['company'] || "公司"], [wechat, info['wechat'] || "微信"], [qq, info['qq'] || "QQ"], [email, info['email'] || '邮箱']];

                            _context.next = 12;
                            return _gitee2.default.getContributions(info['login'], new Date().getFullYear());

                        case 12:
                            _this.contributions = _context.sent;

                        case 13:
                        case "end":
                            return _context.stop();
                    }
                }
            }, _callee, _this);
        }))();
    },
    data: function data() {
        return {
            contributions: [],
            rightIcon: right,
            avatarIcon: '',
            username: "username",
            nikeName: "nikeName",
            bio: "tag",
            joinTime: "111",
            items: [["仓库", 0], ["关注中", 0], ["关注者", 0]],
            items2: [[team, "组织"], [wechat, "地区"], [qq, "网站"], [email, "邮箱"]],
            items3: [[setting, "设置"], [info, "关于"], [feedback, "反馈"]]
        };
    }
};

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(329)
)

/* script */
__vue_exports__ = __webpack_require__(330)

/* template */
var __vue_template__ = __webpack_require__(331)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\src\\contributionView.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-8a61304a"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 329 */
/***/ (function(module, exports) {

module.exports = {
  "wrapper": {
    "backgroundColor": "#FFFFFF",
    "width": "750",
    "justifyContent": "center",
    "alignItems": "center",
    "height": "250"
  },
  "scroller": {
    "flexDirection": "row",
    "width": "710",
    "height": "210"
  },
  "box-group": {
    "flexDirection": "column"
  },
  "box": {
    "backgroundColor": "#eaeaea",
    "height": "25",
    "width": "25",
    "borderRadius": "2.5",
    "marginTop": "2.5",
    "marginRight": "2.5",
    "marginBottom": "2.5",
    "marginLeft": "2.5"
  }
}

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var colors = {
    less: "#eaeaea",
    little: "#D6E685",
    some: "#8CC665",
    many: "#44A340",
    much: "#1E6823"
};

function buildItems(array) {
    if (array == null) {
        return [];
    }
    var items = new Array(parseInt((array.length / 7).toString()));
    var temp = [];
    for (var i = 0; i < array.length; i++) {
        var item = array[i];
        temp.push(item);
        if (temp.length === 7 || array.length - 1 === i) {
            items.push(temp);
            temp = [];
        }
    }
    return items;
}

exports.default = {
    name: "contributionView",
    props: {
        items: {
            type: Array,
            default: function _default() {
                return [];
            }
        }
    },
    computed: {
        renderItems: function renderItems() {
            return buildItems(this.items);
        }
    },
    methods: {
        onClick: function onClick(text) {}
    },
    data: function data() {
        return {
            colors: colors
        };
    }
};

/***/ }),
/* 331 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["wrapper"]
  }, [_c('scroller', {
    staticClass: ["scroller"],
    attrs: {
      "scrollDirection": "horizontal",
      "showScrollbar": "false",
      "scrollToBegin": "true"
    }
  }, _vm._l((_vm.renderItems), function(itemGroup, index) {
    return _c('div', {
      staticClass: ["box-group"]
    }, _vm._l((itemGroup), function(box, index2) {
      return _c('div', {
        staticClass: ["box"],
        style: {
          'background-color': (_vm.colors[box.color])
        },
        on: {
          "click": function($event) {
            _vm.onClick(box[1])
          }
        }
      })
    }))
  }))])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 332 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 333 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 334 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 335 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 336 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 337 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 338 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 339 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticStyle: {
      flex: "1"
    }
  }, [_c('wxc-minibar', {
    attrs: {
      "title": "个人信息",
      "leftButton": "",
      "textColor": "black",
      "backgroundColor": "#FBFBFB"
    }
  }), _c('scroller', {
    staticClass: ["wrapper"],
    attrs: {
      "alwaysScrollableVertical": "true"
    }
  }, [_c('refresh', {
    staticClass: ["refresh"],
    on: {
      "refresh": _vm.onRefresh
    }
  }, [_c('text', {
    staticStyle: {
      fontSize: "30px"
    }
  }, [_vm._v("正在加载")]), _c('loading-indicator')]), _c('div', {
    staticClass: ["head-bar"]
  }, [_c('image', {
    staticClass: ["head-icon"],
    attrs: {
      "src": _vm.avatarIcon
    }
  }), _c('div', {
    staticStyle: {
      flexDirection: "column",
      marginTop: "15px",
      marginLeft: "25px"
    }
  }, [_c('div', {
    staticStyle: {
      flexDirection: "row",
      alignItems: "center"
    }
  }, [_c('text', {
    staticStyle: {
      fontSize: "38px",
      color: "#00B4FF"
    }
  }, [_vm._v(_vm._s(_vm.username))]), _c('text', {
    staticStyle: {
      fontSize: "38px"
    }
  }, [_vm._v(" (" + _vm._s(_vm.nikeName) + ")")])]), _c('text', {
    staticStyle: {
      fontSize: "35px",
      marginTop: "10px"
    }
  }, [_vm._v(_vm._s(_vm.bio))]), _c('text', {
    staticStyle: {
      fontSize: "30px",
      marginTop: "10px"
    }
  }, [_vm._v("于" + _vm._s(_vm.joinTime) + "加入")])])]), _c('div', {
    staticClass: ["head-bar2"]
  }, _vm._l((_vm.items), function(item) {
    return _c('div', {
      staticClass: ["head-item"]
    }, [_c('text', {
      staticStyle: {
        fontSize: "35px"
      }
    }, [_vm._v(_vm._s(item[1]))]), _c('text', {
      staticStyle: {
        fontSize: "25px"
      }
    }, [_vm._v(_vm._s(item[0]))])])
  })), _c('div', {
    staticStyle: {
      height: "30px"
    }
  }), _c('contribution-view', {
    attrs: {
      "items": _vm.contributions
    }
  }), _c('div', {
    staticStyle: {
      height: "30px"
    }
  }), _c('div', _vm._l((_vm.items2), function(item, index) {
    return _c('div', {
      staticClass: ["item2"],
      on: {
        "click": function($event) {
          _vm.onClick(index)
        }
      }
    }, [_c('image', {
      staticClass: ["item2-icon"],
      attrs: {
        "src": item[0]
      }
    }), _c('text', {
      staticStyle: {
        marginLeft: "15px",
        fontSize: "30px"
      }
    }, [_vm._v(_vm._s(item[1]))])])
  })), _c('div', {
    staticStyle: {
      height: "30px"
    }
  }), _c('div', _vm._l((_vm.items3), function(item, index) {
    return _c('div', {
      staticClass: ["item2"],
      on: {
        "click": function($event) {
          _vm.onClick2(index)
        }
      }
    }, [_c('image', {
      staticClass: ["item2-icon"],
      attrs: {
        "src": item[0]
      }
    }), _c('text', {
      staticStyle: {
        marginLeft: "15px",
        fontSize: "30px",
        flex: "1"
      }
    }, [_vm._v(_vm._s(item[1]))]), _c('image', {
      staticStyle: {
        height: "30px",
        width: "30px",
        marginRight: "20px"
      },
      attrs: {
        "src": _vm.rightIcon
      }
    })])
  }))], 1)], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(341)
)

/* script */
__vue_exports__ = __webpack_require__(342)

/* template */
var __vue_template__ = __webpack_require__(358)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\src\\search.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-49b9daa4"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 341 */
/***/ (function(module, exports) {

module.exports = {
  "list": {
    "flex": 1,
    "backgroundColor": "#F5F5F5"
  },
  "wrapper": {
    "backgroundColor": "#F5F5F5",
    "flex": 1
  },
  "top-bar": {
    "paddingTop": "5",
    "backgroundColor": "#FFFFFF",
    "justifyContent": "center",
    "alignItems": "center",
    "flexDirection": "column"
  },
  "search-box": {
    "marginTop": "5",
    "marginRight": "5",
    "marginBottom": "5",
    "marginLeft": "5"
  },
  "select-bar": {
    "flex": 1,
    "flexDirection": "row",
    "width": "750",
    "marginTop": "10",
    "marginBottom": "20",
    "justifyContent": "space-between",
    "alignItems": "center"
  },
  "right-item": {
    "flex": 1,
    "flexDirection": "row",
    "justifyContent": "flex-end",
    "height": "60",
    "alignItems": "center",
    "paddingRight": "20"
  },
  "header": {
    "backgroundColor": "#FFFFFF",
    "flexDirection": "column",
    "width": "750",
    "borderTopWidth": "0.5",
    "borderTopColor": "#dddddd",
    "borderBottomWidth": "0.5",
    "borderBottomColor": "#dddddd"
  },
  "header2": {
    "flex": 1,
    "backgroundColor": "#FFFFFF",
    "flexDirection": "row",
    "justifyContent": "space-between",
    "alignItems": "center",
    "paddingTop": "10",
    "paddingRight": "15",
    "paddingBottom": "10",
    "paddingLeft": "25"
  },
  "item": {
    "flex": 1,
    "backgroundColor": "#FFFFFF",
    "paddingLeft": "25",
    "paddingRight": "20",
    "borderTopWidth": "0.5",
    "borderTopColor": "#dddddd",
    "borderBottomWidth": "0.5",
    "borderBottomColor": "#dddddd",
    "width": "750",
    "height": "70",
    "justifyContent": "center"
  }
}

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _weexUi = __webpack_require__(3);

var _tabView = __webpack_require__(343);

var _tabView2 = _interopRequireDefault(_tabView);

var _reposList = __webpack_require__(31);

var _reposList2 = _interopRequireDefault(_reposList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var clean = __webpack_require__(356).default; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var options = __webpack_require__(357).default;

var tabStyle = {
    lineSpacing: '0px',
    width: '200px',
    height: '50px',
    icon: '',
    color: '#333333',
    checkedColor: '#ffffff',
    disabledColor: '#eeeeee',
    borderColor: '#666666',
    checkedBorderColor: '#238FFF',
    backgroundColor: '#ffffff',
    checkedBackgroundColor: '#238FFF'
};

exports.default = {
    components: {
        WxcSearchbar: _weexUi.WxcSearchbar,
        tabView: _tabView2.default,
        reposList: _reposList2.default
    },
    name: "search",
    methods: {
        onSelect: function onSelect(params) {},
        wxcSearchbarInputOnFocus: function wxcSearchbarInputOnFocus() {},
        wxcSearchbarInputOnBlur: function wxcSearchbarInputOnBlur() {},
        wxcSearchbarInputReturned: function wxcSearchbarInputReturned() {},
        wxcSearchbarCloseClicked: function wxcSearchbarCloseClicked() {},
        wxcSearchbarInputOnInput: function wxcSearchbarInputOnInput(e) {
            this.searchText = e.value;
        },
        wxcSearchbarCancelClicked: function wxcSearchbarCancelClicked() {},
        wxcSearchbarInputDisabledClicked: function wxcSearchbarInputDisabledClicked() {},
        wxcSearchbarDepChooseClicked: function wxcSearchbarDepChooseClicked() {}
    },
    data: function data() {
        return {
            optionsIcon: options,
            cleanIcon: clean,
            lang: '所有语言',
            orderByUp: true,
            searchText: '',
            customStyles: tabStyle,
            historyItems: ['1111', '11111', '1111', '11111', '1111']
        };
    }
};

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(344)
)

/* script */
__vue_exports__ = __webpack_require__(345)

/* template */
var __vue_template__ = __webpack_require__(346)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\src\\tabView.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-7e66de78"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 344 */
/***/ (function(module, exports) {

module.exports = {
  "bar": {
    "flexDirection": "row",
    "backgroundColor": "#eaeaea",
    "borderRadius": "10"
  },
  "select-item": {
    "justifyContent": "center",
    "alignItems": "center",
    "flex": 1,
    "borderRadius": "5",
    "backgroundColor": "#FFFFFF",
    "marginTop": "5",
    "marginRight": "5",
    "marginBottom": "5",
    "marginLeft": "5"
  },
  "unselect-item": {
    "justifyContent": "center",
    "alignItems": "center",
    "flex": 1,
    "marginTop": "5",
    "marginRight": "5",
    "marginBottom": "5",
    "marginLeft": "5"
  },
  "item": {
    "textAlign": "center",
    "fontSize": "32",
    "flex": 1,
    "justifyContent": "center",
    "alignItems": "center"
  }
}

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
    props: {
        tabs: {
            type: Array,
            default: function _default() {
                return [];
            }
        }
    },
    name: "tabView",
    methods: {
        onSelect: function onSelect(index) {
            this.activeTab = index;
            this.$emit('select', {
                index: index
            });
        }
    },
    data: function data() {
        return {
            activeTab: 0
        };
    }
};

/***/ }),
/* 346 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["bar"]
  }, _vm._l((_vm.tabs), function(text, index) {
    return _c('div', {
      staticStyle: {
        flex: "1"
      }
    }, [(index === _vm.activeTab) ? _c('div', {
      key: "tab",
      staticClass: ["select-item"]
    }, [_c('text', {
      staticClass: ["item"]
    }, [_vm._v(_vm._s(text))])]) : _c('div', {
      staticClass: ["unselect-item"],
      on: {
        "click": function($event) {
          _vm.onSelect(index)
        }
      }
    }, [_c('text', {
      staticClass: ["item"]
    }, [_vm._v(_vm._s(text))])])])
  }))
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 347 */
/***/ (function(module, exports) {

module.exports = {}

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _reposItem = __webpack_require__(349);

var _reposItem2 = _interopRequireDefault(_reposItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
    components: {
        reposItem: _reposItem2.default
    },
    props: {
        items: {
            type: Array,
            default: function _default() {
                return [];
            }
        }
    },
    name: "reposList"
}; //
//
//
//
//
//
//
//
//

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(350)
)

/* script */
__vue_exports__ = __webpack_require__(351)

/* template */
var __vue_template__ = __webpack_require__(354)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\src\\reposItem.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-2dee455e"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 350 */
/***/ (function(module, exports) {

module.exports = {
  "item": {
    "flexDirection": "column",
    "backgroundColor": "#FFFFFF",
    "borderBottomWidth": "0.5",
    "borderBottomColor": "#dddddd"
  },
  "distribute": {
    "marginLeft": "100",
    "fontSize": "30",
    "lines": 5,
    "textOverflow": "ellipsis"
  },
  "tags-line": {
    "marginTop": "10",
    "marginRight": "60",
    "marginBottom": "10",
    "marginLeft": "100",
    "flexDirection": "row",
    "alignItems": "center",
    "justifyContent": "space-between"
  },
  "line1": {
    "flexDirection": "row",
    "marginTop": "30",
    "alignItems": "center",
    "marginBottom": "5"
  },
  "tag": {
    "flexDirection": "row",
    "alignItems": "center"
  },
  "title-text": {
    "fontSize": "35"
  },
  "icon": {
    "height": "50",
    "width": "50",
    "marginLeft": "30",
    "backgroundColor": "#238FFF",
    "borderRadius": "5"
  }
}

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

// 0        1            2       3             4           5       6       7        8
//["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"],
var star = __webpack_require__(352).default;
var branch = __webpack_require__(353).default;
exports.default = {
    props: {
        item: {
            type: Array
        }
    },
    name: "reposItem",
    data: function data() {
        return {
            starIcon: star,
            branchIcon: branch
        };
    }
};

/***/ }),
/* 352 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 353 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 354 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["item"]
  }, [_c('div', {
    staticClass: ["line1"]
  }, [_c('image', {
    staticClass: ["icon"]
  }), _c('div', {
    staticStyle: {
      flexDirection: "row"
    }
  }, [_c('text', {
    staticClass: ["title-text"],
    staticStyle: {
      marginLeft: "20px"
    }
  }, [_vm._v(_vm._s(_vm.item[1]))]), _c('text', {
    staticClass: ["title-text"]
  }, [_vm._v("/")]), _c('text', {
    staticClass: ["title-text"]
  }, [_vm._v(_vm._s(_vm.item[2]))])])]), _c('text', {
    staticClass: ["distribute"]
  }, [_vm._v(_vm._s(_vm.item[3]))]), _c('div', {
    staticClass: ["tags-line"]
  }, [_c('div', {
    staticClass: ["tag"]
  }, [_c('div', {
    staticStyle: {
      width: "25px",
      height: "25px",
      borderRadius: "30px",
      backgroundColor: "#238FFF"
    }
  }), _c('text', {
    staticStyle: {
      fontSize: "30px",
      marginLeft: "10px"
    }
  }, [_vm._v(_vm._s(_vm.item[6]))])]), _c('div', {
    staticClass: ["tag"]
  }, [_c('image', {
    staticStyle: {
      width: "30px",
      height: "30px"
    },
    attrs: {
      "src": _vm.starIcon
    }
  }), _c('text', {
    staticStyle: {
      fontSize: "30px",
      marginLeft: "10px"
    }
  }, [_vm._v(_vm._s((_vm.item[7])))])]), _c('div', {
    staticClass: ["tag"]
  }, [_c('image', {
    staticStyle: {
      width: "30px",
      height: "30px"
    },
    attrs: {
      "src": _vm.branchIcon
    }
  }), _c('text', {
    staticStyle: {
      fontSize: "30px",
      marginLeft: "10px"
    }
  }, [_vm._v(_vm._s(_vm.item[8]))])])])])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 355 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('list', _vm._l((_vm.items), function(item, index) {
    return _c('cell', {
      appendAsTree: true,
      attrs: {
        "append": "tree"
      }
    }, [_c('repos-item', {
      attrs: {
        "item": item
      }
    })], 1)
  }))
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 356 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 357 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 358 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["wrapper"]
  }, [_c('div', {
    staticClass: ["top-bar"]
  }, [_c('wxc-searchbar', {
    ref: "wxc-searchbar",
    staticClass: ["search-box"],
    on: {
      "wxcSearchbarCancelClicked": _vm.wxcSearchbarCancelClicked,
      "wxcSearchbarInputReturned": _vm.wxcSearchbarInputReturned,
      "wxcSearchbarInputOnInput": _vm.wxcSearchbarInputOnInput,
      "wxcSearchbarCloseClicked": _vm.wxcSearchbarCloseClicked,
      "wxcSearchbarInputOnFocus": _vm.wxcSearchbarInputOnFocus,
      "wxcSearchbarInputOnBlur": _vm.wxcSearchbarInputOnBlur
    }
  }), _c('div', {
    staticClass: ["select-bar"]
  }, [_c('div', {
    staticStyle: {
      flex: "1"
    }
  }), _c('tab-view', {
    staticStyle: {
      height: "60px",
      width: "500px"
    },
    attrs: {
      "tabs": ['仓库', '用户']
    }
  }), _c('div', {
    staticClass: ["right-item"]
  }, [_c('image', {
    staticStyle: {
      width: "50px",
      height: "50px"
    },
    attrs: {
      "src": _vm.optionsIcon
    }
  })])], 1)], 1), (_vm.searchText === '') ? _c('list', {
    staticClass: ["list"]
  }, [_c('header', {
    staticClass: ["header"],
    appendAsTree: true,
    attrs: {
      "append": "tree"
    }
  }, [_c('div', {
    staticClass: ["header2"]
  }, [_c('text', {
    staticStyle: {
      fontSize: "32px"
    }
  }, [_vm._v("搜索历史")]), _c('image', {
    staticStyle: {
      width: "50px",
      height: "50px"
    },
    attrs: {
      "src": _vm.cleanIcon
    }
  })])]), _vm._l((_vm.historyItems), function(text, index) {
    return _c('cell', {
      key: index,
      appendAsTree: true,
      attrs: {
        "append": "tree"
      }
    }, [_c('div', {
      staticClass: ["item"]
    }, [_c('text', {
      staticStyle: {
        fontSize: "32px"
      }
    }, [_vm._v(_vm._s(text))])])])
  })], 2) : _c('div', {
    staticClass: ["list"]
  }, [_c('div', {
    staticClass: ["header"]
  }, [_c('div', {
    staticClass: ["header2"]
  }, [_c('text', {
    staticStyle: {
      fontSize: "32px"
    }
  }, [_vm._v(_vm._s(_vm.lang) + " | " + _vm._s(_vm.orderByUp ? '最多star' : '最少star'))]), _c('image', {
    staticStyle: {
      width: "60px",
      height: "60px",
      backgroundColor: "#00B4FF"
    }
  })])]), _c('repos-list')], 1)])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(360)
)

/* script */
__vue_exports__ = __webpack_require__(361)

/* template */
var __vue_template__ = __webpack_require__(362)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\src\\star.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-c9d1dc50"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 360 */
/***/ (function(module, exports) {

module.exports = {}

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _weexUi = __webpack_require__(3);

var _reposList = __webpack_require__(31);

var _reposList2 = _interopRequireDefault(_reposList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
    components: {
        WxcMinibar: _weexUi.WxcMinibar,
        reposList: _reposList2.default
    },
    name: "star",
    data: function data() {
        return {
            items: [
            // 0        1            2       3             4           5       6       7        8
            ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"]]
        };
    }
};

/***/ }),
/* 362 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticStyle: {
      flex: "1"
    }
  }, [_c('wxc-minibar', {
    attrs: {
      "title": "我的star",
      "leftButton": "",
      "textColor": "black",
      "backgroundColor": "#FBFBFB"
    }
  }), _c('repos-list', {
    attrs: {
      "items": _vm.items
    }
  })], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(364)
)

/* script */
__vue_exports__ = __webpack_require__(365)

/* template */
var __vue_template__ = __webpack_require__(366)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\src\\hot.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-125890b7"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 364 */
/***/ (function(module, exports) {

module.exports = {}

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _weexUi = __webpack_require__(3);

var _reposList = __webpack_require__(31);

var _reposList2 = _interopRequireDefault(_reposList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//

exports.default = {
    name: "hot",
    components: {
        WxcMinibar: _weexUi.WxcMinibar,
        reposList: _reposList2.default
    },
    data: function data() {
        return {
            items: [
            // 0        1            2       3             4           5       6       7        8
            ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"], ["icon", "username", "repos", "distribute", "updateAt", "color", "lang", "star", "fork"]]
        };
    }
};

/***/ }),
/* 366 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticStyle: {
      flex: "1"
    }
  }, [_c('wxc-minibar', {
    attrs: {
      "title": "热门仓库",
      "leftButton": "",
      "textColor": "black",
      "backgroundColor": "#FBFBFB"
    }
  }), _c('repos-list', {
    attrs: {
      "items": _vm.items
    }
  })], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(368)
)

/* script */
__vue_exports__ = __webpack_require__(369)

/* template */
var __vue_template__ = __webpack_require__(370)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\src\\events.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-41336d9f"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 368 */
/***/ (function(module, exports) {

module.exports = {
  "text-root": {
    "flex": 1,
    "flexDirection": "column"
  },
  "line2": {
    "flexDirection": "row",
    "marginTop": "10",
    "marginLeft": "150",
    "marginBottom": "10"
  },
  "create-at": {
    "fontSize": "30",
    "marginLeft": "10"
  },
  "icon": {
    "height": "120",
    "width": "120",
    "backgroundColor": "#238FFF",
    "borderRadius": "10"
  },
  "item-wrapper": {
    "paddingTop": "15",
    "paddingLeft": "25",
    "paddingRight": "25"
  },
  "item": {
    "minHeight": "200",
    "borderRadius": "20",
    "backgroundColor": "#FFFFFF",
    "flexDirection": "column"
  }
}

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _weexUi = __webpack_require__(3);

exports.default = {
    components: {
        WxcMinibar: _weexUi.WxcMinibar
    },
    name: "events",
    methods: {
        onClick: function onClick() {}
    },
    data: function data() {
        return {
            items: [
            // 0                1           2             3
            ["username", "eventType", "eventTarget", "createAt"], ["username", "eventType", "eventTarget", "createAt"], ["username", "eventType", "eventTarget", "createAt"], ["username", "eventType", "eventTarget", "createAt"], ["username", "eventType", "eventTarget", "createAt"], ["username", "eventType", "eventTarget", "createAt"], ["username", "eventType", "eventTarget", "createAt"], ["username", "eventType", "eventTarget", "createAt"], ["username", "eventType", "eventTarget", "createAt"], ["username", "eventType", "eventTarget", "createAt"], ["username", "eventType", "eventTarget", "createAt"], ["username", "eventType", "eventTarget", "createAt"]]
        };
    }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 370 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticStyle: {
      flex: "1"
    }
  }, [_c('wxc-minibar', {
    attrs: {
      "title": "事件",
      "leftButton": "",
      "textColor": "black",
      "backgroundColor": "#FBFBFB"
    }
  }), _c('recycle-list', {
    appendAsTree: true,
    attrs: {
      "listData": _vm.items,
      "bindingExpression": "items",
      "alias": "item",
      "index": "index",
      "append": "tree"
    }
  }, [_c('cell-slot', {
    appendAsTree: true,
    attrs: {
      "append": "tree"
    }
  }, [_c('div', {
    staticClass: ["item-wrapper"]
  }, [_c('div', {
    staticClass: ["item"]
  }, [_c('div', {
    staticStyle: {
      flexDirection: "row",
      marginTop: "20px",
      marginLeft: "20px"
    }
  }, [_c('image', {
    staticClass: ["icon"]
  }), _c('div', {
    staticClass: ["text-root"]
  })]), _c('div', {
    staticClass: ["line2"]
  }, [_c('image', {
    staticStyle: {
      width: "40px",
      height: "40px",
      backgroundColor: "#238FFF"
    }
  }), _c('text', {
    staticClass: ["create-at"],
    attrs: {
      "value": ["在", {
        "@binding": "item[3]"
      }]
    }
  })])])])])], 1)], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 371 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 372 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 373 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 374 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 375 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 376 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 377 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 378 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 379 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 380 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),
/* 381 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('wxc-tab-bar', {
    attrs: {
      "tabTitles": _vm.titles,
      "tabStyles": _vm.tabStyles,
      "titleType": "icon"
    }
  }, [_c('div', {
    staticClass: ["item-container"]
  }, [_c('events', {
    staticStyle: {
      flex: "1"
    }
  })], 1), _c('div', {
    staticClass: ["item-container"]
  }, [_c('events', {
    staticStyle: {
      flex: "1"
    }
  })], 1), _c('div', {
    staticClass: ["item-container"]
  }, [_c('star', {
    staticStyle: {
      flex: "1"
    }
  })], 1), _c('div', {
    staticClass: ["item-container"]
  }, [_c('search', {
    staticStyle: {
      flex: "1"
    }
  })], 1), _c('div', {
    staticClass: ["item-container"],
    style: this['contentStyle']
  }, [_c('user', {
    staticStyle: {
      flex: "1"
    }
  })], 1)])
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(383)
)

/* script */
__vue_exports__ = __webpack_require__(384)

/* template */
var __vue_template__ = __webpack_require__(385)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\src\\setting.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-b68a4f8c"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 383 */
/***/ (function(module, exports) {

module.exports = {}

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
//
//
//
//

exports.default = {
    name: "setting"
};

/***/ }),
/* 385 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c("div")
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(387)
)

/* script */
__vue_exports__ = __webpack_require__(388)

/* template */
var __vue_template__ = __webpack_require__(389)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\src\\about.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-0ad49912"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 387 */
/***/ (function(module, exports) {

module.exports = {
  "image-root": {
    "borderWidth": "0.5",
    "borderColor": "#dddddd",
    "borderRadius": "25",
    "paddingTop": "25",
    "paddingRight": "35",
    "paddingBottom": "25",
    "paddingLeft": "35",
    "backgroundColor": "#FFFFFF",
    "marginTop": "100"
  },
  "image": {
    "width": "429",
    "height": "135"
  },
  "item-group": {
    "flexDirection": "column",
    "paddingLeft": "30",
    "paddingRight": "20",
    "marginTop": "50",
    "width": "750",
    "backgroundColor": "#FFFFFF"
  },
  "item": {
    "alignItems": "center",
    "height": "80",
    "borderBottomWidth": "0.5",
    "borderBottomColor": "#dddddd",
    "flexDirection": "row",
    "backgroundColor": "#FFFFFF"
  }
}

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _weexUi = __webpack_require__(3);

exports.default = {
    components: {
        WxcMinibar: _weexUi.WxcMinibar
    },
    name: "about",
    methods: {},
    data: function data() {
        return {
            items: ["作者", "URL识别", "推荐给好友"]
        };
    }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){
var this$1 = this;
var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticStyle: {
      flexDirection: "column",
      backgroundColor: "whitesmoke",
      width: "750px"
    }
  }, [_c('wxc-minibar', {
    attrs: {
      "title": "关于",
      "textColor": "black",
      "backgroundColor": "#FBFBFB"
    }
  }, [_c('div', {
    staticStyle: {
      width: "60px",
      height: "60px",
      justifyContent: "center",
      alignItems: "center"
    },
    attrs: {
      "slot": "left"
    },
    on: {
      "click": function () {
        this$1.$router.back()
      }
    },
    slot: "left"
  }, [_c('image', {
    staticStyle: {
      width: "40px",
      height: "40px"
    },
    attrs: {
      "src": __webpack_require__(390).default
    }
  })])]), _c('scroller', {
    attrs: {
      "alwaysScrollableVertical": "true"
    }
  }, [_c('div', {
    staticStyle: {
      flexDirection: "column",
      alignItems: "center"
    }
  }, [_c('div', {
    staticClass: ["image-root"]
  }, [_c('image', {
    staticClass: ["image"],
    attrs: {
      "src": __webpack_require__(53).default
    }
  })]), _c('text', {
    staticStyle: {
      fontSize: "45px",
      marginTop: "40px"
    }
  }, [_vm._v("Gitee Weex")]), _c('div', {
    staticClass: ["item-group"]
  }, _vm._l((_vm.items), function(item, index) {
    return _c('div', {
      staticClass: ["item"]
    }, [_c('text', {
      staticStyle: {
        fontSize: "30px",
        flex: "1"
      }
    }, [_vm._v(_vm._s(item))]), _c('image', {
      staticStyle: {
        height: "30px",
        width: "30px",
        marginRight: "20px"
      },
      attrs: {
        "src": __webpack_require__(62).default
      }
    })])
  }))])])], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ }),
/* 390 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAJkUlEQVR4Xu2da2wcVxXHz7m7q3oTU5mCVCQkSPiCoAgQEmqcOoSGUEpKK4KoQS0gXm1AoQZZu/euFUS3iNg7M8ZBpgFCSwWlIAiCVEBD2kQl4dEPjdQiQUWQQDFSkIpAASPHNt3dOeiWteL4ubNnZj2Ps199z7n3/v+/c+7seHcWQV6ZVgAzvXvZPAgAGYdAABAAMq5AxrcvHSAkACYmJorNZvN6mw4RL5VKpbMhpY40jQDAlHd0dPRluVzu8wDwCUR8yUI6InoOAMaMMd9jThFpuADAkLdl/hlEvG61NET0C2PMHsY0kYYKAB3KOzExcU2j0fglALxxvRRE9A1jzKfXG7cRfxcAOlDdml+v159ExDe1G05ErzfG/LHd8d0aJwAEVPrQoUN99Xr9TDuVvyS10Vq7AaeLfLgAEEDiycnJq+fn523bf0uAsIWhD2qt7+ogLtIQAaBNeZnmAxE9YIy5u83pujZMAGhD6sOHD/deunTpFAC8+D6/w9eQ1vqrHcZGFiYArCOtNX9mZuYkIm7juFCv119x4MCBv3NyRBErAKyhaqvynwCAfo74RDRpjPksJ0dUsQLAKspWq9VNmzZtsubfwBT/mdnZ2Ruq1eo8M08k4QLACrLa+/r1ev0JRBzgqE5Ev/d9f+fIyMi/OHmijBUAlqibJfPt1gWARQBMTk5eNTc3d4pb+QBwrtlsbo9z5S9sWwBoKWHNn5+fPw4Au5gt95xSakepVPonM09XwgUAAMiq+XIEAMCRI0cK09PTJ7iVT0R/zuVy/UmpfDkCLpv/UwC4mdNvrfmNRmMgjjd61ttXZo+AVuVn2vzMHgFHjx7NTU1N/TyEyp9qNBrbklj5mT0CrPnnz5//CSLetl57XOvvRDRVKBQGhoeH/8bJs9GxmToCxPzluGUGgGq1qorF4rEQKv9CoVDYlvTKz9QR0DL/h4j4fk7LJaILuVxuoFQq/ZWTJ06xqe8AYv7auKUaACJC13WPcisfAJ5XSm1LU+Wn/ghomf9dRLyT2XKfB4ABrfVfmHliGZ7KDiDmt89aKgFwHOcRbuUT0T8QsT+tlZ/aI8B13W8BwMfbr4HlI635ALDDGPMnTp4kxKaqA4j5wZFLDQBhmA8AF4loexYqP1VHgOu6XwMA7rdvLyLiznK5/IfgdZTciMR3ADGfB1+iAQjDfCKaVkoNZK3yE38EOI5zCBE/x+Hfmu/7/o0jIyPPcvIkOTaRHUDMDw+5xAEQkvkzvu+/LcuVn8gjwHXdMQCocPgnohkAeIcx5mlOnrTEJqYDuK57HwB8gSO8mJ/QTwQ5jmMQscY0fxYAbpTKv1LF2HeAsMxHxJu01r/lQJTG2FgD4LqufajCVzjCE9GsmL+6grEFICTz5xFxt1R+wgAIy3wA2GOMsY91k9cqCsSuAziO8ylE/DrHMSKyj2MR89sQMVYAhGT+C/YrX1L5bbgfpyeEhGU+Ed1WqVQeb2/7MioWHcBxnI8h4kMcO4joBTE/uIIbDkDLfPs5vo7XQkQNInqPVH7CAAjLfKXU+8rl8s+Cb18iOq46rnSe591BRI9wK1/M5zmxIQC4rrsfAOyDkznzNxFxr1R+wgDwPO9LRHSAt+wXowe11j8KIU+mU3AqMLBwo6Oj/fl83v5DhjNvEwA+oLX+ceAFSMAyBThGBJbTdd1pALg6cGArgIh8RLSVL+Z3KuKSuK4B4LruTQDQ8Q0aa75S6sPlcvn7Ie1d0jBbcSABPc+7l4iqgYIuD7aVL+Z3KN5aYV3rAJ7nfZmIhjvdAxHdY4y5v9N4iVtZga4BwD0CWssva63HxczwFOgaAPahDZ7n2St47pwCQXj+s80ItBTXdb8DAB8JFLTyYIEgBBFtCm41Bl6G4zjHEfHdgQOXBBDRfcaYTi8qudOnJr7rAFjlPM9ziai8VEUiAsRASxrXWi/Lkxp3urCRQGqHuR7HcT6DiGH8kKJAwDBmwwCwaxYIGM6FFLqhAAgEIbnISLPhAIQJARHdb4y5h6FH5kJjAYBVvVar3aWU+ibXAYEgmIKxAUAgCGZcWKNjBcAiCI5w71EQ0QPGmLvDEiqteWIHgBXadV17t/DbAkH02MUSAIEgeuMXZogtAGFDoLXeh4jUPWmTMVOsAQgTAgB4uFwuf1QguBLM2APQujD8oFLKfhSMu16BYElj4gratT5Xq9UEggjUTgwAizqB/TZRjqmFdIKWgIkCwK7Z87y9RGS/EMKCgIh+oLW+I+vXBIkDQCBg9r6kXgMs3bbtBL7v25+Ey3MksZ1g69atHxocHLSfV8zcK5EdYMGlWq12CyI+yoUAAI5t2bLl9ixCkGgAWheGAgGjbyUeAIGA4X4IN1Z4s4cYbY8DpdQxACgw0x6bnZ0drFarDWaeRISnogMsKO04zjsR8TEuBET02Nzc3HuzAEGqALAgCATBGk/qAFgEgX1o1FXB5LhytO0EfX19e/ft21fn5IlzbCoBaN0sejsRnQgBgpN9fX23pBWC1AIgELTXd1INgECwPgSpB2ARBMcBoLi+JKuPIKKTxWLx1qGhof9y8sQpNhMAtG4WbVdKneJCAACne3p6bk4LBJkBQCBYue9kCoAFCBDxcUTsZbbi0/l8fs/w8PAcM8+GhmcOAKv2+Pj4W5vN5pNcCIjoqUKhsDvJEGQSAIHgctPJLAACwf8hyDQACxD4vm/fHXT8CFubxx4Hvb2979q/f7/9beLEvDIPgHXKdd03A8AZLgQAcHbz5s27kgSBANCq1axCIAAsatYWAiKy7w5eyuzhZ3t6enYPDQ39h5kn8nABYInEtVrtOkT8dQgQ/K6np2dn3CEQAFaosSxBIACs0mSzAoEAsMYpayFQSp0GgJdzDmMierqvr28gjh8qEQDWcdZxnNci4m+4EADAvVrrL3JAiiJWAGhD1ZAg+He5XL4mbl9GFQDaAMAOsRDYm0WIeG2bIcuGKaVeVyqVznUaH0WcABBA1bGxsdcopZ7qFALf93dUKhV7nMTmJQAEtIIDge/7b6hUKs8FnDLS4QJAB/JaCHK53K8A4JXthhPRBa31q+QaoF3FYj5ufHz81b7v219BbQsCIqoYY5y4bUs6AMORdiEgomeLxWJ/HD9IKgAwALChBw8evLZQKNhH2O1aJdWJfD5/5/Dw8EXmVJGECwAhyGp/Es9xnE8qpW4FgOsBwH6X8BkAeFRr/VAIU0SWQgCITNpkJBYAkuFTZKsUACKTNhmJBYBk+BTZKgWAyKRNRmIBIBk+RbbK/wFzHCy9LWOblwAAAABJRU5ErkJggg==");

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

var __vue_exports__, __vue_options__
var __vue_styles__ = []

/* styles */
__vue_styles__.push(__webpack_require__(392)
)

/* script */
__vue_exports__ = __webpack_require__(393)

/* template */
var __vue_template__ = __webpack_require__(394)
__vue_options__ = __vue_exports__ = __vue_exports__ || {}
if (
  typeof __vue_exports__.default === "object" ||
  typeof __vue_exports__.default === "function"
) {
if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
__vue_options__ = __vue_exports__ = __vue_exports__.default
}
if (typeof __vue_options__ === "function") {
  __vue_options__ = __vue_options__.options
}
__vue_options__.__file = "C:\\Users\\Luke\\Desktop\\weex\\gitee-weex\\src\\index.vue"
__vue_options__.render = __vue_template__.render
__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
__vue_options__._scopeId = "data-v-1a4d8e3c"
__vue_options__.style = __vue_options__.style || {}
__vue_styles__.forEach(function (module) {
  for (var name in module) {
    __vue_options__.style[name] = module[name]
  }
})
if (typeof __register_static_styles__ === "function") {
  __register_static_styles__(__vue_options__._scopeId, __vue_styles__)
}

module.exports = __vue_exports__


/***/ }),
/* 392 */
/***/ (function(module, exports) {

module.exports = {
  "wrapper": {
    "justifyContent": "center",
    "alignItems": "center"
  },
  "content": {
    "flex": 1
  }
}

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = __webpack_require__(7);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _gitee = __webpack_require__(10);

var _gitee2 = _interopRequireDefault(_gitee);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } //
//
//
//
//
//

var modal = weex.requireModule('modal');

exports.default = {
    name: 'App',
    created: function created() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
            return _regenerator2.default.wrap(function _callee$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                        case 'end':
                            return _context.stop();
                    }
                }
            }, _callee, _this);
        }))();
    },
    data: function data() {
        return {};
    }
};

/***/ }),
/* 394 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: ["wrapper"],
    staticStyle: {
      flex: "1"
    }
  }, [_c('router-view', {
    staticClass: ["content"]
  })], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true

/***/ })
/******/ ]);